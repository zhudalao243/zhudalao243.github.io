<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang中的GC垃圾回收机制</title>
    <url>/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Golang中的GC垃圾回收机制"><a href="#Golang中的GC垃圾回收机制" class="headerlink" title="Golang中的GC垃圾回收机制"></a>Golang中的GC垃圾回收机制</h1><h2 id="Go-1-3-标记清除-mark-and-sweep"><a href="#Go-1-3-标记清除-mark-and-sweep" class="headerlink" title="Go 1.3 标记清除(mark and sweep)"></a>Go 1.3 标记清除(mark and sweep)</h2><blockquote>
<p>流程：</p>
<ol>
<li>暂停程序业务逻辑, 找出不不可达的对象，和可达对象。</li>
<li>开始标记，程序找出它所有可达的对象，并做上标记。</li>
<li>标记完了了之后，然后开始清除未标记的对象.</li>
<li>停⽌止暂停，让程序继续跑。然后循环重复这个过程，直到process程序⽣生命周期结束。</li>
</ol>
<p>缺点：</p>
<ol>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。将第四步和第三步换位置， 缩短STW的范围</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产⽣生heap碎⽚。</li>
</ol>
</blockquote>
<h2 id="Go-1-5-三色标记法"><a href="#Go-1-5-三色标记法" class="headerlink" title="Go 1.5 三色标记法"></a>Go 1.5 三色标记法</h2><p>流程：</p>
<ol>
<li>只要是新创建的对象,默认的颜⾊色都是标记为“⽩白⾊色”.</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202056508.png" alt="image-20210815202056508" style="zoom:40%;">

<ol start="2">
<li><p>每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202153446.png" alt="image-20210815202153446" style="zoom:40%;"></li>
<li><p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202305099.png" alt="image-20210815202305099" style="zoom:40%;">

<ol start="4">
<li><p>重复第三步, 直到灰⾊色中⽆无任何对象.</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202348203.png" alt="image-20210815202348203" style="zoom:30%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202439107.png" alt="image-20210815202439107" style="zoom:30%;"></center></li>
<li><p>回收所有的白色标记表的对象. 也就是回收垃圾.</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202557320.png" alt="image-20210815202557320" style="zoom:40%;">

<h2 id="如果三色标记法不被STW保护"><a href="#如果三色标记法不被STW保护" class="headerlink" title="如果三色标记法不被STW保护"></a>如果三色标记法不被STW保护</h2><p><em>条件1: ⼀一个白色对象被⿊黑色对象引用(白色被挂在黑色下).</em></p>
<p><em>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</em></p>
<p><em>两个条件同时满⾜足，那么就会出现对象丢失的现象</em></p>
<p>样例：</p>
<p>如果不开启STW：</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203317889.png" alt="image-20210815203317889" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203356122.png" alt="image-20210815203356122" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203423861.png" alt="image-20210815203423861" style="zoom:25%;"></center>



<h2 id="强弱三色不变式"><a href="#强弱三色不变式" class="headerlink" title="强弱三色不变式"></a>强弱三色不变式</h2><h3 id="强三⾊色不不变式"><a href="#强三⾊色不不变式" class="headerlink" title="强三⾊色不不变式"></a>强三⾊色不不变式</h3><p>破坏条件1</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213638805.png" alt="image-20210815213638805" style="zoom:33%;">

<h3 id="弱三⾊色不不变式"><a href="#弱三⾊色不不变式" class="headerlink" title="弱三⾊色不不变式"></a>弱三⾊色不不变式</h3><p>破坏条件2</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213703432.png" alt="image-20210815213703432" style="zoom:40%;">

<p>如果三色标记满足强弱不变式之一，即可保证不丢失对象.</p>
<h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>屏障？程序运行过程中额外添加的判断机制。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213927896.png" alt="image-20210815213927896" style="zoom:50%;">

<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>插入屏障： 对象被引用时，触发的机制。</p>
<p>具体操作： 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p>满足: 强三色不不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	标记灰⾊色(新下游对象ptr)</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)  //A对象，删除B对象的引⽤用。 B被A删除，被标记为灰(如果B之前为⽩)</span><br><span class="line">A.添加下游对象(B, C) //A对象，更更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩)</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214828157.png" alt="image-20210815214828157" style="zoom:50%;">

<p>插入写屏障只在堆上触发，在栈上不触发。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214950520.png" alt="image-20210815214950520" style="zoom:26%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215043176.png" alt="image-20210815215043176" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215126841.png" alt="image-20210815215126841" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215308921.png" alt="image-20210815215308921" style="zoom:33%;">

<p>由于栈上不触发插入写屏障，所以在准备回收白色前，需要加STW暂停保护重新扫描一遍栈空间。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215334937.png" alt="image-20210815215334937" style="zoom:33%;">

<p>不足：结束时需要STW来重新扫描栈，⼤大约需要10~100ms</p>
<h3 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h3><p>删除屏障：对象被删除时 触发的机制。</p>
<p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	<span class="keyword">if</span> (当前下游对象slot是灰⾊色 || 当前下游对象slot是⽩白⾊色) &#123;</span><br><span class="line">		标记灰⾊色(当前下游对象slot) //slot为被删除对象， 标记为灰⾊色</span><br><span class="line">	&#125;</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<p>​    A.添加下游对象(B, nil) //A对象，删除B对象的引⽤用。 B被A删除，被标记为灰(如果B之前为⽩白)<br>​    A.添加下游对象(B, C) //A对象，更更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩白)</p>
<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220252392.png" alt="image-20210815220252392" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220332343.png" alt="image-20210815220332343" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220413361.png" alt="image-20210815220413361" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220435567.png" alt="image-20210815220435567" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220500445.png" alt="image-20210815220500445" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220533566.png" alt="image-20210815220533566" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220552303.png" alt="image-20210815220552303" style="zoom:40%;">

<p>不足： 回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理理掉。</p>
<h2 id="Go-1-8-混合写屏障机制"><a href="#Go-1-8-混合写屏障机制" class="headerlink" title="Go 1.8 混合写屏障机制"></a>Go 1.8 混合写屏障机制</h2><blockquote>
<p>具体操作:</p>
<ol>
<li>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ol>
<p>满足: 变形的弱三色不变式. (结合了插入、删除写屏障两者的优点)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">    //1</span><br><span class="line">    标记灰⾊色(当前下游对象slot) //只要当前下游对象被移⾛走，就标记灰⾊色</span><br><span class="line">    //2</span><br><span class="line">    标记灰⾊色(新下游对象ptr)</span><br><span class="line">    //3</span><br><span class="line">    当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221417608.png" alt="image-20210815221417608" style="zoom:25%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221437818.png" alt="image-20210815221437818" style="zoom:50%;">

<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>对象被一个堆对象删除引用，成为栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">//前提：堆对象4-&gt;对象7 = 对象7； //对象7 被 对象4引⽤用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7； //将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222017066.png" alt="image-20210815222017066" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222032431.png" alt="image-20210815222032431" style="zoom:33%;">

<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>对象被一个栈对象删除引用，成为另一个栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象9-&gt;对象3 = 对象3； //将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 = null； //对象2 删除引⽤用 对象3</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222315895-1629105238588.png" alt="image-20210815222315895" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222346906-1629105238588.png" alt="image-20210815222346906" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222407645-1629105238589.png" alt="image-20210815222407645" style="zoom:50%;">

<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>对象被一个堆对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7； //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222602561-1629105297759.png" alt="image-20210815222602561" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222619017-1629105297759.png" alt="image-20210815222619017" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222633300-1629105297758.png" alt="image-20210815222633300" style="zoom:50%;">

<h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>对象从一个栈对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈对象1-&gt;对象2 = null； //对象1 删除引⽤用 对象2</span><br><span class="line">堆对象4-&gt;对象7 = null; //对象4 删除引⽤用 对象7</span><br><span class="line">堆对象4-&gt;对象2 = 栈对象2； //对象4 添加 下游 栈对象2</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222835930.png" alt="image-20210815222835930" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222852740.png" alt="image-20210815222852740" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222910678.png" alt="image-20210815222910678" style="zoom:50%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go V1.3 普通的标记清除法， 整体过程需要STW，效率极低</p>
<p>Go V1.5 三⾊色标记法， 堆空间启动写屏障，栈空间不启动， 全部扫描之后，需要重新扫描⼀一次栈(需要STW)， 效率普通</p>
<p>Go V1.8 三⾊色标记法，混合写屏障机制， 栈空间不不启动，堆空间启动， 整体过程⼏几乎不不需要STW， 效率较高</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>周易基础及其应用01</title>
    <url>/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/</url>
    <content><![CDATA[<h1 id="周易基础及应用"><a href="#周易基础及应用" class="headerlink" title="周易基础及应用"></a>周易基础及应用</h1><p>千古奇书《周易》</p>
<p>人更三圣：伏羲    周文王    孔夫子</p>
<p>事历三古：远古    中古         近古</p>
<p>《易经》它是以八卦为核心，以卦的形式来说明问题，以阴爻和阳爻来说明问题，以阴爻和阳爻的相互配合，以文字系统与符号系统相结合说明万事万物的根本规律。</p>
<p>《易经》为群经之首。</p>
<p>系词： <strong>夫《易》何为者也，开物成务斯如此也。</strong>  开物成务：开物是认识事物的本质，成务是怎么去解决这个问题。</p>
<p><strong>不善易者，不得为将相。</strong>   </p>
<p><strong>不知易不足以言大医。   ————孙思邈</strong></p>
<p>易道广大，无所不包。</p>
<p>《易》与天地准，故能弥纶天地之道。</p>
<p>百姓日用而不知。</p>
<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815150334560.png" alt="image-20210815150334560" style="zoom:33%;">

<h2 id="阴阳学说"><a href="#阴阳学说" class="headerlink" title="阴阳学说"></a>阴阳学说</h2><p>易以道阴阳。 ——庄子</p>
<p>天地间无往而非阴阳，一动一静一语一默，皆是阴阳之理。 ———朱熹</p>
<p>阳：天    上    昼    男    君    贵    福 ….</p>
<p>阴：地    下    夜    女    臣    贱    祸 ….</p>
<p><strong>一阴一阳之谓道。</strong></p>
<p>主要内容：</p>
<ul>
<li>阴阳对立</li>
<li>阴阳依存（互根）。有无相生，难易相成，长短相盈，高低相形，音声相合，前后相随，恒也。</li>
<li>阴阳消长。阴阳动态变化，动态平衡。阴盛则阳病，阳盛则阴病。</li>
<li>阴阳转换。消长属于量变，转化属于质变。</li>
</ul>
<p>中国哲学三大问题：天人、群己、身心</p>
<p>重视对立，追求平衡。</p>
<h2 id="五行学说"><a href="#五行学说" class="headerlink" title="五行学说"></a>五行学说</h2><p>世界上的万事万物的运动和发生发展都是”金木水火土“这五种状态，相互作用、相互运动的结果。  ——&gt;系统观</p>
<h3 id="五行特点"><a href="#五行特点" class="headerlink" title="五行特点"></a>五行特点</h3><blockquote>
<p>五行顺序              特性        方位    五德            季节</p>
<p>一曰水    润下    润下寒冷    北方    智               冬季</p>
<p>二曰火    炎上    炎热向上    南方    礼               夏季</p>
<p>三曰木    曲直    生发条达    东方    仁               春季</p>
<p>四曰金    从草    清凉萧杀    西方    义                秋季</p>
<p>五曰土    稼穑    长养化育    中央    信      农历（三、六、九、十二月）</p>
</blockquote>
<h3 id="五行生克"><a href="#五行生克" class="headerlink" title="五行生克"></a>五行生克</h3><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815160518695.png" alt="image-20210815160518695" style="zoom:33%;">

<h3 id="五行的旺、相、休、囚、死"><a href="#五行的旺、相、休、囚、死" class="headerlink" title="五行的旺、相、休、囚、死"></a>五行的旺、相、休、囚、死</h3><p>生克制化之理</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">旺</th>
<th align="center">相</th>
<th align="center">死</th>
<th align="center">囚</th>
<th align="center">休</th>
</tr>
</thead>
<tbody><tr>
<td align="center">春</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
</tr>
<tr>
<td align="center">夏</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
</tr>
<tr>
<td align="center">秋</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
</tr>
<tr>
<td align="center">冬</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
</tr>
<tr>
<td align="center">四季</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
</tr>
</tbody></table>
<h2 id="天干地支"><a href="#天干地支" class="headerlink" title="天干地支"></a>天干地支</h2><h3 id="十天干"><a href="#十天干" class="headerlink" title="十天干"></a>十天干</h3><blockquote>
<p>甲        乙        丙        丁        戊        己        庚        辛        壬        癸</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">甲乙同属木</td>
<td>东方</td>
<td>甲阳木</td>
<td>乙阴木</td>
</tr>
<tr>
<td align="center">丙丁同属火</td>
<td>南方</td>
<td>丙阳火</td>
<td>丁阴火</td>
</tr>
<tr>
<td align="center">戊己同属土</td>
<td>中央</td>
<td>戊阳土</td>
<td>己阴土</td>
</tr>
<tr>
<td align="center">庚辛同属金</td>
<td>西方</td>
<td>庚阳金</td>
<td>辛阴金</td>
</tr>
<tr>
<td align="center">壬癸同属水</td>
<td>北方</td>
<td>壬阳水</td>
<td>癸阴水</td>
</tr>
</tbody></table>
<h4 id="天干相和"><a href="#天干相和" class="headerlink" title="天干相和"></a>天干相和</h4><blockquote>
<p>甲己合土</p>
<p>乙庚合金</p>
<p>丙辛合水</p>
<p>丁壬合木</p>
<p>戊癸合火</p>
</blockquote>
<h4 id="十天干的相生相克"><a href="#十天干的相生相克" class="headerlink" title="十天干的相生相克"></a>十天干的相生相克</h4><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165629369.png" alt="image-20210815160518695">

<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165743365.png" alt="image-20210815160518695">

<h3 id="地支"><a href="#地支" class="headerlink" title="地支"></a>地支</h3><p>P8</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>周易基础及其应用</category>
      </categories>
  </entry>
  <entry>
    <title>对称加密</title>
    <url>/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>常用的两种加密方式 </p>
<p>对称加密</p>
<ul>
<li>秘钥: 加密解密使用的是同一个秘钥, 秘钥有一个</li>
<li>特点<ul>
<li>双方向保证机密性</li>
<li>加密效率高, 适合加密大数据, 大文件</li>
<li>加密强度不高, 相对于非对称加密</li>
</ul>
</li>
</ul>
<p>非对称加密</p>
<ul>
<li>秘钥: 加密解密使用的不同的秘钥, 秘钥有两个, 需要使用秘钥生成算法, 得到密钥对<ul>
<li>公钥 - 可以公开的秘钥<ul>
<li>公钥加密数据, 解密需要使用私钥</li>
</ul>
</li>
<li>私钥 - 需要妥善保管的秘钥, 知道的人越少越好<ul>
<li>私钥加密, 公钥解密</li>
</ul>
</li>
</ul>
</li>
<li>特点:<ul>
<li>数据的机密性只能单方向保证</li>
<li>加密效率低, 适合加密少量数据</li>
<li>加密强度高, 相对于对称加密</li>
</ul>
</li>
</ul>
</li>
<li><p>密码信息安全常识 </p>
<ul>
<li><p>不要使用保密的密码算法（普通公司和个人）</p>
</li>
<li><p>使用低强度的密码比不进行任何加密更危险</p>
</li>
<li><p>任何密码总有一天都会被破解</p>
</li>
<li><p>密码只是信息安全的一部分                </p>
</li>
</ul>
</li>
<li><p>密码信息威胁 </p>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816230646529.png" alt="image-20210816230646529" style="zoom:70%;"></li>
</ol>
<h2 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h2><blockquote>
<p>“对称加密: 也称为对称密码, 是指在加密和解码时使用同一秘钥的加密方式”</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231137633.png" alt="image-20210816231137633" style="zoom:50%;">

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote>
<p>现代的密码都是建立在计算机的基础之上的，这是因为现代的密码所处理的数据量非常大，而且密码算法也非常复杂，不借助计算机的力量就无法完成加密和解密的操作。</p>
<p>计算机的操作对象并不是文字，而是由0和1排列而成的<strong>比特序列</strong>。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>
<p>将现实世界中的东西映射为比特序列的操作称为<strong>编码（encoding）</strong>。例如midnight（深夜）这个词，我们可以对其中的每个字母逐一进行编码，这种编码规则叫作<strong>ASCII</strong>。</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231349119.png" alt="image-20210816231349119" style="zoom:67%;">

<blockquote>
<p>注意这里的m –&gt; 01101101这一转换并不是加密而是编码。尽管在人类看来0和1的序列跟密码没什么两样，但计算机却可以“看懂”这些比特序列，并很快地反应出其所对应的字符 <strong>midnight</strong></p>
</blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>DES是一种将64比特的明文加密成64比特的密文的对称密码算法，==它的密钥长度是56比特==。尽管<font color="red">从规格上来说，DES的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上其密钥长度是56比特</font>。</p>
<p><font color="red">DES是以64比特的明文（比特序列）为一个单位来进行加密的</font>，<strong>这个64比特的单位称为分组</strong>。一般来说，以分组为单位进行处理的密码算法称为<strong>分组密码（blockcipher）</strong>，DES就是分组密码的一种。</p>
<p>DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。</p>
<p>大B -&gt; bit</p>
<p>小b -&gt; byte</p>
<p>秘钥长度(56bit + 8bit)/8 = 8byte   12345678</p>
</blockquote>
<h4 id="DES的加密与解密-图例"><a href="#DES的加密与解密-图例" class="headerlink" title="DES的加密与解密 - 图例"></a>DES的加密与解密 - 图例</h4><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231818006.png" alt="image-20210816231818006" style="zoom:80%;">

<h4 id="DES小结"><a href="#DES小结" class="headerlink" title="DES小结"></a>DES小结</h4><ul>
<li>现在使用DES方式加密，数据还安全吗？<ul>
<li>不安全, 已经被破解了  </li>
</ul>
</li>
<li>是不是分组密码？<ul>
<li>是, 先对数据进行分组, 然后在加密或解密</li>
</ul>
</li>
<li>DES的分组长度?<ul>
<li>8byte == 64bit</li>
</ul>
</li>
<li>DES的秘钥长度?<ul>
<li>56bit秘钥长度+8bit错误检测标志位 = 64bit == 8byte</li>
</ul>
</li>
</ul>
<h3 id="3DES-–-Triple-DES"><a href="#3DES-–-Triple-DES" class="headerlink" title="3DES  –   Triple-DES"></a>3DES  –   Triple-DES</h3><blockquote>
<p>现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码，三重DES就是出于这个目的被开发出来的。</p>
<p><strong>三重DES（triple-DES）是为了增加DES的强度，==将DES重复3次所得到的一种密码算法==，通常缩写为3DES</strong>。</p>
</blockquote>
<h4 id="加密和解密-1"><a href="#加密和解密-1" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>三重DES的加解密机制如图所示：</p>
<p>加-&gt;解-&gt;加 -&gt; 目的是为了兼容des</p>
<p>3des秘钥长度24字节 = 1234567a 1234567b 1234567a</p>
</blockquote>
<center><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102851239.png" alt="image-20210817102851239" style="zoom:50%;">!<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102916694.png" alt="image-20210817102916694 " style="zoom:50%;"></center>

<blockquote>
<p>明文经过三次DES处理才能变成最后的密文，由于<strong>DES密钥的长度实质上是56比特</strong>，因此<font color="red">三重DES的密钥长度就是56×3=168比特, 加上用于错误检测的标志位8x3, 共192bit</font>。</p>
<p>从上图我们可以发现，三重DES并不是进行三次DES加密（加密–&gt;加密–&gt;加密），而是<font color="red"><strong>加密–&gt;解密–&gt;加密</strong></font>的过程。在加密算法中加人解密操作让人感觉很不可思议，实际上这个方法是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES。</p>
<p><font color="red">当三重DES中所有的密钥都相同时，三重DES也就等同于普通的DES了</font>。这是因为在前两步加密–&gt;解密之后，得到的就是最初的明文。因此，以前用DES加密的密文，就可以通过这种方式用三重DES来进行解密。也就是说，三重DES对DES具备向下兼容性。</p>
<p>如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个DES密钥），这种三重DES就称为DES-EDE2。EDE表示的是加密（Encryption) –&gt;解密（Decryption)–&gt;加密（Encryption）这个流程。</p>
<p>密钥1、密钥2、密钥3全部使用不同的比特序列的三重DES称为DES-EDE3。</p>
<p>尽管三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题。</p>
</blockquote>
<h4 id="3DES小结"><a href="#3DES小结" class="headerlink" title="3DES小结"></a>3DES小结</h4><ul>
<li>3DES安全吗?<ul>
<li>安全, 但是效率低</li>
</ul>
</li>
<li>算法描述?<ul>
<li>进行了3次des加密</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>3DES分组长度?<ul>
<li>8字节</li>
</ul>
</li>
<li>3DES秘钥长度?<ul>
<li>24字节, 在算法内部会被平均分成3份</li>
</ul>
</li>
<li>3DES加密过程?<ul>
<li>秘钥1 -&gt; 加密, 秘钥2 -&gt; 解密, 秘钥3 -&gt; 加密</li>
</ul>
</li>
<li>3DES解密过程?<ul>
<li>秘钥1 -&gt; 解密, 秘钥2 -&gt; 加密, 秘钥3 -&gt; 解密</li>
</ul>
</li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><blockquote>
<p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码算法。全世界的企业和密码学家提交了多个对称密码算法作为AES的候选，最终在2000年从这些候选算法中选出了一种名为==<strong>Rijndael</strong>==的对称密码算法，并将其确定为了AES。</p>
</blockquote>
<blockquote>
<p>**==Rijndael的分组长度为128比特==**，密钥长度可以以32比特为单位在128比特到256比特的范围内进行选择（不过==<strong>在AES的规格中，密钥长度只有128、192和256比特三种</strong>==）。</p>
<p>128bit = 16字节</p>
<p>192bit = 24字节</p>
<p>256bit = 32字节</p>
<p>在go提供的接口中秘钥长度只能是16字节</p>
</blockquote>
<h4 id="AES小结"><a href="#AES小结" class="headerlink" title="AES小结"></a>AES小结</h4><ul>
<li>AES安全吗?<ul>
<li>安全, 效率高, 推荐使用的</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>AES分组长度?<ul>
<li>128bit = 16字节</li>
</ul>
</li>
<li>AES秘钥长度?<ul>
<li>128bit = 16字节</li>
<li>192bit = 24字节</li>
<li>256bit = 32字节</li>
<li>go中的秘钥长度只能是16字节</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码的模式</title>
    <url>/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;分组密码的模式 -- 分组密码是如何迭代的&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DES和AES都属于分组密码，只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。</p>
<p>分组密码有很多种模式，如果模式的选择不恰当，就无法保证机密性。例如，如果使用ECB模式，明文中的一些规律就可以通过密文被识别出来。</p>
<p>分组密码的主要模式（ECB、CBC、CFB、OFB、CTR）</p>
</blockquote>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><blockquote>
<p><strong>分组密码（blockcipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的一块”就称为分组（block）。此外，一个分组的比特数就称为分组长度（blocklength）。</p>
<p>例如，<strong>DES和三重DES的分组长度都是64比特</strong>。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。</p>
<p><strong>AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。</strong></p>
</blockquote>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><blockquote>
<p><strong>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）</strong>。</p>
</blockquote>
<blockquote>
<p>模式有很多种类，分组密码的主要模式有以下5种：</p>
<ul>
<li><strong>ECB模式</strong>：Electronic Code Book mode（电子密码本模式）</li>
<li><strong>CBC模式</strong>：Cipher Block Chaining mode（密码分组链接模式）</li>
<li><strong>CFB模式</strong>：Cipher FeedBack mode（密文反馈模式）</li>
<li><strong>OFB模式</strong>：Output FeedBack mode（输出反馈模式）</li>
<li><strong>CTR模式</strong>：CounTeR mode（计数器模式）</li>
</ul>
</blockquote>
<h3 id="明文分组和密文分组"><a href="#明文分组和密文分组" class="headerlink" title="明文分组和密文分组"></a>明文分组和密文分组</h3><blockquote>
<p>**明文分组: **是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p>**密文分组: **是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105748588.png" alt="image-20210817105748588" style="zoom:67%;">

<h2 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h2><p>ECB(Electronic Code Book, 电子密码本)模式是最简单的加密模式，<font color="red">明文消息被分成固定大小的块（分组），并且每个块被单独加密。</font>  每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<font color="red">安全性比较差。  适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</font></p>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105913728.png" alt="image-20210817105913728 " style="zoom:67%;">

<blockquote>
<p>使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组–&gt;密文分组”的对应表，因此ECB模式也称为电子密码本模式<strong>当最后一个明文分组的内容小于分组长度时，需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度</strong>。</p>
<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>
</blockquote>
<h2 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><blockquote>
<p>异或操作： </p>
<p>1$\bigoplus$0=1  </p>
<p>0$\bigoplus$1=1</p>
<p>1$\bigoplus$1=0 </p>
<p>0$\bigoplus$0=0</p>
</blockquote>
<center><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110350744.png" alt="image-20210817110350744" style="zoom:80%;"><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110416665.png" alt="image-20210817110416665" style="zoom:80%;"></center>

<blockquote>
<p>可能大家已经发现了，上面的计算和加密、解密的步骤非常相似。</p>
<ul>
<li><p>将明文A用密钥B进行加密，得到密文A⊕B</p>
</li>
<li><p>将密文A⊕B用密钥B进行解密，得到明文A</p>
</li>
</ul>
<p>实际上，只要选择一个合适的B，仅仅使用XOR就可以实现一个高强度的密码。</p>
<p>对同一个比特序列进行两次XOR之后就会回到最初的状态。</p>
</blockquote>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><blockquote>
<p>CBC(Cipher Block Chaining, 密码块链)<font color="red">模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密</font>。  这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，<font color="red">第一个数据块进行加密之前需要用初始化向量IV进行异或操作</font>。  <font color="red">CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。</font></p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110639241.png" alt="image-20210817110639241" style="zoom:67%;">

<blockquote>
<p> 如果将一个分组的加密过程分离出来，我们就可以很容易地比较出ECB模式和CBC模式的区别 。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110715286.png" alt="image-20210817110715286" style="zoom:50%;">

<h3 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><strong>当加密第一个明文分组时，由于不存在“前一个密文分组”，因此<font color="red">需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组</font>“，这个比特序列称为初始化向量（initialization vector）</strong> 通常缩写为 IV </p>
</blockquote>
<h2 id="CFB-模式"><a href="#CFB-模式" class="headerlink" title="CFB 模式"></a>CFB 模式</h2><blockquote>
<p>CFB模式的全称是Cipher FeedBack模式（密文反馈模式）。在CFB模式中，<font color="red">前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</font>。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111048158.png" alt="image-20210817111048158" style="zoom:67%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111109864.png" alt="image-20210817111109864" style="zoom:67%;">

<blockquote>
<p>在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。</p>
<p>从上图可以看出，明文分组和密文分组之间并没有经过”加密”这一步骤。在CFB模式中，明文分和密文分组之间只有一个XOR。</p>
<p>我们将CBC模式与CFB模式对比一下，就可以看出其中的差异了（如下图）。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB模式中，明文分组和密文分组之间则只有XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111235512.png" alt="image-20210817111235512" style="zoom:50%;">

<h3 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><font color="red">在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替</font>，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。</p>
</blockquote>
<h3 id="CFB模式与流密码"><a href="#CFB模式与流密码" class="headerlink" title="CFB模式与流密码"></a>CFB模式与流密码</h3><blockquote>
<p>CFB模式是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”的。</p>
<p>在CFB模式中，密码算法的输出相当于一个随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此CFB模式不可能具各理论上不可破译的性质。</p>
<p><font color="red">CFB模式中由加密算法所生成的比特序列称为密钥流（key stream）</font>。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的“种子“。</p>
<p>在CFB模式中，<font color="red">明文数据可以被逐比特加密</font>，因此我们<font color="red">可以将CFB模式看做是一种使用分组密码来实现流密码的方式</font>。</p>
</blockquote>
<h2 id="OFB-模式"><a href="#OFB-模式" class="headerlink" title="OFB 模式"></a>OFB 模式</h2><blockquote>
<p>OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将 “明文分组” 和 “密码算法的输出” 进行XOR来产生 “密文分组” 的，在这一点上OFB模式和CFB模式非常相似。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111629522.png" alt="image-20210817111629522" style="zoom:67%;">

<h3 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p>和CBC模式、CFB模式一样，OFB模式中也需要使用初始化向量（IV）。</p>
</blockquote>
<h3 id="CFB模式和OFB模式对比"><a href="#CFB模式和OFB模式对比" class="headerlink" title="CFB模式和OFB模式对比"></a>CFB模式和OFB模式对比</h3><blockquote>
<p>OFB模式和CFB模式的区别仅仅在于密码算法的输入。</p>
<p>CFB式中，密码算法的输人是前一个密文分组，也就是将密文分组反馈到密算法中，因此就有了“密文反馈模式”这个名字。</p>
<p>相对地，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈给密码算法，因此就有了“输出反馈模式”这个名字。</p>
<p>如果将一个分组抽出来对CFB模式和OFB模式进行一个对比．就可以很容易看出它们之间的差异（下图）。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112004499.png" alt="image-20210817112004499" style="zoom:67%;">

<blockquote>
<p>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。</p>
<p>相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了。只要将明文与密钥流进行XOR就可以了。和AES等密码算法相比，XOR运算的速度是非常快的。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p>
</blockquote>
<h2 id="CTR-模式"><a href="#CTR-模式" class="headerlink" title="CTR 模式"></a>CTR 模式</h2><blockquote>
<p>CTR模式的全称是CounTeR模式（计数器模式）。<font color="red">CTR摸式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码</font>（下图）。</p>
<p>CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112246534.png" alt="image-20210817112246534" style="zoom:50%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112306254.png" alt="image-20210817112306254" style="zoom:50%;">

<h3 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h3><blockquote>
<p>每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是像下面这样的形式。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112459058.png" alt="image-20210817112459058" style="zoom:80%;">

<blockquote>
<p>其中前8个字节为nonce（随机数），这个值在每次加密时必须都是不同的，后8个字节为分组序号，这个部分是会逐次累加的。在加密的过程中，计数器的值会产生如下变化：</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112557257.png" alt="image-20210817112557257" style="zoom:80%;">

<blockquote>
<p>按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p>
</blockquote>
<h3 id="OFB模式与CTR模式对比"><a href="#OFB模式与CTR模式对比" class="headerlink" title="OFB模式与CTR模式对比"></a>OFB模式与CTR模式对比</h3><blockquote>
<p>CTR模式和OFB模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么OFB模式和CTR模式之间的差异还是很容易理解的（下图）。OFB模式是将加密的输出反愦到输入，而CTR模式则是将计数器的值用作输入。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112653539.png" alt="image-20210817112653539" style="zoom:67%;">

<h3 id="CTR模式的特点"><a href="#CTR模式的特点" class="headerlink" title="CTR模式的特点"></a>CTR模式的特点</h3><blockquote>
<p>CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。</p>
<p>此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。</p>
<p>能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112810129.png" alt="image-20210817112810129 " style="zoom:80%;">

<ol>
<li><p>ECB - Electronic Code Book, 电子密码本模式</p>
<ul>
<li>特点: 简单, 效率高, 密文有规律, 容易被破解</li>
<li>最后一个明文分组必须要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>不需要初始化向量</li>
</ul>
</li>
<li><p>CBC - Cipher Block Chaining, 密码块链模式</p>
<ul>
<li>特点: 密文没有规律, 经常使用的加密方式</li>
<li>最后一个明文分组需要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
</ul>
</li>
<li><p>CFB - Cipher FeedBack, 密文反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>OFB - Output-Feedback, 输出反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>CTR - CounTeR, 计数器模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>不需要初始化向量<ul>
<li>go接口中的iv可以理解为随机数种子, iv的长度 == 明文分组的长度</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现对称算法</title>
    <url>/2021/08/17/Go%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Go中对DES的操作"><a href="#Go中对DES的操作" class="headerlink" title="Go中对DES的操作"></a>Go中对DES的操作</h2><p>最后一个分组添加填充数据和移除添加数据代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充函数，如果最后一个分组字节数不够, 填充</span></span><br><span class="line"><span class="comment">// 使用pks5的方式填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算最后一个分组缺多少个字节</span></span><br><span class="line">	padding := blockSize - (<span class="built_in">len</span>(ciphertext)%blockSize)</span><br><span class="line">	<span class="comment">// 2. 创建一个大小为padding的切片, 每个字节的值为padding</span></span><br><span class="line">	padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="comment">// 3. 将padText添加到原始数据的后边, 将最后一个分组缺少的字节数补齐</span></span><br><span class="line">	newText := <span class="built_in">append</span>(ciphertext, padText...)</span><br><span class="line">	<span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除pks5填充的尾部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的总长度</span></span><br><span class="line">	length := <span class="built_in">len</span>(origData)</span><br><span class="line">	<span class="comment">// 2. 根据填充的字节值得到填充的次数</span></span><br><span class="line">	number := <span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 3. 将尾部填充的number个字节去掉</span></span><br><span class="line">	<span class="keyword">return</span> origData[:(length-number)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加解密实现思路"><a href="#加解密实现思路" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit, 即 64/8 = 8字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><p>解密：</p>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="加解密的代码实现"><a href="#加解密的代码实现" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>在Go中使用DES需要导入的包:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/des&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要加密的明文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 对最后一个明文分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 4. 创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</span></span><br><span class="line">	<span class="comment">//    参数iv的长度, 必须等于b的块尺寸</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blackMode := cipher.NewCBCEncrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 5. 加密连续的数据块</span></span><br><span class="line">	dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	blackMode.CryptBlocks(dst, src)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;加密之后的数据: &quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 将加密数据返回</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要解密的密文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 和加密秘钥相同, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 4. 解密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(src, dst)</span><br><span class="line">	<span class="comment">// 5. 去掉最后一组填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 返回结果</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DESText</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加密</span></span><br><span class="line">	key := []<span class="keyword">byte</span>(<span class="string">&quot;11111111&quot;</span>)</span><br><span class="line">	result := DesEncrypt_CBC([]<span class="keyword">byte</span>(<span class="string">&quot;床前明月光, 疑是地上霜. 举头望明月, 低头思故乡.&quot;</span>), key)</span><br><span class="line">	fmt.Println(base64.StdEncoding.EncodeToString(result))</span><br><span class="line">	<span class="comment">// 解密</span></span><br><span class="line">	result = DesDecrypt_CBC(result, key)</span><br><span class="line">	fmt.Println(<span class="string">&quot;解密之后的数据: &quot;</span>, <span class="keyword">string</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用DES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: des对称加密使用的密码, 密码长度为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>自定义函数介绍</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">对称加密加密需要对数据进行分组, 保证每个分组的数据长度相等, 如果最后一个分组长度不够, 需要进行填充</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数 ciphertext: 需要加密的原始数据</span><br><span class="line">    - 参数 blockSize: 每个分组的长度, 跟使用的加密算法有关系</span><br><span class="line">		* des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* <span class="number">3</span>des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* aes： <span class="number">128</span>bit， <span class="number">16</span><span class="keyword">byte</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对3DES的操作"><a href="#Go中对3DES的操作" class="headerlink" title="Go中对3DES的操作"></a>Go中对3DES的操作</h2><h3 id="加解密实现思路-1"><a href="#加解密实现思路-1" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><p><strong>加密 - CBC分组模式</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit*3=192bit, 即 192/8 = 24字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>3DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<p><strong>解密</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-1"><a href="#加解密的代码实现-1" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>3DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3DES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用3DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 对最后一组明文进行填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式, 底层使用3DES加密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 4. 加密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3DES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建3DES算法的Block接口对象</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建密码分组为链接模式, 底层使用3DES解密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li> 生成一个底层使用3DES加/解密的Block接口对象</li>
</ol>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTripleDESCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: <span class="number">3</span>des对称加密使用的密码, 密码长度为(<span class="number">64</span>*<span class="number">3</span>)bit, 即(<span class="number">8</span>*<span class="number">3</span>)<span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对AES的使用"><a href="#Go中对AES的使用" class="headerlink" title="Go中对AES的使用"></a>Go中对AES的使用</h2><h3 id="加解密实现思路-2"><a href="#加解密实现思路-2" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为128bit, 即 128/8 = 16字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>AES是以128比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够128bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用AES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><strong>解密</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用AES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-2"><a href="#加解密的代码实现-2" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>AES加密代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES加密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 最后一个分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个分组为链接模式, 底层使用AES加密的块模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 4. 加密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AES解密:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES解密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建分组为链接模式, 底层使用AES的解密模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的字</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用AES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: aes对称加密使用的密码, 密码长度为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用AES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用aes.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<h2 id="应选择哪种对称加密"><a href="#应选择哪种对称加密" class="headerlink" title="应选择哪种对称加密"></a>应选择哪种对称加密</h2><blockquote>
<p>前面我们介绍了DES、三重DES和AES等对称密码，那么我们到底应该使用哪一种对称密码算法呢？</p>
<ol>
<li><strong>今后最好不要将DES用于新的用途，因为随着计算机技术的进步，现在用暴力破解法已经能够在现实的时间内完成对DES的破译。但是，在某些情况下也需要保持与旧版本软件的兼容性。</strong></li>
<li><strong>出于兼容性的因素三重DES在今后还会使用一段时间，但会逐渐被AES所取代。</strong></li>
<li><strong>今后大家应该使用的算法是AES（Rijndael），因为它安全、快速，而且能够在各种平台上工作。此外，由于全世界的密码学家都在对AES进行不断的验证，因此即便万一发现它有什么缺陷，也会立刻告知全世界并修复这些缺陷。</strong></li>
</ol>
<p>一般来说，我们不应该使用任何自制的密码算法，而是应该使用AES。因为AES在其选定过程中，经过了全世界密码学家所进行的高品质的验证工作，而对于自制的密码算法则很难进行这样的验证。 </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
