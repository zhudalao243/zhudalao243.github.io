<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang中的GC垃圾回收机制</title>
    <url>/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Golang中的GC垃圾回收机制"><a href="#Golang中的GC垃圾回收机制" class="headerlink" title="Golang中的GC垃圾回收机制"></a>Golang中的GC垃圾回收机制</h1><h2 id="Go-1-3-标记清除-mark-and-sweep"><a href="#Go-1-3-标记清除-mark-and-sweep" class="headerlink" title="Go 1.3 标记清除(mark and sweep)"></a>Go 1.3 标记清除(mark and sweep)</h2><blockquote>
<p>流程：</p>
<ol>
<li>暂停程序业务逻辑, 找出不不可达的对象，和可达对象。</li>
<li>开始标记，程序找出它所有可达的对象，并做上标记。</li>
<li>标记完了了之后，然后开始清除未标记的对象.</li>
<li>停⽌止暂停，让程序继续跑。然后循环重复这个过程，直到process程序⽣生命周期结束。</li>
</ol>
<p>缺点：</p>
<ol>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。将第四步和第三步换位置， 缩短STW的范围</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产⽣生heap碎⽚。</li>
</ol>
</blockquote>
<h2 id="Go-1-5-三色标记法"><a href="#Go-1-5-三色标记法" class="headerlink" title="Go 1.5 三色标记法"></a>Go 1.5 三色标记法</h2><p>流程：</p>
<ol>
<li>只要是新创建的对象,默认的颜⾊色都是标记为“⽩白⾊色”.</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202056508.png" alt="image-20210815202056508" style="zoom:40%;">

<ol start="2">
<li><p>每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202153446.png" alt="image-20210815202153446" style="zoom:40%;"></li>
<li><p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202305099.png" alt="image-20210815202305099" style="zoom:40%;">

<ol start="4">
<li><p>重复第三步, 直到灰⾊色中⽆无任何对象.</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202348203.png" alt="image-20210815202348203" style="zoom:30%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202439107.png" alt="image-20210815202439107" style="zoom:30%;"></center></li>
<li><p>回收所有的白色标记表的对象. 也就是回收垃圾.</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202557320.png" alt="image-20210815202557320" style="zoom:40%;">

<h2 id="如果三色标记法不被STW保护"><a href="#如果三色标记法不被STW保护" class="headerlink" title="如果三色标记法不被STW保护"></a>如果三色标记法不被STW保护</h2><p><em>条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下).</em></p>
<p><em>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</em></p>
<p><em>两个条件同时满足，那么就会出现对象丢失的现象</em></p>
<p>样例：</p>
<p>如果不开启STW：</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203317889.png" alt="image-20210815203317889" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203356122.png" alt="image-20210815203356122" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203423861.png" alt="image-20210815203423861" style="zoom:25%;"></center>



<h2 id="强弱三色不变式"><a href="#强弱三色不变式" class="headerlink" title="强弱三色不变式"></a>强弱三色不变式</h2><h3 id="强三色不不变式"><a href="#强三色不不变式" class="headerlink" title="强三色不不变式"></a>强三色不不变式</h3><p>破坏条件1</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213638805.png" alt="image-20210815213638805" style="zoom:33%;">

<h3 id="弱三色不不变式"><a href="#弱三色不不变式" class="headerlink" title="弱三色不不变式"></a>弱三色不不变式</h3><p>破坏条件2</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213703432.png" alt="image-20210815213703432" style="zoom:40%;">

<p>如果三色标记满足强弱不变式之一，即可保证不丢失对象.</p>
<h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>屏障？程序运行过程中额外添加的判断机制。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213927896.png" alt="image-20210815213927896" style="zoom:50%;">

<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>插入屏障： 对象被引用时，触发的机制。</p>
<p>具体操作： 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p>满足: 强三色不不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	标记灰⾊色(新下游对象ptr)</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, nil)  //A对象，删除B对象的引⽤。 B被A删除，被标记为灰(如果B之前为⽩)</span><br><span class="line">A.添加下游对象(B, C) //A对象，更更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩)</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214828157.png" alt="image-20210815214828157" style="zoom:50%;">

<p>插入写屏障只在堆上触发，在栈上不触发。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214950520.png" alt="image-20210815214950520" style="zoom:26%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215043176.png" alt="image-20210815215043176" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215126841.png" alt="image-20210815215126841" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215308921.png" alt="image-20210815215308921" style="zoom:33%;">

<p>由于栈上不触发插入写屏障，所以在准备回收白色前，需要加STW暂停保护重新扫描一遍栈空间。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215334937.png" alt="image-20210815215334937" style="zoom:33%;">

<p>不足：结束时需要STW来重新扫描栈，⼤大约需要10~100ms</p>
<h3 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h3><p>删除屏障：对象被删除时 触发的机制。</p>
<p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	<span class="keyword">if</span> (当前下游对象slot是灰⾊色 || 当前下游对象slot是⽩白⾊色) &#123;</span><br><span class="line">		标记灰⾊色(当前下游对象slot) //slot为被删除对象， 标记为灰⾊色</span><br><span class="line">	&#125;</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<p>​    A.添加下游对象(B, nil) //A对象，删除B对象的引用。 B被A删除，被标记为灰(如果B之前为白)<br>​    A.添加下游对象(B, C) //A对象，更换下游B变成C。 B被A删除，被标记为灰(如果B之前为白)</p>
<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220252392.png" alt="image-20210815220252392" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220332343.png" alt="image-20210815220332343" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220413361.png" alt="image-20210815220413361" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220435567.png" alt="image-20210815220435567" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220500445.png" alt="image-20210815220500445" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220533566.png" alt="image-20210815220533566" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220552303.png" alt="image-20210815220552303" style="zoom:40%;">

<p>不足： 回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理理掉。</p>
<h2 id="Go-1-8-混合写屏障机制"><a href="#Go-1-8-混合写屏障机制" class="headerlink" title="Go 1.8 混合写屏障机制"></a>Go 1.8 混合写屏障机制</h2><blockquote>
<p>具体操作:</p>
<ol>
<li>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ol>
<p>满足: 变形的弱三色不变式. (结合了插入、删除写屏障两者的优点)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">    //1</span><br><span class="line">    标记灰⾊色(当前下游对象slot) //只要当前下游对象被移⾛走，就标记灰⾊色</span><br><span class="line">    //2</span><br><span class="line">    标记灰⾊色(新下游对象ptr)</span><br><span class="line">    //3</span><br><span class="line">    当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221417608.png" alt="image-20210815221417608" style="zoom:25%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221437818.png" alt="image-20210815221437818" style="zoom:50%;">

<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>对象被一个堆对象删除引用，成为栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪码</span><br><span class="line">//前提：堆对象4-&gt;对象7 = 对象7； //对象7 被 对象4引⽤用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7； //将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222017066.png" alt="image-20210815222017066" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222032431.png" alt="image-20210815222032431" style="zoom:33%;">

<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>对象被一个栈对象删除引用，成为另一个栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象9-&gt;对象3 = 对象3； //将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 = null； //对象2 删除引⽤用 对象3</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222315895-1629105238588.png" alt="image-20210815222315895" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222346906-1629105238588.png" alt="image-20210815222346906" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222407645-1629105238589.png" alt="image-20210815222407645" style="zoom:50%;">

<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>对象被一个堆对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7； //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222602561-1629105297759.png" alt="image-20210815222602561" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222619017-1629105297759.png" alt="image-20210815222619017" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222633300-1629105297758.png" alt="image-20210815222633300" style="zoom:50%;">

<h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>对象从一个栈对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈对象1-&gt;对象2 = null； //对象1 删除引⽤用 对象2</span><br><span class="line">堆对象4-&gt;对象7 = null; //对象4 删除引⽤用 对象7</span><br><span class="line">堆对象4-&gt;对象2 = 栈对象2； //对象4 添加 下游 栈对象2</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222835930.png" alt="image-20210815222835930" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222852740.png" alt="image-20210815222852740" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222910678.png" alt="image-20210815222910678" style="zoom:50%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go V1.3 普通的标记清除法， 整体过程需要STW，效率极低</p>
<p>Go V1.5 三⾊色标记法， 堆空间启动写屏障，栈空间不启动， 全部扫描之后，需要重新扫描⼀一次栈(需要STW)， 效率普通</p>
<p>Go V1.8 三⾊色标记法，混合写屏障机制， 栈空间不不启动，堆空间启动， 整体过程⼏几乎不不需要STW， 效率较高</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>01周易基础及其应用</title>
    <url>/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/</url>
    <content><![CDATA[<h1 id="周易基础及应用"><a href="#周易基础及应用" class="headerlink" title="周易基础及应用"></a>周易基础及应用</h1><p>千古奇书《周易》</p>
<p>人更三圣：伏羲    周文王    孔夫子</p>
<p>事历三古：远古    中古         近古</p>
<p>《易经》它是以八卦为核心，以卦的形式来说明问题，以阴爻和阳爻来说明问题，以阴爻和阳爻的相互配合，以文字系统与符号系统相结合说明万事万物的根本规律。</p>
<p>《易经》为群经之首。</p>
<p>系词： <strong>夫《易》何为者也，开物成务斯如此也。</strong>  开物成务：开物是认识事物的本质，成务是怎么去解决这个问题。</p>
<p><strong>不善易者，不得为将相。</strong>   </p>
<p><strong>不知易不足以言大医。   ————孙思邈</strong></p>
<p>易道广大，无所不包。</p>
<p>《易》与天地准，故能弥纶天地之道。</p>
<p>百姓日用而不知。</p>
<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815150334560.png" alt="image-20210815150334560" style="zoom:33%;">

<h2 id="阴阳学说"><a href="#阴阳学说" class="headerlink" title="阴阳学说"></a>阴阳学说</h2><p>易以道阴阳。 ——庄子</p>
<p>天地间无往而非阴阳，一动一静一语一默，皆是阴阳之理。 ———朱熹</p>
<p>阳：天    上    昼    男    君    贵    福 ….</p>
<p>阴：地    下    夜    女    臣    贱    祸 ….</p>
<p><strong>一阴一阳之谓道。</strong></p>
<p>主要内容：</p>
<ul>
<li>阴阳对立</li>
<li>阴阳依存（互根）。有无相生，难易相成，长短相盈，高低相形，音声相合，前后相随，恒也。</li>
<li>阴阳消长。阴阳动态变化，动态平衡。阴盛则阳病，阳盛则阴病。</li>
<li>阴阳转换。消长属于量变，转化属于质变。</li>
</ul>
<p>中国哲学三大问题：天人、群己、身心</p>
<p>重视对立，追求平衡。</p>
<h2 id="五行学说"><a href="#五行学说" class="headerlink" title="五行学说"></a>五行学说</h2><p>世界上的万事万物的运动和发生发展都是”金木水火土“这五种状态，相互作用、相互运动的结果。  ——&gt;系统观</p>
<h3 id="五行特点"><a href="#五行特点" class="headerlink" title="五行特点"></a>五行特点</h3><blockquote>
<p>五行顺序              特性        方位    五德            季节</p>
<p>一曰水    润下    润下寒冷    北方    智               冬季</p>
<p>二曰火    炎上    炎热向上    南方    礼               夏季</p>
<p>三曰木    曲直    生发条达    东方    仁               春季</p>
<p>四曰金    从草    清凉萧杀    西方    义                秋季</p>
<p>五曰土    稼穑    长养化育    中央    信      农历（三、六、九、十二月）</p>
</blockquote>
<h3 id="五行生克"><a href="#五行生克" class="headerlink" title="五行生克"></a>五行生克</h3><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815160518695.png" alt="image-20210815160518695" style="zoom:33%;">

<h3 id="五行的旺、相、休、囚、死"><a href="#五行的旺、相、休、囚、死" class="headerlink" title="五行的旺、相、休、囚、死"></a>五行的旺、相、休、囚、死</h3><p>生克制化之理</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">旺</th>
<th align="center">相</th>
<th align="center">死</th>
<th align="center">囚</th>
<th align="center">休</th>
</tr>
</thead>
<tbody><tr>
<td align="center">春</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
</tr>
<tr>
<td align="center">夏</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
</tr>
<tr>
<td align="center">秋</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
</tr>
<tr>
<td align="center">冬</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
</tr>
<tr>
<td align="center">四季</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
</tr>
</tbody></table>
<h2 id="天干地支"><a href="#天干地支" class="headerlink" title="天干地支"></a>天干地支</h2><h3 id="十天干"><a href="#十天干" class="headerlink" title="十天干"></a>十天干</h3><blockquote>
<p>甲        乙        丙        丁        戊        己        庚        辛        壬        癸</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">甲乙同属木</td>
<td>东方</td>
<td>甲阳木</td>
<td>乙阴木</td>
</tr>
<tr>
<td align="center">丙丁同属火</td>
<td>南方</td>
<td>丙阳火</td>
<td>丁阴火</td>
</tr>
<tr>
<td align="center">戊己同属土</td>
<td>中央</td>
<td>戊阳土</td>
<td>己阴土</td>
</tr>
<tr>
<td align="center">庚辛同属金</td>
<td>西方</td>
<td>庚阳金</td>
<td>辛阴金</td>
</tr>
<tr>
<td align="center">壬癸同属水</td>
<td>北方</td>
<td>壬阳水</td>
<td>癸阴水</td>
</tr>
</tbody></table>
<h4 id="天干相和"><a href="#天干相和" class="headerlink" title="天干相和"></a>天干相和</h4><blockquote>
<p>甲己合土</p>
<p>乙庚合金</p>
<p>丙辛合水</p>
<p>丁壬合木</p>
<p>戊癸合火</p>
</blockquote>
<h4 id="十天干的相生相克"><a href="#十天干的相生相克" class="headerlink" title="十天干的相生相克"></a>十天干的相生相克</h4><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165629369.png" alt="image-20210815160518695">

<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165743365.png" alt="image-20210815160518695">



]]></content>
      <categories>
        <category>哲学</category>
        <category>周易基础及其应用</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密</title>
    <url>/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>常用的两种加密方式 </p>
<p>对称加密</p>
<ul>
<li>秘钥: 加密解密使用的是同一个秘钥, 秘钥有一个</li>
<li>特点<ul>
<li>双方向保证机密性</li>
<li>加密效率高, 适合加密大数据, 大文件</li>
<li>加密强度不高, 相对于非对称加密</li>
</ul>
</li>
</ul>
<p>非对称加密</p>
<ul>
<li>秘钥: 加密解密使用的不同的秘钥, 秘钥有两个, 需要使用秘钥生成算法, 得到密钥对<ul>
<li>公钥 - 可以公开的秘钥<ul>
<li>公钥加密数据, 解密需要使用私钥</li>
</ul>
</li>
<li>私钥 - 需要妥善保管的秘钥, 知道的人越少越好<ul>
<li>私钥加密, 公钥解密</li>
</ul>
</li>
</ul>
</li>
<li>特点:<ul>
<li>数据的机密性只能单方向保证</li>
<li>加密效率低, 适合加密少量数据</li>
<li>加密强度高, 相对于对称加密</li>
</ul>
</li>
</ul>
</li>
<li><p>密码信息安全常识 </p>
<ul>
<li><p>不要使用保密的密码算法（普通公司和个人）</p>
</li>
<li><p>使用低强度的密码比不进行任何加密更危险</p>
</li>
<li><p>任何密码总有一天都会被破解</p>
</li>
<li><p>密码只是信息安全的一部分                </p>
</li>
</ul>
</li>
<li><p>密码信息威胁 </p>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816230646529.png" alt="image-20210816230646529" style="zoom:70%;"></li>
</ol>
<h2 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h2><blockquote>
<p>“对称加密: 也称为对称密码, 是指在加密和解码时使用同一秘钥的加密方式”</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231137633.png" alt="image-20210816231137633" style="zoom:50%;">

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote>
<p>现代的密码都是建立在计算机的基础之上的，这是因为现代的密码所处理的数据量非常大，而且密码算法也非常复杂，不借助计算机的力量就无法完成加密和解密的操作。</p>
<p>计算机的操作对象并不是文字，而是由0和1排列而成的<strong>比特序列</strong>。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>
<p>将现实世界中的东西映射为比特序列的操作称为<strong>编码（encoding）</strong>。例如midnight（深夜）这个词，我们可以对其中的每个字母逐一进行编码，这种编码规则叫作<strong>ASCII</strong>。</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231349119.png" alt="image-20210816231349119" style="zoom:67%;">

<blockquote>
<p>注意这里的m –&gt; 01101101这一转换并不是加密而是编码。尽管在人类看来0和1的序列跟密码没什么两样，但计算机却可以“看懂”这些比特序列，并很快地反应出其所对应的字符 <strong>midnight</strong></p>
</blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>DES是一种将64比特的明文加密成64比特的密文的对称密码算法，==它的密钥长度是56比特==。尽管<font color="red">从规格上来说，DES的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上其密钥长度是56比特</font>。</p>
<p><font color="red">DES是以64比特的明文（比特序列）为一个单位来进行加密的</font>，<strong>这个64比特的单位称为分组</strong>。一般来说，以分组为单位进行处理的密码算法称为<strong>分组密码（blockcipher）</strong>，DES就是分组密码的一种。</p>
<p>DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。</p>
<p>大B -&gt; bit</p>
<p>小b -&gt; byte</p>
<p>秘钥长度(56bit + 8bit)/8 = 8byte   12345678</p>
</blockquote>
<h4 id="DES的加密与解密-图例"><a href="#DES的加密与解密-图例" class="headerlink" title="DES的加密与解密 - 图例"></a>DES的加密与解密 - 图例</h4><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231818006.png" alt="image-20210816231818006" style="zoom:80%;">

<h4 id="DES小结"><a href="#DES小结" class="headerlink" title="DES小结"></a>DES小结</h4><ul>
<li>现在使用DES方式加密，数据还安全吗？<ul>
<li>不安全, 已经被破解了  </li>
</ul>
</li>
<li>是不是分组密码？<ul>
<li>是, 先对数据进行分组, 然后在加密或解密</li>
</ul>
</li>
<li>DES的分组长度?<ul>
<li>8byte == 64bit</li>
</ul>
</li>
<li>DES的秘钥长度?<ul>
<li>56bit秘钥长度+8bit错误检测标志位 = 64bit == 8byte</li>
</ul>
</li>
</ul>
<h3 id="3DES-–-Triple-DES"><a href="#3DES-–-Triple-DES" class="headerlink" title="3DES  –   Triple-DES"></a>3DES  –   Triple-DES</h3><blockquote>
<p>现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码，三重DES就是出于这个目的被开发出来的。</p>
<p><strong>三重DES（triple-DES）是为了增加DES的强度，==将DES重复3次所得到的一种密码算法==，通常缩写为3DES</strong>。</p>
</blockquote>
<h4 id="加密和解密-1"><a href="#加密和解密-1" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>三重DES的加解密机制如图所示：</p>
<p>加-&gt;解-&gt;加 -&gt; 目的是为了兼容des</p>
<p>3des秘钥长度24字节 = 1234567a 1234567b 1234567a</p>
</blockquote>
<center><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102851239.png" alt="image-20210817102851239" style="zoom:50%;">!<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102916694.png" alt="image-20210817102916694 " style="zoom:50%;"></center>

<blockquote>
<p>明文经过三次DES处理才能变成最后的密文，由于<strong>DES密钥的长度实质上是56比特</strong>，因此<font color="red">三重DES的密钥长度就是56×3=168比特, 加上用于错误检测的标志位8x3, 共192bit</font>。</p>
<p>从上图我们可以发现，三重DES并不是进行三次DES加密（加密–&gt;加密–&gt;加密），而是<font color="red"><strong>加密–&gt;解密–&gt;加密</strong></font>的过程。在加密算法中加人解密操作让人感觉很不可思议，实际上这个方法是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES。</p>
<p><font color="red">当三重DES中所有的密钥都相同时，三重DES也就等同于普通的DES了</font>。这是因为在前两步加密–&gt;解密之后，得到的就是最初的明文。因此，以前用DES加密的密文，就可以通过这种方式用三重DES来进行解密。也就是说，三重DES对DES具备向下兼容性。</p>
<p>如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个DES密钥），这种三重DES就称为DES-EDE2。EDE表示的是加密（Encryption) –&gt;解密（Decryption)–&gt;加密（Encryption）这个流程。</p>
<p>密钥1、密钥2、密钥3全部使用不同的比特序列的三重DES称为DES-EDE3。</p>
<p>尽管三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题。</p>
</blockquote>
<h4 id="3DES小结"><a href="#3DES小结" class="headerlink" title="3DES小结"></a>3DES小结</h4><ul>
<li>3DES安全吗?<ul>
<li>安全, 但是效率低</li>
</ul>
</li>
<li>算法描述?<ul>
<li>进行了3次des加密</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>3DES分组长度?<ul>
<li>8字节</li>
</ul>
</li>
<li>3DES秘钥长度?<ul>
<li>24字节, 在算法内部会被平均分成3份</li>
</ul>
</li>
<li>3DES加密过程?<ul>
<li>秘钥1 -&gt; 加密, 秘钥2 -&gt; 解密, 秘钥3 -&gt; 加密</li>
</ul>
</li>
<li>3DES解密过程?<ul>
<li>秘钥1 -&gt; 解密, 秘钥2 -&gt; 加密, 秘钥3 -&gt; 解密</li>
</ul>
</li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><blockquote>
<p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码算法。全世界的企业和密码学家提交了多个对称密码算法作为AES的候选，最终在2000年从这些候选算法中选出了一种名为==<strong>Rijndael</strong>==的对称密码算法，并将其确定为了AES。</p>
</blockquote>
<blockquote>
<p>**==Rijndael的分组长度为128比特==**，密钥长度可以以32比特为单位在128比特到256比特的范围内进行选择（不过==<strong>在AES的规格中，密钥长度只有128、192和256比特三种</strong>==）。</p>
<p>128bit = 16字节</p>
<p>192bit = 24字节</p>
<p>256bit = 32字节</p>
<p>在go提供的接口中秘钥长度只能是16字节</p>
</blockquote>
<h4 id="AES小结"><a href="#AES小结" class="headerlink" title="AES小结"></a>AES小结</h4><ul>
<li>AES安全吗?<ul>
<li>安全, 效率高, 推荐使用的</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>AES分组长度?<ul>
<li>128bit = 16字节</li>
</ul>
</li>
<li>AES秘钥长度?<ul>
<li>128bit = 16字节</li>
<li>192bit = 24字节</li>
<li>256bit = 32字节</li>
<li>go中的秘钥长度只能是16字节</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码的模式</title>
    <url>/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;分组密码的模式 -- 分组密码是如何迭代的&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DES和AES都属于分组密码，只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。</p>
<p>分组密码有很多种模式，如果模式的选择不恰当，就无法保证机密性。例如，如果使用ECB模式，明文中的一些规律就可以通过密文被识别出来。</p>
<p>分组密码的主要模式（ECB、CBC、CFB、OFB、CTR）</p>
</blockquote>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><blockquote>
<p><strong>分组密码（blockcipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的一块”就称为分组（block）。此外，一个分组的比特数就称为分组长度（blocklength）。</p>
<p>例如，<strong>DES和三重DES的分组长度都是64比特</strong>。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。</p>
<p><strong>AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。</strong></p>
</blockquote>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><blockquote>
<p><strong>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）</strong>。</p>
</blockquote>
<blockquote>
<p>模式有很多种类，分组密码的主要模式有以下5种：</p>
<ul>
<li><strong>ECB模式</strong>：Electronic Code Book mode（电子密码本模式）</li>
<li><strong>CBC模式</strong>：Cipher Block Chaining mode（密码分组链接模式）</li>
<li><strong>CFB模式</strong>：Cipher FeedBack mode（密文反馈模式）</li>
<li><strong>OFB模式</strong>：Output FeedBack mode（输出反馈模式）</li>
<li><strong>CTR模式</strong>：CounTeR mode（计数器模式）</li>
</ul>
</blockquote>
<h3 id="明文分组和密文分组"><a href="#明文分组和密文分组" class="headerlink" title="明文分组和密文分组"></a>明文分组和密文分组</h3><blockquote>
<p>**明文分组: **是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p>**密文分组: **是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105748588.png" alt="image-20210817105748588" style="zoom:67%;">

<h2 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h2><p>ECB(Electronic Code Book, 电子密码本)模式是最简单的加密模式，<font color="red">明文消息被分成固定大小的块（分组），并且每个块被单独加密。</font>  每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<font color="red">安全性比较差。  适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</font></p>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105913728.png" alt="image-20210817105913728 " style="zoom:67%;">

<blockquote>
<p>使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组–&gt;密文分组”的对应表，因此ECB模式也称为电子密码本模式<strong>当最后一个明文分组的内容小于分组长度时，需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度</strong>。</p>
<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>
</blockquote>
<h2 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><blockquote>
<p>异或操作： </p>
<p>1$\bigoplus$0=1  </p>
<p>0$\bigoplus$1=1</p>
<p>1$\bigoplus$1=0 </p>
<p>0$\bigoplus$0=0</p>
</blockquote>
<center><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110350744.png" alt="image-20210817110350744" style="zoom:80%;"><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110416665.png" alt="image-20210817110416665" style="zoom:80%;"></center>

<blockquote>
<p>可能大家已经发现了，上面的计算和加密、解密的步骤非常相似。</p>
<ul>
<li><p>将明文A用密钥B进行加密，得到密文A⊕B</p>
</li>
<li><p>将密文A⊕B用密钥B进行解密，得到明文A</p>
</li>
</ul>
<p>实际上，只要选择一个合适的B，仅仅使用XOR就可以实现一个高强度的密码。</p>
<p>对同一个比特序列进行两次XOR之后就会回到最初的状态。</p>
</blockquote>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><blockquote>
<p>CBC(Cipher Block Chaining, 密码块链)<font color="red">模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密</font>。  这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，<font color="red">第一个数据块进行加密之前需要用初始化向量IV进行异或操作</font>。  <font color="red">CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。</font></p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110639241.png" alt="image-20210817110639241" style="zoom:67%;">

<blockquote>
<p> 如果将一个分组的加密过程分离出来，我们就可以很容易地比较出ECB模式和CBC模式的区别 。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110715286.png" alt="image-20210817110715286" style="zoom:50%;">

<h3 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><strong>当加密第一个明文分组时，由于不存在“前一个密文分组”，因此<font color="red">需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组</font>“，这个比特序列称为初始化向量（initialization vector）</strong> 通常缩写为 IV </p>
</blockquote>
<h2 id="CFB-模式"><a href="#CFB-模式" class="headerlink" title="CFB 模式"></a>CFB 模式</h2><blockquote>
<p>CFB模式的全称是Cipher FeedBack模式（密文反馈模式）。在CFB模式中，<font color="red">前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</font>。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111048158.png" alt="image-20210817111048158" style="zoom:67%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111109864.png" alt="image-20210817111109864" style="zoom:67%;">

<blockquote>
<p>在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。</p>
<p>从上图可以看出，明文分组和密文分组之间并没有经过”加密”这一步骤。在CFB模式中，明文分和密文分组之间只有一个XOR。</p>
<p>我们将CBC模式与CFB模式对比一下，就可以看出其中的差异了（如下图）。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB模式中，明文分组和密文分组之间则只有XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111235512.png" alt="image-20210817111235512" style="zoom:50%;">

<h3 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><font color="red">在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替</font>，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。</p>
</blockquote>
<h3 id="CFB模式与流密码"><a href="#CFB模式与流密码" class="headerlink" title="CFB模式与流密码"></a>CFB模式与流密码</h3><blockquote>
<p>CFB模式是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”的。</p>
<p>在CFB模式中，密码算法的输出相当于一个随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此CFB模式不可能具各理论上不可破译的性质。</p>
<p><font color="red">CFB模式中由加密算法所生成的比特序列称为密钥流（key stream）</font>。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的“种子“。</p>
<p>在CFB模式中，<font color="red">明文数据可以被逐比特加密</font>，因此我们<font color="red">可以将CFB模式看做是一种使用分组密码来实现流密码的方式</font>。</p>
</blockquote>
<h2 id="OFB-模式"><a href="#OFB-模式" class="headerlink" title="OFB 模式"></a>OFB 模式</h2><blockquote>
<p>OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将 “明文分组” 和 “密码算法的输出” 进行XOR来产生 “密文分组” 的，在这一点上OFB模式和CFB模式非常相似。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111629522.png" alt="image-20210817111629522" style="zoom:67%;">

<h3 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p>和CBC模式、CFB模式一样，OFB模式中也需要使用初始化向量（IV）。</p>
</blockquote>
<h3 id="CFB模式和OFB模式对比"><a href="#CFB模式和OFB模式对比" class="headerlink" title="CFB模式和OFB模式对比"></a>CFB模式和OFB模式对比</h3><blockquote>
<p>OFB模式和CFB模式的区别仅仅在于密码算法的输入。</p>
<p>CFB式中，密码算法的输人是前一个密文分组，也就是将密文分组反馈到密算法中，因此就有了“密文反馈模式”这个名字。</p>
<p>相对地，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈给密码算法，因此就有了“输出反馈模式”这个名字。</p>
<p>如果将一个分组抽出来对CFB模式和OFB模式进行一个对比．就可以很容易看出它们之间的差异（下图）。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112004499.png" alt="image-20210817112004499" style="zoom:67%;">

<blockquote>
<p>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。</p>
<p>相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了。只要将明文与密钥流进行XOR就可以了。和AES等密码算法相比，XOR运算的速度是非常快的。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p>
</blockquote>
<h2 id="CTR-模式"><a href="#CTR-模式" class="headerlink" title="CTR 模式"></a>CTR 模式</h2><blockquote>
<p>CTR模式的全称是CounTeR模式（计数器模式）。<font color="red">CTR摸式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码</font>（下图）。</p>
<p>CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112246534.png" alt="image-20210817112246534" style="zoom:50%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112306254.png" alt="image-20210817112306254" style="zoom:50%;">

<h3 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h3><blockquote>
<p>每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是像下面这样的形式。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112459058.png" alt="image-20210817112459058" style="zoom:80%;">

<blockquote>
<p>其中前8个字节为nonce（随机数），这个值在每次加密时必须都是不同的，后8个字节为分组序号，这个部分是会逐次累加的。在加密的过程中，计数器的值会产生如下变化：</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112557257.png" alt="image-20210817112557257" style="zoom:80%;">

<blockquote>
<p>按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p>
</blockquote>
<h3 id="OFB模式与CTR模式对比"><a href="#OFB模式与CTR模式对比" class="headerlink" title="OFB模式与CTR模式对比"></a>OFB模式与CTR模式对比</h3><blockquote>
<p>CTR模式和OFB模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么OFB模式和CTR模式之间的差异还是很容易理解的（下图）。OFB模式是将加密的输出反愦到输入，而CTR模式则是将计数器的值用作输入。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112653539.png" alt="image-20210817112653539" style="zoom:67%;">

<h3 id="CTR模式的特点"><a href="#CTR模式的特点" class="headerlink" title="CTR模式的特点"></a>CTR模式的特点</h3><blockquote>
<p>CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。</p>
<p>此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。</p>
<p>能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112810129.png" alt="image-20210817112810129 " style="zoom:80%;">

<ol>
<li><p>ECB - Electronic Code Book, 电子密码本模式</p>
<ul>
<li>特点: 简单, 效率高, 密文有规律, 容易被破解</li>
<li>最后一个明文分组必须要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>不需要初始化向量</li>
</ul>
</li>
<li><p>CBC - Cipher Block Chaining, 密码块链模式</p>
<ul>
<li>特点: 密文没有规律, 经常使用的加密方式</li>
<li>最后一个明文分组需要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
</ul>
</li>
<li><p>CFB - Cipher FeedBack, 密文反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>OFB - Output-Feedback, 输出反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>CTR - CounTeR, 计数器模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>不需要初始化向量<ul>
<li>go接口中的iv可以理解为随机数种子, iv的长度 == 明文分组的长度</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Go实现对称算法</title>
    <url>/2021/08/17/Go%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Go中对DES的操作"><a href="#Go中对DES的操作" class="headerlink" title="Go中对DES的操作"></a>Go中对DES的操作</h2><p>最后一个分组添加填充数据和移除添加数据代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充函数，如果最后一个分组字节数不够, 填充</span></span><br><span class="line"><span class="comment">// 使用pks5的方式填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算最后一个分组缺多少个字节</span></span><br><span class="line">	padding := blockSize - (<span class="built_in">len</span>(ciphertext)%blockSize)</span><br><span class="line">	<span class="comment">// 2. 创建一个大小为padding的切片, 每个字节的值为padding</span></span><br><span class="line">	padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="comment">// 3. 将padText添加到原始数据的后边, 将最后一个分组缺少的字节数补齐</span></span><br><span class="line">	newText := <span class="built_in">append</span>(ciphertext, padText...)</span><br><span class="line">	<span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除pks5填充的尾部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的总长度</span></span><br><span class="line">	length := <span class="built_in">len</span>(origData)</span><br><span class="line">	<span class="comment">// 2. 根据填充的字节值得到填充的次数</span></span><br><span class="line">	number := <span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 3. 将尾部填充的number个字节去掉</span></span><br><span class="line">	<span class="keyword">return</span> origData[:(length-number)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加解密实现思路"><a href="#加解密实现思路" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit, 即 64/8 = 8字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><p>解密：</p>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="加解密的代码实现"><a href="#加解密的代码实现" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>在Go中使用DES需要导入的包:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/des&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要加密的明文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 对最后一个明文分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 4. 创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</span></span><br><span class="line">	<span class="comment">//    参数iv的长度, 必须等于b的块尺寸</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blackMode := cipher.NewCBCEncrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 5. 加密连续的数据块</span></span><br><span class="line">	dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	blackMode.CryptBlocks(dst, src)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;加密之后的数据: &quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 将加密数据返回</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要解密的密文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 和加密秘钥相同, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 4. 解密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(src, dst)</span><br><span class="line">	<span class="comment">// 5. 去掉最后一组填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 返回结果</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试函数:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DESText</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加密</span></span><br><span class="line">	key := []<span class="keyword">byte</span>(<span class="string">&quot;11111111&quot;</span>)</span><br><span class="line">	result := DesEncrypt_CBC([]<span class="keyword">byte</span>(<span class="string">&quot;床前明月光, 疑是地上霜. 举头望明月, 低头思故乡.&quot;</span>), key)</span><br><span class="line">	fmt.Println(base64.StdEncoding.EncodeToString(result))</span><br><span class="line">	<span class="comment">// 解密</span></span><br><span class="line">	result = DesDecrypt_CBC(result, key)</span><br><span class="line">	fmt.Println(<span class="string">&quot;解密之后的数据: &quot;</span>, <span class="keyword">string</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用DES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: des对称加密使用的密码, 密码长度为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>自定义函数介绍</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">对称加密加密需要对数据进行分组, 保证每个分组的数据长度相等, 如果最后一个分组长度不够, 需要进行填充</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数 ciphertext: 需要加密的原始数据</span><br><span class="line">    - 参数 blockSize: 每个分组的长度, 跟使用的加密算法有关系</span><br><span class="line">		* des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* <span class="number">3</span>des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* aes： <span class="number">128</span>bit， <span class="number">16</span><span class="keyword">byte</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对3DES的操作"><a href="#Go中对3DES的操作" class="headerlink" title="Go中对3DES的操作"></a>Go中对3DES的操作</h2><h3 id="加解密实现思路-1"><a href="#加解密实现思路-1" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><p><strong>加密 - CBC分组模式</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit*3=192bit, 即 192/8 = 24字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>3DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<p><strong>解密</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-1"><a href="#加解密的代码实现-1" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>3DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3DES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用3DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 对最后一组明文进行填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式, 底层使用3DES加密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 4. 加密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3DES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建3DES算法的Block接口对象</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建密码分组为链接模式, 底层使用3DES解密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li> 生成一个底层使用3DES加/解密的Block接口对象</li>
</ol>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTripleDESCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: <span class="number">3</span>des对称加密使用的密码, 密码长度为(<span class="number">64</span>*<span class="number">3</span>)bit, 即(<span class="number">8</span>*<span class="number">3</span>)<span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对AES的使用"><a href="#Go中对AES的使用" class="headerlink" title="Go中对AES的使用"></a>Go中对AES的使用</h2><h3 id="加解密实现思路-2"><a href="#加解密实现思路-2" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为128bit, 即 128/8 = 16字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>AES是以128比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够128bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用AES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><strong>解密</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用AES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-2"><a href="#加解密的代码实现-2" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>AES加密代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES加密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 最后一个分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个分组为链接模式, 底层使用AES加密的块模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 4. 加密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AES解密:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES解密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建分组为链接模式, 底层使用AES的解密模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的字</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用AES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: aes对称加密使用的密码, 密码长度为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用AES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用aes.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<h2 id="应选择哪种对称加密"><a href="#应选择哪种对称加密" class="headerlink" title="应选择哪种对称加密"></a>应选择哪种对称加密</h2><blockquote>
<p>前面我们介绍了DES、三重DES和AES等对称密码，那么我们到底应该使用哪一种对称密码算法呢？</p>
<ol>
<li><strong>今后最好不要将DES用于新的用途，因为随着计算机技术的进步，现在用暴力破解法已经能够在现实的时间内完成对DES的破译。但是，在某些情况下也需要保持与旧版本软件的兼容性。</strong></li>
<li><strong>出于兼容性的因素三重DES在今后还会使用一段时间，但会逐渐被AES所取代。</strong></li>
<li><strong>今后大家应该使用的算法是AES（Rijndael），因为它安全、快速，而且能够在各种平台上工作。此外，由于全世界的密码学家都在对AES进行不断的验证，因此即便万一发现它有什么缺陷，也会立刻告知全世界并修复这些缺陷。</strong></li>
</ol>
<p>一般来说，我们不应该使用任何自制的密码算法，而是应该使用AES。因为AES在其选定过程中，经过了全世界密码学家所进行的高品质的验证工作，而对于自制的密码算法则很难进行这样的验证。 </p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>02周易基础及其应用</title>
    <url>/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/</url>
    <content><![CDATA[<h2 id="地支"><a href="#地支" class="headerlink" title="地支"></a>地支</h2><blockquote>
<p>子        十一                辰            三月                申            七月</p>
<p>丑        十二                巳            四月                酉            八月</p>
<p>寅        正月                午            五月                戌            九月</p>
<p>卯        二月                未            六月                亥            十月</p>
</blockquote>
<h2 id="地支对应阴阳"><a href="#地支对应阴阳" class="headerlink" title="地支对应阴阳"></a>地支对应阴阳</h2><p>子丑寅卯辰巳午未申酉戌亥           单数为阳，奇数为阴</p>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817233329429.png" alt="image-20210817233329429" style="zoom:30%;">

<h2 id="地支对应方位"><a href="#地支对应方位" class="headerlink" title="地支对应方位"></a>地支对应方位</h2><table>
<thead>
<tr>
<th align="center">方位</th>
<th align="center">对应地支</th>
<th align="center">五行</th>
<th align="center">月份</th>
</tr>
</thead>
<tbody><tr>
<td align="center">东</td>
<td align="center">寅 卯</td>
<td align="center">木</td>
<td align="center">正月 二月</td>
</tr>
<tr>
<td align="center">南</td>
<td align="center">巳 午</td>
<td align="center">火</td>
<td align="center">四月 五月</td>
</tr>
<tr>
<td align="center">西</td>
<td align="center">申 酉</td>
<td align="center">金</td>
<td align="center">七月 八月</td>
</tr>
<tr>
<td align="center">北</td>
<td align="center">亥 子</td>
<td align="center">水</td>
<td align="center">十月 十一月</td>
</tr>
<tr>
<td align="center">中</td>
<td align="center">辰戌丑未</td>
<td align="center">土</td>
<td align="center">三月 九月 六月 十二月</td>
</tr>
</tbody></table>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817234729721.png" alt="image-20210817234729721" style="zoom:50%;">

<h2 id="地支相生相克"><a href="#地支相生相克" class="headerlink" title="地支相生相克"></a>地支相生相克</h2><table>
<thead>
<tr>
<th align="center">相生</th>
<th align="center">相克</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寅卯木   生    巳午火</td>
<td align="center">寅卯木    克     辰戌丑未土</td>
</tr>
<tr>
<td align="center">巳午火    生    辰戌丑未土</td>
<td align="center">辰戌丑未土    克    亥子水</td>
</tr>
<tr>
<td align="center">辰戌丑未土    生    申酉金</td>
<td align="center">亥子水    克     巳午火</td>
</tr>
<tr>
<td align="center">申酉金    生    亥子水</td>
<td align="center">巳午火     克    申酉金</td>
</tr>
<tr>
<td align="center">亥子水    生    寅卯木</td>
<td align="center">申酉金   克     寅卯木</td>
</tr>
</tbody></table>
<center><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817235421581.png" alt="image-20210817235421581" style="zoom:50%;"><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817235937674.png" alt="image-20210817235937674" style="zoom:50%;"></center>

<h2 id="地支六冲六合"><a href="#地支六冲六合" class="headerlink" title="地支六冲六合"></a>地支六冲六合</h2><h3 id="六冲"><a href="#六冲" class="headerlink" title="六冲"></a>六冲</h3><blockquote>
<p>子丑寅卯辰巳</p>
<p>午未申酉戌亥  </p>
</blockquote>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210818000234540.png" alt="image-20210818000234540" style="zoom:33%;">

<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210902200410598.png" alt="image-20210902200410598" style="zoom:50%;">

<h3 id="六合"><a href="#六合" class="headerlink" title="六合"></a>六合</h3><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210818000444347.png" alt="image-20210818000444347" style="zoom:40%;">

<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210902200534887.png" alt="image-20210902200534887" style="zoom:50%;">]]></content>
      <categories>
        <category>哲学</category>
        <category>周易基础及其应用</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称加密</title>
    <url>/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;非对称加密也叫公钥密码: 使用公钥加密, 使用私钥解密&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对称加密的弊端"><a href="#对称加密的弊端" class="headerlink" title="对称加密的弊端"></a>对称加密的弊端</h2><ul>
<li><p>秘钥分发困难</p>
</li>
<li><p>可以通过非对称加密完成秘钥的分发</p>
<blockquote>
<p>https</p>
<p>Alice 和 Bob通信, Alice给bob发送数据, 使用对称加密的方式</p>
<ol>
<li>生成一个非对称的秘钥对, bob生成</li>
<li>bob将公钥发送给alice</li>
<li>alice生成一个用于对称加密的秘钥</li>
<li>alice使用bob的公钥就对称加密的秘钥进行加密, 并且发送给bob</li>
<li>bob使用私钥就数据解密, 得到对称加密的秘钥</li>
<li>通信的双方使用写好的秘钥进行对称加密数据加密</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="非对称加密的秘钥"><a href="#非对称加密的秘钥" class="headerlink" title="非对称加密的秘钥"></a>非对称加密的秘钥</h2><ul>
<li>不存在秘钥分发困难的问题</li>
</ul>
<h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>数据对谁更重要, 谁就拿私钥</p>
<ul>
<li>直观上看: 私钥比公钥长</li>
<li>使用第三方工具生成密钥对: 公钥文件xxx.pub xxx </li>
</ul>
<blockquote>
<ol>
<li><p>通信流程, 信息加密  （A写数据, 发送给B, 信息只允许B读）</p>
<p>A: 公钥</p>
<p>B: 私钥</p>
</li>
<li><p>登录认证 （客户端要登录, 连接服务器, 向服务器请求个人数据）</p>
<p>客户端:  私钥</p>
<p>服务器:  公钥</p>
</li>
<li><p>数字签名（表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面）</p>
<ul>
<li>发送信息的人:   私钥</li>
<li>收到信息的人:   公钥</li>
</ul>
</li>
<li><p>网银U盾</p>
<ul>
<li>个人: 私钥</li>
<li>银行拿公钥</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><blockquote>
<p>非对称加密的代表—RSA。在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，如下:                                                                                    </p>
</blockquote>
<p>$$<br>密文=明文 ^ E  mod     N（RSA加密）<br>$$</p>
<blockquote>
<p>也就是说，RSA的密文是对代表明文的数字的E次方求modN的结果。换句话说，就是将明文自己做E次乘法，然后将其结果除以N求余数，这个余数就是密文。</p>
<p>加密公式中出现的两个数一一一E和N，到底都是什么数呢？RSA的加密是求明文的E次方modN，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，E和N是RSA加密的密钥，也就是说，<strong>E和N的组合就是公钥</strong>。</p>
<p>不过，E和N并不是随便什么数都可以的，它们是经过严密计算得出的。顺便说一句，<strong>E是加密（Encryption）的首字母，N是数字（Number)的首字母</strong>。</p>
<p>有一个很容易引起误解的地方需要大家注意一一E和N这两个数并不是密钥对（公钥和私钥的密钥对）。E和N两个数才组成了一个公钥，因此我们一般会写成 “公钥是(E，N)” 或者 “公钥是{E, N}” 这样的形式，将E和N用括号括起来。</p>
<p>现在大家应该已经知道，==<strong>RSA的加密就是 “求E次方的modN”</strong>==，接下来我们来看看RSA的解密。</p>
</blockquote>
<h3 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h3><blockquote>
<p>RSA的解密和加密一样简单，可以用下面的公式来表达：</p>
</blockquote>
<p>$$<br>明文=密文^DmodN（RSA解密）<br>$$</p>
<blockquote>
<p>也就是说，对表示密文的数字的D次方求modN就可以得到明文。换句话说，将密文自己做D次乘法，再对其结果除以N求余数，就可以得到明文。</p>
<p>这里所使用的数字N和加密时使用的数字N是相同的。<strong>数D和数N组合起来就是RSA的解密密钥，因此D和N的组合就是私钥</strong>。只有知道D和N两个数的人才能够完成解密的运算。</p>
<p>大家应该已经注意到，<strong>在RSA中，加密和解密的形式是相同的。加密是求 “E次方的mod N”，而解密则是求 “D次方的modN”</strong>，这真是太美妙了。</p>
<p>当然，D也并不是随便什么数都可以的，作为解密密钥的D，和数字E有着相当紧密的联系。否则，用E加密的结果可以用D来解密这样的机制是无法实现的。</p>
<p>顺便说一句，<strong>D是解密〈Decryption）的首字母，N是数字（Number）的首字母</strong>。</p>
<p>我们将上面讲过的内容整理一下，如下表所示。</p>
</blockquote>
<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143403596.png" alt="image-20210818143403596" style="zoom:67%;">

<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143417941.png" alt="image-20210818143417941" style="zoom:67%;">

<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol>
<li>x509证书规范、pem、base64<ul>
<li>pem编码规范 - 数据加密</li>
<li>base64 - 对数据编码, 可逆<ul>
<li>不管原始数据是什么, 将原始数据使用64个字符来替代<ul>
<li>a-z  A-Z 0-9 + /</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ASN.1抽象语法标记</li>
<li>PKCS1标准</li>
</ol>
<h2 id="Go中生成公钥和私钥"><a href="#Go中生成公钥和私钥" class="headerlink" title="Go中生成公钥和私钥"></a>Go中生成公钥和私钥</h2><p>需要引入的包:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>生成私钥操作流程概述:</p>
<blockquote>
<ol>
<li>使用rsa中的GenerateKey方法生成私钥</li>
<li>通过x509标准将得到的ras私钥序列化为ASN.1 的 DER编码字符串</li>
<li>将私钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件中</li>
</ol>
</blockquote>
<p>生成公钥操作流程:</p>
<blockquote>
<ol>
<li>从得到的私钥对象中将公钥信息取出</li>
<li>通过x509标准将得到 的rsa公钥序列化为字符串</li>
<li>将公钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件</li>
</ol>
</blockquote>
<p>生成公钥和私钥的源代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数bits: 指定生成的秘钥的长度, 单位: bit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaGenKey</span><span class="params">(bits <span class="keyword">int</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 生成私钥件</span></span><br><span class="line">	<span class="comment">// GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥</span></span><br><span class="line">	<span class="comment">// 参数1: Reader是一个全局、共享的密码用强随机数生成器</span></span><br><span class="line">	<span class="comment">// 参数2: 秘钥的位数 - bit</span></span><br><span class="line">	privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. MarshalPKCS1PrivateKey将rsa私钥序列化为ASN.1 PKCS#1 DER编码</span></span><br><span class="line">	derStream := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line">	<span class="comment">// 3. Block代表PEM编码的结构, 对其进行设置</span></span><br><span class="line">	block := pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>,<span class="comment">//&quot;RSA PRIVATE KEY&quot;,</span></span><br><span class="line">		Bytes: derStream,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4. 创建文件</span></span><br><span class="line">	privFile, err := os.Create(<span class="string">&quot;private.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 使用pem编码, 并将数据写入文件中</span></span><br><span class="line">	err = pem.Encode(privFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 最后的时候关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> privFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 生成公钥文件</span></span><br><span class="line">	publicKey := privateKey.PublicKey</span><br><span class="line">	derPkix, err := x509.MarshalPKIXPublicKey(&amp;publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	block = pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PUBLIC KEY&quot;</span>,<span class="comment">//&quot;PUBLIC KEY&quot;,</span></span><br><span class="line">		Bytes: derPkix,</span><br><span class="line">	&#125;</span><br><span class="line">	pubFile, err := os.Create(<span class="string">&quot;public.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 8. 编码公钥, 写入文件</span></span><br><span class="line">	err = pem.Encode(pubFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> pubFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数介绍:</p>
<ol>
<li><p>GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;crypto/rsa&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(random io.Reader, bits <span class="keyword">int</span>)</span> <span class="params">(priv *PrivateKey, err error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: io.Reader: 赋值为: rand.Reader</span><br><span class="line">        -- rand包实现了用于加解密的更安全的随机数生成器。</span><br><span class="line">        -- <span class="keyword">var</span> Reader io.Reader (rand包中的变量)</span><br><span class="line">    - 参数<span class="number">2</span>: bits: 秘钥长度</span><br><span class="line">    - 返回值<span class="number">1</span>: 代表一个RSA私钥。</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>通过x509 将rsa私钥序列化为ASN.1 PKCS#1 DER编码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数 (x509包解析X<span class="number">.509</span>编码的证书和密钥)。</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKCS1PrivateKey</span><span class="params">(key *rsa.PrivateKey)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过rsa.GenerateKey得到的私钥</span><br><span class="line">    - 返回值: 将私钥通过ASN<span class="number">.1</span>序列化之后得到的私钥编码数据</span><br></pre></td></tr></table></figure></li>
<li><p>设置Pem编码结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Block代表PEM编码的结构。</span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span>            <span class="comment">// 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">    Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 可选的头项，Headers是可为空的多行键值对。</span></span><br><span class="line">    Bytes   []<span class="keyword">byte</span>            <span class="comment">// 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将得到的Pem格式私钥通过文件指针写入磁盘中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, b *Block)</span> <span class="title">error</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 可进行写操作的IO对象, 此处需要指定一个文件指针</span><br><span class="line">    - 参数<span class="number">2</span>: 初始化完成的Pem块对象, 即Block对象</span><br></pre></td></tr></table></figure></li>
<li><p>通过RSA私钥得到公钥</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥</span></span><br><span class="line">    D         *big.Int   <span class="comment">// 私有的指数</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// N的素因子，至少有两个</span></span><br><span class="line">    <span class="comment">// 包含预先计算好的值，可在某些情况下加速私钥的操作</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    N   *big.Int <span class="comment">// 模</span></span><br><span class="line">    E   <span class="keyword">int</span>      <span class="comment">// 公开的指数</span></span><br><span class="line">&#125;</span><br><span class="line">通过私钥获取公钥</span><br><span class="line">publicKey := privateKey.PublicKey <span class="comment">// privateKey为私钥对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过x509将公钥序列化为PKIX格式DER编码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKIXPublicKey</span><span class="params">(pub <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过私钥对象得到的公钥</span><br><span class="line">    - 返回值<span class="number">1</span>：将公钥通过ASN<span class="number">.1</span>序列化之后得到的编码数据</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>将公钥编码之后的数据格式化为Pem结构, 参考私钥的操作</p>
</li>
<li><p>将得到的Pem格式公钥通过文件指针写入磁盘中</p>
</li>
<li><p>生成的私钥和公钥文件数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 私钥文件数据</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXgIBAAKBgQC5bm0DCEV+EFeiLUqSshziqhSB30jXy5BWbPV5SlMq4aWiEknM</span><br><span class="line">i+Mw1aXic4bEsM3YyT73eWsifqZNSc/4fRaV4qz5OL8IIe9AZoGDSLX/Ar9AQMJf</span><br><span class="line">OHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3DVEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">AoGARGdn72ZtvENrEHiEufjajwMO7Zng1TpS1I79PvEcHQWAhHkaoEo6VRl7SD41</span><br><span class="line">yPkv9njGsaQo0WDHGFvSTGhYm/EWGrBWRPc5xXbSBg7ty9Iza9B1ekAj8VfWryen</span><br><span class="line">Wje3xDOCVCDUiCcYdaSfPiJPYuWMSnNMNa+0cR921zBQg0ECQQDpCMljuH7LrpbC</span><br><span class="line">NDF5q+LbUWMAE2KLDPX4WmDSdZdIO3mPux3MdwOUEfrcvSBGZNB7gyaEG7goZL8G</span><br><span class="line">BqL22MJHAkEAy7SqbVPoPbMPHuLI52VQ2FDp6xxSWLhjmv1ePCHGo28MDCaHeVzZ</span><br><span class="line">QaxyuIbnY8A6NHfu/QGwz/eB941IjYNBMwJBAI9XEEl+mr++zIz4fdZRnGE7VqId</span><br><span class="line">SmgtuL7jGNtb6YpMyyFV/6ZdLp5N0PkmfEvQh0zyBycLxeNS1Q1n16Xu/tECQQCZ</span><br><span class="line">dF42wdDgOfWYFMu31VETw9CTtuApya3vYhMNRXx4Pf1bYeMIf/OCT8CUVbwWHwc5</span><br><span class="line">42d73TwvTorvy9TuFgSVAkEA6F69THlTn5oIP8IWHcHuqS01fIR/vGfEwQ4cFZGR</span><br><span class="line">ketfieyeeF8rjn4qzwT/ugwRNjkhfKmoILnIC8UhEEJdjA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公钥文件数据</span></span><br><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5bm0DCEV+EFeiLUqSshziqhSB</span><br><span class="line"><span class="number">30</span>jXy5BWbPV5SlMq4aWiEknMi+Mw1aXic4bEsM3YyT73eWsifqZNSc/<span class="number">4</span>fRaV4qz5</span><br><span class="line">OL8IIe9AZoGDSLX/Ar9AQMJfOHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3D</span><br><span class="line">VEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中使用RSA加解密"><a href="#Go中使用RSA加解密" class="headerlink" title="Go中使用RSA加解密"></a>Go中使用RSA加解密</h2><ol>
<li><p>操作步骤</p>
<ul>
<li><p>公钥加密</p>
<blockquote>
<ol>
<li>将公钥文件中的公钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的公钥解析出来</li>
<li>使用得到的公钥通过rsa进行数据加密</li>
</ol>
</blockquote>
</li>
<li><p>私钥解密</p>
<blockquote>
<ol>
<li>将私钥文件中的私钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的私钥解析出来</li>
<li>使用得到的私钥通过rsa进行数据解密</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li>RSA公钥加密</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSAEncrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">    file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 读文件</span></span><br><span class="line">    info, _ := file.Stat()</span><br><span class="line">    allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">    file.Read(allText)</span><br><span class="line">    <span class="comment">// 3. 关闭文件</span></span><br><span class="line">    file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">    block, _ := pem.Decode(allText)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 解析一个DER编码的公钥</span></span><br><span class="line">    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 公钥加密</span></span><br><span class="line">    result, _ := rsa.EncryptPKCS1v15(rand.Reader, pubKey, src)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RSA私钥解密</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSADecrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">  file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 读文件</span></span><br><span class="line">  info, _ := file.Stat()</span><br><span class="line">  allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">  file.Read(allText)</span><br><span class="line">  <span class="comment">// 3. 关闭文件</span></span><br><span class="line">  file.Close()</span><br><span class="line">  <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">  block, _ := pem.Decode(allText)</span><br><span class="line">  <span class="comment">// 5. 解析一个pem格式的私钥</span></span><br><span class="line">  privateKey , err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">  <span class="comment">// 6. 私钥解密</span></span><br><span class="line">  result, _ := rsa.DecryptPKCS1v15(rand.Reader, privateKey, src)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重要的函数介绍</li>
</ul>
<ol>
<li>将得到的Pem格式私钥通过文件指针写入磁盘中</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(p *Block, rest []<span class="keyword">byte</span>)</span></span></span><br><span class="line">    - 参数 data: 需要解析的数据块</span><br><span class="line">    - 返回值<span class="number">1</span>: 从参数中解析出的PEM格式的块</span><br><span class="line">    - 返回值<span class="number">2</span>: 参数data剩余的未被解码的数据</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解析一个DER编码的公钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKIXPublicKey</span><span class="params">(derBytes []<span class="keyword">byte</span>)</span> <span class="params">(pub <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br><span class="line">    - 参数 derBytes: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 pub: 接口对象, 实际是公钥数据</span><br><span class="line">    - 参数 err:   错误信息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解析一个DER编码的私钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKCS1PrivateKey</span><span class="params">(der []<span class="keyword">byte</span>)</span> <span class="params">(key *rsa.PrivateKey, err error)</span></span></span><br><span class="line">    - 参数 der: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 key: 解析出的私钥</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将接口转换为公钥</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line">    - pubInterface: ParsePKIXPublicKey函数返回的 <span class="keyword">interface</span>&#123;&#125; 对象</span><br><span class="line">    - pubInterface.(*rsa.PublicKey): 将pubInterface转换为公钥类型 rsa.PublicKey</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用公钥加密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPKCS1v15</span><span class="params">(rand io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 pub:  非对称加密加密使用的公钥</span><br><span class="line">    - 参数 msg:  要使用公钥加密的原始数据</span><br><span class="line">    - 返回值 out: 加密之后的数据</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用私钥解密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 priv: 非对称加密解密使用的私钥</span><br><span class="line">    - 参数 ciphertext: 需要使用私钥解密的数据</span><br><span class="line">    - 返回值 out: 解密之后得到的数据</span><br><span class="line">    - 返回值 err: 错误信</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ECC椭圆曲线"><a href="#ECC椭圆曲线" class="headerlink" title="ECC椭圆曲线"></a>ECC椭圆曲线</h2><blockquote>
<ol>
<li>概念</li>
</ol>
<p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。</p>
<p>ECC 164位的密钥产生的一个安全级相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国<code>居民二代身份证</code>正在使用 256 位的椭圆曲线密码，虚拟货币<code>比特币</code>也选择ECC作为加密算法。</p>
<p>具体算法详解参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></li>
<li><a href="https://blog.csdn.net/taifei/article/details/73277247">https://blog.csdn.net/taifei/article/details/73277247</a></li>
</ul>
<ol start="2">
<li>数学原理</li>
</ol>
<p>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。</p>
<p>椭圆曲线依赖的数学难题是:</p>
<p><code>k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知Q和P，很难计算出k</code></p>
</blockquote>
<h2 id="非对称加密解惑"><a href="#非对称加密解惑" class="headerlink" title="非对称加密解惑"></a>非对称加密解惑</h2><ul>
<li>非对称加密比对称加密机密性更高吗?</li>
</ul>
<blockquote>
<p>这个问题无法回答, 以为机密性高低是根据秘钥长度而变化的</p>
</blockquote>
<ul>
<li><strong>采用1024bit 秘钥长度的非对称加密, 和采用128bit秘钥长度的对称加密中, 是秘钥更长的非对称加密更安全吗?</strong></li>
</ul>
<blockquote>
<p>不是。</p>
<p>非对称加密的密钥长度不能与对称加密的密钥长度进行直接比较。下表是一张密钥长度的比较表（本表摘自《应用密码学》），根据这张表我们可以看出，1024比特的公钥密码与128比特的对称密码相比，反而是128比特的对称密码抵御暴力破解的能力更强。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">对称加密秘钥长度</th>
<th align="center">非对称加密秘钥长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">128 比特</td>
<td align="center">2304 比特</td>
</tr>
<tr>
<td align="center">112 比特</td>
<td align="center">1792 比特</td>
</tr>
<tr>
<td align="center">80 比特</td>
<td align="center">768 比特</td>
</tr>
<tr>
<td align="center">64 比特</td>
<td align="center">512 比特</td>
</tr>
<tr>
<td align="center">56 比特</td>
<td align="center">384 比特</td>
</tr>
</tbody></table>
<ul>
<li><strong>有了非对称加密， 以后对称加密会被替代吗？</strong></li>
</ul>
<blockquote>
<p>不会</p>
<p>一般来说，在采用具备同等机密性的密钥长度的情况下，非对称加密的处理速度只有对称加密的几百分之一。因此，非对称加密并不适合用来对很长的消息内容进行加密。根据目的的不同，还可能会配合使用对称加密和非对称加密，如，混合密码系统就是将这两种密码组合而成的。</p>
</blockquote>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>单向散列函数</title>
    <url>/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="什么是单向散列函数"><a href="#什么是单向散列函数" class="headerlink" title="什么是单向散列函数"></a>什么是单向散列函数</h2><blockquote>
<p>单向散列函数（one-wayftnction）有一个输人和一个输出，其中输人称为消息（message），输出称为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。</p>
<p>散列值的长度和消息的长度无关。无论消息是1比特，还是100MB，甚至是IOOGB，单向散列函数都会计算出固定长度的散列值。以SHA-I单向散列函数为例，它所计算出的散列值的长度永远是160比特（20字节）</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150209003.png" alt="image-20210818150209003" style="zoom:67%;">

<h2 id="单向散列函数的性质"><a href="#单向散列函数的性质" class="headerlink" title="单向散列函数的性质"></a>单向散列函数的性质</h2><ul>
<li><p>根据任意长度的消息计算出固定长度的散列值</p>
</li>
<li><p>能够快速计算出散列值</p>
</li>
<li><p>消息不同散列值也不同</p>
<blockquote>
<p>为了能够确认完整性，消息中哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值。</p>
<p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。<strong>两个不同的消息产生同一个散列值的情况称为碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。</p>
</blockquote>
</li>
<li><p><strong>具备单向性</strong></p>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150357989.png" alt="image-20210818150357989" style="zoom:67%;"></li>
</ul>
<h2 id="单向散列函数的实际应用"><a href="#单向散列函数的实际应用" class="headerlink" title="单向散列函数的实际应用"></a>单向散列函数的实际应用</h2><ul>
<li>检测软件是否被篡改</li>
</ul>
<blockquote>
<p>我们可以使用单向散列函数来确认自己下载的软件是否被篡改。</p>
<p>很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。</p>
<p>这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150530259.png" alt="image-20210818150530259" style="zoom:67%;">

<ul>
<li><p>消息认证码</p>
<blockquote>
<p>使用单向散列函数可以构造消息认证码。</p>
<p>消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</p>
<p>消息认证码在SSL/TLS中也得到了运用，关于SSL/TLS我们将后边章节中介绍。</p>
</blockquote>
</li>
<li><p>数字签名</p>
<blockquote>
<p>在进行数字签名时也会使用单向散列函数。</p>
<p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
</li>
<li><p>伪随机数生成器</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li><p>一次性口令</p>
<blockquote>
<p>使用单向散列函数可以构造一次性口令（one-time password）。</p>
<p>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p>
</blockquote>
</li>
</ul>
<h2 id="常用的单向散列函数"><a href="#常用的单向散列函数" class="headerlink" title="常用的单向散列函数"></a>常用的单向散列函数</h2><h3 id="MD4、MD5"><a href="#MD4、MD5" class="headerlink" title="MD4、MD5"></a>MD4、MD5</h3><blockquote>
<p>MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。</p>
<p>MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。</p>
</blockquote>
<p>Go中使用MD5</p>
<ul>
<li><p>需要导入的包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>计算Md5的方式1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_1</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的md5</span></span><br><span class="line">	result := md5.Sum(str)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, result)</span><br><span class="line">	<span class="comment">// 2. 数据格式化为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result[:])</span><br><span class="line">	fmt.Println(<span class="string">&quot;res: &quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span>  res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>返回数据data的MD5校验和</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span></span><br><span class="line">    - 参数 data: 原始数据</span><br><span class="line">    - 返回值: 经过md5计算之后得到的数据, 长度为 <span class="number">16</span>字节(<span class="keyword">byte</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>将字符串编码为16进制格式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToString</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span></span><br><span class="line">    - 参数 src: 要转换的数据</span><br><span class="line">    - 返回值: 转换之后得到的<span class="number">16</span>进制格式字符串</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>计算Md5的方式2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_2</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用MD5校验的Hash对象`</span></span><br><span class="line">	myHash := md5.New()</span><br><span class="line">	<span class="comment">// 2. 通过io操作将数据写入hash对象中</span></span><br><span class="line">	io.WriteString(myHash, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="comment">//io.WriteString(myHash, &quot;, world&quot;)</span></span><br><span class="line">	myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;, world&quot;</span>))</span><br><span class="line">	<span class="comment">// 3. 计算结果</span></span><br><span class="line">	result := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	<span class="comment">// 4. 将结果转换为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>创建一个新的使用MD5校验的hash.Hash接口 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span></span><br></pre></td></tr></table></figure>

<p>Hash是一个被所有hash函数实现的公共接口。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误</span></span><br><span class="line">    io.Writer</span><br><span class="line">    <span class="comment">// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 重设hash为无数据输入的状态</span></span><br><span class="line">    Reset()</span><br><span class="line">    <span class="comment">// 返回Sum会返回的切片的长度</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回hash底层的块大小；Write方法可以接受任何大小的数据，</span></span><br><span class="line">    <span class="comment">// 但提供的数据是块大小的倍数时效率更高</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;io&quot;</span> 包中 Writer 接口用于包装基本的写入方法。</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过io操作将数据写入hash对象中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 第一种方式</span><br><span class="line">函数所属的包: <span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    - 参数 w: 实现了/包含Writer接口的对象</span><br><span class="line">    - 参数 s: 要添加到IO对象中的数据</span><br><span class="line">    - 返回值 n: 数据长度</span><br><span class="line">    - 返回值 err: 错误信息</span><br><span class="line"># 第二种方式</span><br><span class="line">使用md5包中的New()方法得到的hash.Hash接口(假设名为: myHash)添加数据</span><br><span class="line">myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;测试数据&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>使用hash.Hash接口中的Sum方法计算结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sum(b []byte) []byte</span><br><span class="line">    - 参数 b: 将b中的数据进行哈希计算, 结果添加到原始数据的前面, </span><br><span class="line">      		 一般情况下该参数指定为空, 即: nil</span><br><span class="line">    - 返回值: 进行哈希运算之后得到的结果 </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"><a href="#SHA-1、SHA-224、SHA-256、SHA-384、SHA-512" class="headerlink" title="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"></a>SHA-1、SHA-224、SHA-256、SHA-384、SHA-512</h2><blockquote>
<p>SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。</p>
<p>SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没有问题。</p>
<p>SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">比特数</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td>MD4</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>MD5</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>SHA-1</td>
<td align="center">160bit</td>
<td align="center">20byte</td>
</tr>
<tr>
<td>SHA-224</td>
<td align="center">224bit</td>
<td align="center">28byte</td>
</tr>
<tr>
<td>SHA-256</td>
<td align="center">256bit</td>
<td align="center">32byte</td>
</tr>
<tr>
<td>SHA-384</td>
<td align="center">384bit</td>
<td align="center">48byte</td>
</tr>
<tr>
<td>SHA-512</td>
<td align="center">512bit</td>
<td align="center">64byte</td>
</tr>
</tbody></table>
<h3 id="Go中对SHA-1、SHA-2的使用"><a href="#Go中对SHA-1、SHA-2的使用" class="headerlink" title="Go中对SHA-1、SHA-2的使用"></a>Go中对SHA-1、SHA-2的使用</h3><ul>
<li>需要导入的包</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用sha1计算文件指纹</li>
</ul>
<blockquote>
<p>上一小节介绍了如何使用go提供的API计算数据的md5指纹, sha1的计算方式和md5的套路是一样的, 需要将md5包, 替换为sh1, 下面给大家介绍一下如何使用sha1计算文件的指纹(md5亦如此) </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSha1</span><span class="params">(src <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	fp, err := os.Open(src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;文件打开失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建基于sha1算法的Hash对象</span></span><br><span class="line">	myHash := sha1.New()</span><br><span class="line">	<span class="comment">// 3. 将文件数据拷贝给哈希对象</span></span><br><span class="line">	num, err := io.Copy(myHash, fp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;拷贝文件失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件大小: &quot;</span>, num)</span><br><span class="line">	<span class="comment">// 4. 计算文件的哈希值</span></span><br><span class="line">	tmp1 := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 5. 数据格式转换</span></span><br><span class="line">    result := hex.EncodeToString(tmp1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sha1: &quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中map的基本使用和底层理解</title>
    <url>/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/</url>
    <content><![CDATA[<h1 id="map的基本使用"><a href="#map的基本使用" class="headerlink" title="map的基本使用"></a>map的基本使用</h1><h2 id="key与value的限制"><a href="#key与value的限制" class="headerlink" title="key与value的限制"></a>key与value的限制</h2><p>key一定要是<strong>可比较</strong>的类型（可以理解为支持==的操作）：</p>
<table>
<thead>
<tr>
<th align="center">可比教类型</th>
<th align="center">不可比较类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">slice</td>
</tr>
<tr>
<td align="center">numeric</td>
<td align="center">map</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">func</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">array和struct</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果是非法的key类型，会报错：invalid map key type xxx</p>
<blockquote>
<p>golang为uint32、uint64、string提供了fast access，使用这些类型作为key可以提高map访问速度。[runtime/hashmap_fast.go]</p>
</blockquote>
<p>value可以是<strong>任意类型</strong>。</p>
<h2 id="新增-amp-删除-amp-更新-amp-查询"><a href="#新增-amp-删除-amp-更新-amp-查询" class="headerlink" title="新增 &amp; 删除 &amp; 更新 &amp; 查询"></a>新增 &amp; 删除 &amp; 更新 &amp; 查询</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，key不存在则啥也不干</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询，key不存在返回value类型的零值</span></span><br><span class="line">i := m[<span class="string">&quot;name&quot;</span>] <span class="comment">// 三种查询方式，</span></span><br><span class="line">i, ok := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">_, ok := m[<span class="string">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>需要强调的是map本身是<strong>无序的</strong>，在遍历的时候并不会按照你传入的顺序，进行传出</p>
<p>正常遍历:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; </span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有序遍历:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 把key单独抽取出来，放在数组中</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行数组的排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">// 遍历数组就是有序的了</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">    fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>Golang中是没有引用传递的，均为值传递。这意味着传递的是数据的拷贝。<br>那么map本身是<strong>引用类型</strong>，作为形参或返回参数的时候，传递的是<strong>值的拷贝，而值是地址</strong>，<strong>扩容</strong>时也<strong>不会改变</strong>这个地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeM</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 函数开始时地址是： %p\n&quot;</span>, m)</span><br><span class="line">	<span class="keyword">var</span> max = <span class="number">5</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;max; i++&#123;</span><br><span class="line">		m[<span class="keyword">int64</span>(i)] = <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 在函数返回前地址是：%p\n&quot;</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>, <span class="number">1</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 的原始地址：%p\n&quot;</span>, m)</span><br><span class="line">	changeM(m)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 改变后地址：%p\n&quot;</span>, m)</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 长度是：&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 参数是：&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m 的原始地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 函数开始时地址是： <span class="number">0xc00006a360</span></span><br><span class="line">m 在函数返回前地址是：<span class="number">0xc00006a360</span></span><br><span class="line">m 改变后地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 长度是： <span class="number">5</span></span><br><span class="line">m 参数是： <span class="keyword">map</span>[<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2</span> <span class="number">3</span>:<span class="number">2</span> <span class="number">4</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="map的深入理解"><a href="#map的深入理解" class="headerlink" title="map的深入理解"></a>map的深入理解</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p>
<p>map数据结构由<code>runtime/map.go:hmap</code>定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示一个拥有4个bucket的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt="img " style="zoom:80%;">

<p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p>
<p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket</p>
<h2 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h2><p>bucket数据结构由<code>runtime/map.go:bmap</code>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个bucket可以存储8个键值对。</p>
<ul>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li>
<li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li>
</ul>
<p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p>
<p>下图展示bucket存放8个key-value对：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_7f0ba5a124641b1413279892581513c4_r.png" alt="img" style="zoom:80%;">

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p>
<p>下图展示产生冲突后的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_a8b9e5919d9951a71c1c36445dd68521_r.png" alt="img" style="zoom:80%;">

<p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍</p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">负载因子 = 键数量/bucket数量</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p>
<p>哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：</p>
<ul>
<li>哈希因子过小，说明空间利用率低</li>
<li>哈希因子过大，说明冲突严重，存取效率低</li>
</ul>
<p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p>
<h2 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h2><h3 id="扩容的前提条件"><a href="#扩容的前提条件" class="headerlink" title="扩容的前提条件"></a>扩容的前提条件</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p>
<ol>
<li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li>
</ol>
<h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png" alt="img" style="zoom:100%;">

<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p>
<p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2f0122f26e5d66ca91e6820ace6b379b_r.png" alt="img" style="zoom:100%;">

<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p>
<p>搬迁完成后的示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png" alt="img" style="zoom:80%;">

<p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。</p>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，而是把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_f3a5989c90204df9304d5ae246f3db72_r.png" alt="img" style="zoom:80%;">

<p>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p>
<h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>取哈希值高位在tophash数组中查询</li>
<li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li>
<li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li>
<li>如果当前处于搬迁过程，则优先从oldbuckets查找</li>
</ol>
<p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p>
<h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>查找该key是否已经存在，如果存在则直接更新值</li>
<li>如果没找到将key，将key插入</li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言sync.Map</title>
    <url>/2021/08/18/Go%E8%AF%AD%E8%A8%80sync-Map/</url>
    <content><![CDATA[<p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p>
<p>样例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">	fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现有这样的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent map <span class="built_in">read</span> and map write</span><br></pre></td></tr></table></figure>

<p>根本原因就是：并发的去读写map结构的数据了。</p>
<p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p>
<p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<p>sync.Map 有以下特性：</p>
<ul>
<li>无须初始化，直接声明即可。</li>
<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
<li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li>
</ul>
<p>并发安全的 sync.Map 演示代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> scene sync.Map</span><br><span class="line">	<span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">	scene.Store(<span class="string">&quot;greece&quot;</span>, <span class="number">97</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;london&quot;</span>, <span class="number">100</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;egypt&quot;</span>, <span class="number">200</span>)</span><br><span class="line">	<span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">	fmt.Println(scene.Load(<span class="string">&quot;london&quot;</span>))</span><br><span class="line">	<span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">	scene.Delete(<span class="string">&quot;london&quot;</span>)</span><br><span class="line">	<span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">	scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line">		<span class="comment">//return false   返回false立即停止遍历</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>消息认证码</title>
    <url>/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h1><h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><blockquote>
<p><strong>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称为MAC。</strong></p>
</blockquote>
<p><img src="/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/1539176665517.png" alt="1539176665517"></p>
<ul>
<li><p>思考改进方案?</p>
<p>从哈希函数入手</p>
<p>需要将要发送的数据进行哈希运算, 将哈希值和原始数据一并发送</p>
<p>需要在进行哈希运算的时候引入加密的步骤</p>
<ul>
<li>在alice对数据进行哈希运算的时候引入一个秘钥, 让其参与哈希运算, 生成散列值</li>
<li>bob对数据校验<ul>
<li>bob收到原始和散列值之后, <ul>
<li>处理原始数据: 通过秘钥和哈希算法对原始数据生成散列值</li>
<li>散列值比较: 生成的散列值 和  接收到的散列值进行比对</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="消息认证码的使用步骤"><a href="#消息认证码的使用步骤" class="headerlink" title="消息认证码的使用步骤"></a>消息认证码的使用步骤</h2><p><img src="/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/1539177690828.png" alt="1539177690828"></p>
<blockquote>
<p>前提条件:</p>
<ul>
<li>在消息认证码生成的一方和校验的一方, 必须有一个秘钥</li>
<li>双方约定好使用同样的哈希函数对数据进行运算</li>
</ul>
<p>流程:</p>
<p>发送者: </p>
<ul>
<li>发送原始法消息</li>
<li>将原始消息生成消息认证码<ul>
<li>((原始消息) + 秘钥)  *   函数函数 = 散列值(消息认证码)</li>
</ul>
</li>
<li>将消息认证码发送给对方</li>
</ul>
<p>接收者:</p>
<ul>
<li>接收原始数据</li>
<li>接收消息认证码</li>
<li>校验: <ul>
<li>( 接收的消息  +  秘钥 ) * 哈希函数   = 新的散列值</li>
<li>通过新的散列值和接收的散列值进行比较</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="go中对消息认证码的使用"><a href="#go中对消息认证码的使用" class="headerlink" title="go中对消息认证码的使用"></a>go中对消息认证码的使用</h2><blockquote>
<p>有一个包: crypto/hmac</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(h <span class="keyword">func</span>()</span> <span class="title">hash</span>.<span class="title">Hash</span>, <span class="title">key</span> []<span class="title">byte</span>) <span class="title">hash</span>.<span class="title">Hash</span></span></span><br><span class="line">- 返回值: hash接口</span><br><span class="line">- 参数<span class="number">1</span>: 哈希函数的函数名</span><br><span class="line">	sha1.<span class="built_in">new</span></span><br><span class="line">	md5.<span class="built_in">new</span></span><br><span class="line">	sha256.<span class="built_in">new</span></span><br><span class="line">- 参数<span class="number">2</span>: 秘钥</span><br><span class="line"></span><br><span class="line">第二步: 添加数据</span><br><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误</span></span><br><span class="line">    io.Writer</span><br><span class="line">    <span class="comment">// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 重设hash为无数据输入的状态</span></span><br><span class="line">    Reset()</span><br><span class="line">    <span class="comment">// 返回Sum会返回的切片的长度</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回hash底层的块大小；Write方法可以接受任何大小的数据，</span></span><br><span class="line">    <span class="comment">// 但提供的数据是块大小的倍数时效率更高</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">第三步: 计算散列值</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/hmac&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。&quot;</span> +</span><br><span class="line">		<span class="string">&quot;如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，&quot;</span> +</span><br><span class="line">		<span class="string">&quot;这样一来消息认证码就无法发挥作用了。&quot;</span>)</span><br><span class="line">	key := []<span class="keyword">byte</span>(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">	hamc1 := GenerateHamc(src, key)</span><br><span class="line">	bl := VerifyHamc(src, key, hamc1)</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;校验结果: %t\n&quot;, bl)</span></span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成消息认证码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHamc</span><span class="params">(plainText, key []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建哈希接口, 需要指定使用的哈希算法, 和秘钥</span></span><br><span class="line">	myhash := hmac.New(sha1.New, key)</span><br><span class="line">	<span class="comment">// 2. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">// 3. 计算散列值</span></span><br><span class="line">	hashText := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hashText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证消息认证码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyHamc</span><span class="params">(plainText, key, hashText []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建哈希接口, 需要指定使用的哈希算法, 和秘钥</span></span><br><span class="line">	myhash := hmac.New(sha1.New, key)</span><br><span class="line">	<span class="comment">// 2. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">// 3. 计算散列值</span></span><br><span class="line">	hamc1 := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 4. 两个散列值比较</span></span><br><span class="line">	<span class="keyword">return</span> hmac.Equal(hashText, hamc1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="消息认证码的问题"><a href="#消息认证码的问题" class="headerlink" title="消息认证码的问题"></a>消息认证码的问题</h2><ol>
<li>弊端<ul>
<li>有秘钥分发困难的问题</li>
</ul>
</li>
<li>无法解决的问题<ul>
<li>不能进行第三方证明</li>
<li>不能防止否认</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名</title>
    <url>/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><h2 id="签名的生成和验证"><a href="#签名的生成和验证" class="headerlink" title="签名的生成和验证"></a>签名的生成和验证</h2><blockquote>
<ol>
<li><p>签名</p>
<ul>
<li>有原始数据对其进行哈希运算   -&gt;   散列值</li>
<li>使用非对称加密的<font color="red">私钥</font>对散列值加密 -&gt; 签名</li>
<li>将原始数据和签名一并发送给对方</li>
</ul>
</li>
<li><p>验证</p>
<ul>
<li><p>接收数据 </p>
<ul>
<li>原始数据</li>
<li>数字签名</li>
</ul>
</li>
<li><p>数字签名, 需要使用<font color="red">公钥</font>解密, 得到散列值</p>
</li>
<li><p>对原始数据进行哈希运算得到新的散列值</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>小结：</p>
<blockquote>
<ol>
<li>数据通信<ul>
<li>公钥加密, 私钥解密</li>
</ul>
</li>
<li>数字签名:<ul>
<li>私钥加密, 公钥解密</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="数字签名的方法"><a href="#数字签名的方法" class="headerlink" title="数字签名的方法"></a>数字签名的方法</h2><p><img src="/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1539177860475.png" alt="1539177860475"></p>
<h2 id="使用RSA进行数字签名"><a href="#使用RSA进行数字签名" class="headerlink" title="使用RSA进行数字签名"></a>使用RSA进行数字签名</h2><ol>
<li>使用rsa生成密钥对</li>
</ol>
<blockquote>
<ol>
<li>生成密钥对</li>
<li>序列化</li>
<li>保存到磁盘文件</li>
</ol>
</blockquote>
<ol start="2">
<li>使用私钥进行数字签名</li>
</ol>
<blockquote>
<ol>
<li>打开磁盘的私钥文件</li>
<li>将私钥文件中的内容读出</li>
<li>使用pem对数据解码, 得到了pem.Block结构体变量</li>
<li>x509将数据解析成私钥结构体 -&gt; 得到了私钥</li>
<li>创建一个哈希对象 -&gt; md5/sha1</li>
<li>给哈希对象添加数据</li>
<li>计算哈希值</li>
<li>使用rsa中的函数对散列值签名</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>)</span> <span class="params">(s []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">参数<span class="number">1</span>: rand.Reader</span><br><span class="line">参数<span class="number">2</span>: 非对称加密的私钥</span><br><span class="line">参数<span class="number">3</span>: 使用的哈希算法</span><br><span class="line">	crypto.sha1</span><br><span class="line">	crypto.md5</span><br><span class="line">参数<span class="number">4</span>: 数据计算之后得到的散列值</span><br><span class="line">返回值: </span><br><span class="line">- s: 得到的签名数据</span><br><span class="line">- err: 错误信息</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>使用公钥进行签名认证</li>
</ol>
<blockquote>
<ol>
<li><p>打开公钥文件, 将文件内容读出 - []byte</p>
</li>
<li><p>使用pem解码 -&gt; 得到pem.Block结构体变量</p>
</li>
<li><p>使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口</p>
</li>
<li><p>进行类型断言 -&gt; 得到了公钥结构体</p>
</li>
<li><p>对原始消息进行哈希运算(和签名使用的哈希算法一致) -&gt; 散列值</p>
<ol>
<li>创建哈希接口</li>
<li>添加数据</li>
<li>哈希运算</li>
</ol>
</li>
<li><p>签名认证 - rsa中的函数</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyPKCS1v15</span><span class="params">(pub *PublicKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span></span><br><span class="line">参数<span class="number">1</span>: 公钥</span><br><span class="line">参数<span class="number">2</span>: 哈希算法 -&gt; 与签名使用的哈希算法一致</span><br><span class="line">参数<span class="number">3</span>: 将原始数据进行哈希原始得到的散列值</span><br><span class="line">参数<span class="number">4</span>: 签名的字符串</span><br><span class="line">返回值: </span><br><span class="line">	- <span class="literal">nil</span> -&gt; 验证成功</span><br><span class="line">	- !=<span class="literal">nil</span> -&gt; 失败</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，这样一来消息认证码就无法发挥作用了。&quot;</span>)</span><br><span class="line">	sigText := SignatureRSA(src, <span class="string">&quot;private.pem&quot;</span>)</span><br><span class="line">	bl := VerifyRSA(src, sigText, <span class="string">&quot;public.pem&quot;</span>)</span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA签名 - 私钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignatureRSA</span><span class="params">(plainText []<span class="keyword">byte</span>, fileName <span class="keyword">string</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 打开磁盘的私钥文件</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 将私钥文件中的内容读出</span></span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//3. 使用pem对数据解码, 得到了pem.Block结构体变量</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//4. x509将数据解析成私钥结构体 -&gt; 得到了私钥</span></span><br><span class="line">	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5. 创建一个哈希对象 -&gt; md5/sha1 -&gt; sha512</span></span><br><span class="line">	<span class="comment">// sha512.Sum512()</span></span><br><span class="line">	myhash := sha512.New()</span><br><span class="line">	<span class="comment">//6. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">//7. 计算哈希值</span></span><br><span class="line">	hashText := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">//8. 使用rsa中的函数对散列值签名</span></span><br><span class="line">	sigText, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA512, hashText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sigText</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RSA签名验证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyRSA</span><span class="params">(plainText, sigText []<span class="keyword">byte</span>, pubFileName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 打开公钥文件, 将文件内容读出 - []byte</span></span><br><span class="line">	file, err := os.Open(pubFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. 使用pem解码 -&gt; 得到pem.Block结构体变量</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 进行类型断言 -&gt; 得到了公钥结构体</span></span><br><span class="line">	publicKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line">	<span class="comment">//5. 对原始消息进行哈希运算(和签名使用的哈希算法一致) -&gt; 散列值</span></span><br><span class="line">	hashText := sha512.Sum512(plainText)</span><br><span class="line">	<span class="comment">//6. 签名认证 - rsa中的函数</span></span><br><span class="line">	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA512, hashText[:], sigText)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用椭圆曲线进行数字签名"><a href="#使用椭圆曲线进行数字签名" class="headerlink" title="使用椭圆曲线进行数字签名"></a>使用椭圆曲线进行数字签名</h2><blockquote>
<p>椭圆曲线在go中对应的包: import “crypto/elliptic”</p>
<p>使用椭圆曲线在go中进行数字签名: import “crypto/ecdsa”</p>
<p>美国FIPS186-2标准, 推荐使用5个素域上的椭圆曲线, 这5个素数模分别是:</p>
<p>P<del>192</del> = 2^192^ - 2^64^ - 1</p>
<p>P<del>224</del> = 2^224^ - 2^96^ + 1</p>
<p>P<del>256</del> = 2^256^ - 2^224^  + 2^192^ - 2^96^ -1</p>
<p>P<del>384</del> = 2^384^ - 2^128^  - 2^96^ + 2^32^ -1</p>
<p>P<del>512</del> = 2^512^ - 1</p>
</blockquote>
<ol>
<li>秘钥对称的生成, 并保存到磁盘</li>
</ol>
<blockquote>
<ol>
<li><p>使用ecdsa生成密钥对</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(c elliptic.Curve, rand io.Reader)</span> <span class="params">(priv *PrivateKey, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>将私钥写入磁盘</p>
<ul>
<li>使用x509进行序列化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalECPrivateKey</span><span class="params">(key *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将得到的切片字符串放入pem.Block结构体中</p>
<p>block := pem.Block{</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type : <span class="string">&quot;描述....&quot;</span>,</span><br><span class="line"></span><br><span class="line">Bytes : MarshalECPrivateKey返回值中的切片字符串,</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
<li><p>使用pem编码</p>
<p>​    pem.Encode();</p>
</li>
</ul>
</li>
<li><p>将公钥写入磁盘</p>
<ul>
<li>从私钥中得到公钥</li>
<li>使用x509进行序列化</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKIXPublicKey</span><span class="params">(pub <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将得到的切片字符串放入pem.Block结构体中</li>
</ul>
<p>block := pem.Block{</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type : <span class="string">&quot;描述....&quot;</span>,</span><br><span class="line"></span><br><span class="line">Bytes : MarshalECPrivateKey返回值中的切片字符串,</span><br></pre></td></tr></table></figure>

<p>}</p>
<ul>
<li><p>使用pem编码</p>
<p>pem.Encode();</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<ol start="2">
<li>使用私钥进行数字签名</li>
</ol>
<blockquote>
<ol>
<li><p>打开私钥文件, 将内容读出来 -&gt;[]byte</p>
</li>
<li><p>使用pem进行数据解码 -&gt; pem.Decode()</p>
</li>
<li><p>使用x509, 对私钥进行还原</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseECPrivateKey</span><span class="params">(der []<span class="keyword">byte</span>)</span> <span class="params">(key *ecdsa.PrivateKey, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>对原始数据进行哈希运算 -&gt; 散列值</p>
</li>
<li><p>进行数字签名</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(rand io.Reader, priv *PrivateKey, hash []<span class="keyword">byte</span>)</span> <span class="params">(r, s *big.Int, err error)</span></span></span><br><span class="line">- 得到的r和s不能直接使用, 因为这是指针</span><br><span class="line">	应该将这两块内存中的数据进行序列化 -&gt; []<span class="keyword">byte</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">(text []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li><p>使用公钥验证数字签名</p>
<blockquote>
<ol>
<li><p>打开公钥文件, 将里边的内容读出 -&gt; []byte</p>
</li>
<li><p>pem解码 -&gt; pem.Decode()</p>
</li>
<li><p>使用x509对公钥还原</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKIXPublicKey</span><span class="params">(derBytes []<span class="keyword">byte</span>)</span> <span class="params">(pub <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>将接口 -&gt; 公钥</p>
</li>
<li><p>对原始数据进行哈希运算 -&gt; 得到散列值</p>
</li>
<li><p>签名的认证 - &gt; ecdsa</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verify</span><span class="params">(pub *PublicKey, hash []<span class="keyword">byte</span>, r, s *big.Int)</span> <span class="title">bool</span></span></span><br><span class="line">- 参数<span class="number">1</span>: 公钥</span><br><span class="line">- 参数<span class="number">2</span>: 原始数据生成的散列值</span><br><span class="line">- 参数<span class="number">3</span>,<span class="number">4</span>: 通过签名得到的连个点</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">UnmarshalText</span><span class="params">(text []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="数字签名无法解决的问题"><a href="#数字签名无法解决的问题" class="headerlink" title="数字签名无法解决的问题"></a>数字签名无法解决的问题</h2><p><img src="/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1539178819165.png" alt="1539178819165"></p>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	GenerateEccKey()</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口&quot;</span>)</span><br><span class="line">	rText, sText := EccSignature(src, <span class="string">&quot;eccPrivate.pem&quot;</span>)</span><br><span class="line">	bl := EccVerify(src, rText, sText, <span class="string">&quot;eccPublic.pem&quot;</span>)</span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 生成密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateEccKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 使用ecdsa生成密钥对</span></span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 将私钥写入磁盘</span></span><br><span class="line">	<span class="comment">//- 使用x509进行序列化</span></span><br><span class="line">	derText, err := x509.MarshalECPrivateKey(privateKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 将得到的切片字符串放入pem.Block结构体中</span></span><br><span class="line">	block := pem.Block&#123;</span><br><span class="line">		Type : <span class="string">&quot;ecdsa private key&quot;</span>,</span><br><span class="line">		Bytes : derText,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 使用pem编码</span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;eccPrivate.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pem.Encode(file, &amp;block)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//3. 将公钥写入磁盘</span></span><br><span class="line">	<span class="comment">//- 从私钥中得到公钥</span></span><br><span class="line">	publicKey := privateKey.PublicKey</span><br><span class="line">	<span class="comment">//- 使用x509进行序列化</span></span><br><span class="line">	derText, err = x509.MarshalPKIXPublicKey(&amp;publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 将得到的切片字符串放入pem.Block结构体中</span></span><br><span class="line">	block = pem.Block&#123;</span><br><span class="line">		Type : <span class="string">&quot;ecdsa public key&quot;</span>,</span><br><span class="line">		Bytes : derText,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 使用pem编码</span></span><br><span class="line">	file, err = os.Create(<span class="string">&quot;eccPublic.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pem.Encode(file, &amp;block)</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ecc签名 - 私钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EccSignature</span><span class="params">(plainText []<span class="keyword">byte</span>, privName <span class="keyword">string</span>)</span>  <span class="params">(rText, sText []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 打开私钥文件, 将内容读出来 -&gt;[]byte</span></span><br><span class="line">	file, err := os.Open(privName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. 使用pem进行数据解码 -&gt; pem.Decode()</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509, 对私钥进行还原</span></span><br><span class="line">	privateKey, err := x509.ParseECPrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 对原始数据进行哈希运算 -&gt; 散列值</span></span><br><span class="line">	hashText := sha1.Sum(plainText)</span><br><span class="line">	<span class="comment">//5. 进行数字签名</span></span><br><span class="line">	r, s, err := ecdsa.Sign(rand.Reader, privateKey, hashText[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 对r, s内存中的数据进行格式化 -&gt; []byte</span></span><br><span class="line">	rText, err = r.MarshalText()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	sText, err = s.MarshalText()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ecc签名认证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EccVerify</span><span class="params">(plainText, rText, sText []<span class="keyword">byte</span>, pubFile <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 打开公钥文件, 将里边的内容读出 -&gt; []byte</span></span><br><span class="line">	file, err := os.Open(pubFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. pem解码 -&gt; pem.Decode()</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509对公钥还原</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 将接口 -&gt; 公钥</span></span><br><span class="line">	publicKey := pubInterface.(*ecdsa.PublicKey)</span><br><span class="line">	<span class="comment">//5. 对原始数据进行哈希运算 -&gt; 得到散列值</span></span><br><span class="line">	hashText := sha1.Sum(plainText)</span><br><span class="line">	<span class="comment">// 将rText, sText -&gt; int数据</span></span><br><span class="line">	<span class="keyword">var</span> r, s big.Int</span><br><span class="line">	r.UnmarshalText(rText)</span><br><span class="line">	s.UnmarshalText(sText)</span><br><span class="line">	<span class="comment">//6. 签名的认证 - &gt; ecdsa  (问题,api的设计为什么在这个地方要传地址,直接传值比较不是更好吗?)</span></span><br><span class="line">	bl := ecdsa.Verify(publicKey, hashText[:], &amp;r, &amp;s)</span><br><span class="line">	<span class="keyword">return</span> bl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS and HTTPS</title>
    <url>/2021/08/24/SSL-TLS/</url>
    <content><![CDATA[<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p><img src="/2021/08/24/SSL-TLS/1539271432019.png" alt="1539271432019"></p>
<blockquote>
<ul>
<li><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。<br>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li>
<li><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 <a href="http://tools.ietf.org/html/rfc5246">RFC</a> 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li>
</ul>
<p>SSL/TLS协议提供的服务主要有：</p>
<ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ol>
</blockquote>
<p><img src="/2021/08/24/SSL-TLS/image-20210824173412361.png" alt="image-20210824173412361"></p>
<blockquote>
<p>客户端与服务端需要经过一个握手的过程才能完成身份认证，建立一个安全的连接。握手的过程如下：</p>
<ol>
<li><p>客户端访问服务器（比如：<a href="https://www.12306.cn/">https://www.12306.cn</a>）,发送ssl版本、客户端支持的加密算法等消息。</p>
</li>
<li><p>服务器向客户端发送ssl版本、加密算法、证书（证书出现了）等消息。</p>
</li>
<li><p>客户端收到消息后，判断证书是否可信, 若可信，则继续通信，发送消息：</p>
<p><font color="red">客户端生成一个随机数，从证书中获取服务器端的公钥，对随机数加密；</font></p>
<p>随后信息都将使用双方协定的加密方法和密钥发送, 客户端握手结束。</p>
</li>
<li><p>服务器端对数据解密得到随机数, 使用协商好的加密算法和秘钥进行通信</p>
</li>
</ol>
</blockquote>
<p>描述的是客户端和服务器刚建立连接之后做的事情:</p>
<blockquote>
<p>第一次</p>
<ul>
<li>客户端连接服务器<ul>
<li>客户端使用的ssl版本, 客户端支持的加密算法</li>
</ul>
</li>
<li>服务器<ul>
<li>先将自己支持ssl版本和客户端的支持的版本比较<ul>
<li>支持的不一样, 连接断开</li>
<li>支持的一样, 继续</li>
</ul>
</li>
<li>根据得到的客户端支持 的加密算法, 找一个服务器端也同样支持算法, 发送给客户端</li>
<li>需要发送服务器的证书给客户端</li>
</ul>
</li>
</ul>
<p>第二次:</p>
<p>客户端:</p>
<ul>
<li>接收服务器的证书</li>
<li>校验证书的信息<ul>
<li>校验证书的签发机构</li>
<li>证书的有效期</li>
<li>证书中支持 的域名和访问的域名是否一致</li>
</ul>
</li>
<li>校验有问题, 浏览器会给提示</li>
</ul>
</blockquote>
<h2 id="https-gt-单向认证"><a href="#https-gt-单向认证" class="headerlink" title="https -&gt; 单向认证"></a>https -&gt; 单向认证</h2><p><img src="/SSL-TLS/https1.png" alt="https1"></p>
<ol>
<li>服务器要准备的<ul>
<li>生成密钥对</li>
<li>将公钥发送给ca, 由ca签发证书</li>
<li>将ca签发的证书和非对称加密的私钥部署到当前的web服务器</li>
</ul>
</li>
<li>通信流程<ol>
<li>客户端连接服务器, 通过一个域名<ul>
<li>域名和IP地址的关系<ul>
<li>域名要绑定IP地址<ul>
<li>一个域名只能绑定一个IP地址</li>
</ul>
</li>
<li>IP地址需要被域名绑定<ul>
<li>一个IP地址可以被多个域名绑定</li>
</ul>
</li>
</ul>
</li>
<li>客户端访问的域名会解析成IP地址, 通过IP地址访问web服务器</li>
</ul>
</li>
<li>服务器收到了客户端的请求<ul>
<li>服务器将CA签发的证书发送给浏览器(客户端)</li>
</ul>
</li>
<li>客户端拿到了服务器的公钥证书<ul>
<li>读这个公钥 证书<ul>
<li>验证域名</li>
<li>有效期</li>
<li>ca签发机构</li>
<li>服务器的公钥</li>
</ul>
</li>
</ul>
</li>
<li>客户会生成一个随机数 (作为对称加密的秘钥来使用的)<ul>
<li>使用服务器的公钥对这个随机数进行加密</li>
<li>将这个加密之后 秘钥发送给服务器</li>
</ul>
</li>
<li>服务器对收到的密文解密<ul>
<li>使用服务器的是要解密, 得到对称加密的秘钥</li>
</ul>
</li>
<li>数据的传输<ul>
<li>使用对称加密的方式对数据进行加密</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>证书</title>
    <url>/2021/08/24/%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><blockquote>
<p>公钥证书（Public-Key Certificate，PKC)其实和驾照很相似，里面记有姓名、组织、邮箱地址等<font color="red">个人信息</font>，以及属于<font color="red">此人的公钥, 并由认证机构（Certification Authority、Certifying Authority, CA）施加数字签名</font>。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate）。</p>
</blockquote>
<h2 id="证书的应用场景"><a href="#证书的应用场景" class="headerlink" title="证书的应用场景"></a>证书的应用场景</h2><img src="/2021/08/24/%E8%AF%81%E4%B9%A6/1539265302304.png" alt="1539265302304" style="zoom:130%;">

<blockquote>
<ol>
<li><p><font color="red" size="4">Bob生成密钥对</font></p>
<ul>
<li><p>可以将bob看成百度, 提供是web服务器</p>
</li>
<li><p>生成一个密钥对</p>
<ul>
<li>公钥  -&gt; 分发</li>
<li>私钥 -&gt; 百度留着</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Bob在认证机构Trent注册自己的公钥</font></p>
<ul>
<li>百度找了一大家都信赖的机构, 来证明这个公钥是百度的</li>
<li>认证机构会生成一个证书, 写明了公钥属于百度<ul>
<li>认证机构也有一个非对称加密的密钥对</li>
<li>认证机构使用自己的私钥对百度的公钥进行签名, 生成了证书</li>
<li>认证机构将证书发送给百度</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书</font></p>
</li>
<li><p><font color="red" size="4">Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书）</font></p>
<ul>
<li>alice可以看做一个客户 -&gt; 浏览器</li>
<li>客户端访问的百度 -&gt; 得到了百度的证书<ul>
<li>证书中有百度的公钥</li>
</ul>
</li>
<li>客户端需要使用认证机构的公钥对证书进行验证<ul>
<li>客户端怎么会有认证机构的公钥<ul>
<li>window会预装, 或者用户自己安装</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性</font></p>
<ul>
<li>使用认证机构的公钥解除百度证书中签名的数据<ul>
<li>百度的公钥</li>
<li>百度的域名</li>
<li>百度证书的有效期</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Alice用Bob的公钥加密消息并发送给Bob</font></p>
<ul>
<li>非对称加密</li>
<li>使用公钥加密 -&gt; 对称加密秘钥分发</li>
</ul>
</li>
<li><p><font color="red" size="4">Bob用自己的私钥解密密文得到Alice的消息</font></p>
<ul>
<li>服务器使用私钥解密 -&gt; 得到对称加密的秘钥</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="证书规范和格式-–-x509-了解"><a href="#证书规范和格式-–-x509-了解" class="headerlink" title="证书规范和格式 – x509(了解)"></a>证书规范和格式 – x509(了解)</h2><blockquote>
<p><strong>X.509</strong>是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数据结构，并使用ASN.1语法进行编码。 </p>
<p>X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。</p>
<ul>
<li>证书文件的文件名后缀一般为 .crt 或 .cer </li>
<li>对应私钥文件的文件名后缀一般为 .key</li>
<li>证书请求文件的文件名后綴为 .csr </li>
<li>有时候也统一用pem作为文件名后缀。</li>
</ul>
</blockquote>
<h2 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h2><blockquote>
<p>CA证书顾名思义就是由CA（Certification Authority）机构发布的数字证书。要对CA证书完全理解及其作用，首先要理解SSL。SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议。<strong>SSL3.0版本以后又被称为TLS。SSL位于TCP与各应用层之间，是操作系统向外提供的API。</strong>SSL如何保证网络通信的安全和数据的完整性呢？就是采用了两种手段：身份认证和数据加密。首先身份认证就需要用到CA证书了。</p>
</blockquote>
<ol>
<li><p>证书的获取和身份的认证（重点）</p>
<blockquote>
<p>客户端与服务端需要经过一个握手的过程才能完成身份认证，建立一个安全的连接。握手的过程如下：</p>
<ol>
<li><p>客户端访问服务器（比如：<a href="https://www.12306.cn/">https://www.12306.cn</a>）,发送ssl版本、客户端支持的加密算法等消息。</p>
</li>
<li><p>服务器向客户端发送ssl版本、加密算法、证书（证书出现了）等消息。</p>
</li>
<li><p>客户端收到消息后，判断证书是否可信, 若可信，则继续通信，发送消息：</p>
<p><font color="red">客户端生成一个随机数，从证书中获取服务器端的公钥，对随机数加密；</font></p>
<p>随后信息都将使用双方协定的加密方法和密钥发送, 客户端握手结束。</p>
</li>
<li><p>服务器端对数据解密得到随机数, 使用协商好的加密算法和秘钥进行通信</p>
</li>
</ol>
</blockquote>
</li>
<li><p>客户端如何验证CA证书是可信任的?（了解）</p>
<blockquote>
<ol>
<li><p>查看证书的方式:</p>
<p>Internet选项 -&gt; 内容 -&gt; 证书, 打开证书窗口查看已经安装的证书</p>
<p>只要电脑上安装了该证书, 就说明该证书是受信任的。使用https协议访问时，服务器发送证书向浏览器时，首先查找该证书是否已在信任列表中，然后对证书进行校验，校验成功，那么就证明证书是可信的。</p>
<p>下图中<code>受信任的根证书颁发机构</code>下的证书都是根证书。</p>
<p>证书验证的机制是只要根证书是受信任的，那么它的子证书都是可信的。比如说，我们使用https协议访问了需要百度证书的网站，即使我们不安装百度证书，那么网站也不会提示证书不安全，因为，生成百度证书的根证书<code>Globalsign Root CA - R1</code>证书，在受信任的证书列表中。如果一个证书的根证书是不可信的，那么这个证书肯定也是不可信任的。</p>
<p>由以上可知，根证书在证书验证中极其重要，而且，根证书是无条件信任的，只要我们将根证书安装上，就说明我们对根证书是信任的。比如我们安装12306的根证书，是出于我们对国家的信任，对网站的信任，我们才放心安装这个根证书。对于一些不安全的网站的证书，一定要慎重安装。</p>
<p>另外需要知道的是，【<code>受信任的根证书颁发机构</code>】中的证书是windows预先安装的一些证书，都是国际上很有权威的证书机构，他们证书的生成都有很严格的流程，因此他们的证书被认为是安全，就像我们相信银行是安全，所以把钱存入到银行</p>
<p><img src="/2021/08/24/%E8%AF%81%E4%B9%A6/1539272408707.png" alt="1539272408707"></p>
</li>
<li><p>证书的颁发机构 -&gt; CA</p>
<ul>
<li>发布根证书</li>
<li>中间证书</li>
<li>个人</li>
</ul>
</li>
<li><p>证书的信任链 -&gt; 证书签发机构的信任链</p>
<p>A是一个可信赖证书签发机构, A信任B, B就有资格去签发证书</p>
<p>从等级上A比B高一级</p>
</li>
</ol>
</blockquote>
</li>
<li><p>有哪些CA机构?</p>
</li>
</ol>
<blockquote>
<p>世界上较早的数字认证中心是美国的verisign<code>威瑞信</code>公司，在windows的证书窗口中可以看到好多verisign公司生成的证书, 美国的<em>DigiCert</em></p>
<p>另外还有加拿大的ENTRUST公司，也是很著名的证书机构。</p>
<p>中国的安全认证体系分为金融CA和非金融CA。</p>
<ul>
<li>在金融CA方面，根证书由中国人民银行管理，</li>
<li>非金融CA方面，由中国电信负责。<ul>
<li>行业性CA<ul>
<li>中国金融认证中心</li>
<li>中国电信认证中心</li>
</ul>
</li>
<li>区域性CA, 区域性CA主要是以政府为背景，以企业机制运行<ul>
<li>广东CA中心</li>
<li>上海CA中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>沃通 – <a href="http://www.wosign.com/products/ssl.htm">www.wosign.com/products/ssl.htm</a></p>
</blockquote>
<h2 id="公钥基础设施-PKI（了解）"><a href="#公钥基础设施-PKI（了解）" class="headerlink" title="公钥基础设施 - PKI（了解）"></a>公钥基础设施 - PKI（了解）</h2><p>PKI组成的要素</p>
<ul>
<li>用户<ul>
<li>申请证书的人 -&gt; web服务器端<ul>
<li>申请证书<ul>
<li>生成密钥对 , 或者委托ca生成</li>
<li>将公钥发送给CA</li>
<li>ca使用自己的私钥对得到公钥签名</li>
<li>将证书发送给用户</li>
</ul>
</li>
<li>发送证书<ul>
<li>当客户端访问服务器的时候发送证书给客户端</li>
</ul>
</li>
<li>注销证书<ul>
<li>当发现私钥泄露之后</li>
</ul>
</li>
</ul>
</li>
<li>使用证书的人 -&gt; 客户端<ul>
<li>接收证书</li>
<li>验证对方的身份信息</li>
</ul>
</li>
</ul>
</li>
<li>CA认证机构<ul>
<li>可以生产密钥对(可选)</li>
<li>对公钥签名</li>
<li>吊销证书</li>
</ul>
</li>
<li>仓库<ul>
<li>存储证书 -&gt; 公钥</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang协程调度器原理与GMP设计思想</title>
    <url>/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="一-Golang“调度器器”由来"><a href="#一-Golang“调度器器”由来" class="headerlink" title="一. Golang“调度器器”由来"></a>一. Golang“调度器器”由来</h1><p>多进程、多线程的问题？</p>
<blockquote>
<p>设计变得复杂，进程/线程的数量越多，切换成本就越大，也就越浪费</p>
<p>多进程、多线程的壁垒,高内存占用，进程占用内存（虚拟内存4GB（32bit OS）），线程占用约4MB</p>
</blockquote>
<h2 id="线程池的缺陷"><a href="#线程池的缺陷" class="headerlink" title="线程池的缺陷"></a>线程池的缺陷</h2><p>​        在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断地从任务队列中取出任务并执行，可以有效的减少线程创建和销毁所带来的开销。</p>
<p><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/m_b499f154d0135854b725ce27a6b7a009_r.png" alt="img"></p>
<p>我们把任务队列中的每一个任务称作G，而G往往代表一个函数。线程池中的worker线程不断地从任务队列中取出任务并执行。而worker线程的调度则交给操作系统进行调度。</p>
<p>如果worker线程执行的G任务中发生系统调用，则操作系统会将该线程置为阻塞状态，也意味着该线程在怠工，也意味着消费任务队列的worker线程变少了，也就是说线程池消费任务队列的能力变弱了。</p>
<p>如果任务队列中的大部分任务都会进行系统调用，则会让这种状态恶化，大部分worker线程进入阻塞状态，从而任务队列中的任务产生堆积。</p>
<p>解决这个问题的一个思路就是重新审视线程池中线程的数量，增加线程池中线程数量可以一定程度上提高消费能力，但随着线程数量增多，由于过多线程争抢CPU，消费能力会有上限，甚至出现消费能力下降。 </p>
<p>调度器器的优化:</p>
<blockquote>
<p>Goroutine的优化: 内存仅占用几KB，可以大量开辟。灵活调用，切换成本低。</p>
</blockquote>
<p>早期的Go的调度器器：</p>
<blockquote>
<p>基本的全局Go队列列和⽐比较传统的轮询利利⽤用多个thread去调度。</p>
<p>弊端：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了了激烈烈的锁竞争。</li>
<li> M转移G会造成延迟和额外的系统负载。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了了系统开销。    </li>
</ol>
</blockquote>
<h1 id="GMP模型的设计思想"><a href="#GMP模型的设计思想" class="headerlink" title="GMP模型的设计思想"></a>GMP模型的设计思想</h1><h2 id="Goroutine主要概念如下："><a href="#Goroutine主要概念如下：" class="headerlink" title="Goroutine主要概念如下："></a>Goroutine主要概念如下：</h2><ul>
<li><p>G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。</p>
</li>
<li><p>M（Machine）： 工作线程，在Go中称为Machine。</p>
</li>
<li><p>P(Processor): 处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。</p>
</li>
</ul>
<img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824210046445.png" alt="image-20210824210046445 " style="zoom:67%;">

<p>M是交给操作系统调度的线程，M持有一个P，P将G调度进M中执行。P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将G调度到M中执行。</p>
<p>P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。</p>
<p>程序中可以使用<code>runtime.GOMAXPROCS()</code>设置P的个数，在某些IO密集型的场景下可以在一定程度上提高性能。</p>
<blockquote>
<p>全局队列:  存放等待运⾏行行的G</p>
<p>P的本地队列: 存放等待运行的G, 数量限制 (不超过256G),优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中。</p>
<p>P列表：程序启动时创建， 最多有GOMAXPROCS个(可配置)</p>
<p>M列表： 当前操作系统分配到当前Go程序的内核线程数。</p>
<p>P的数量：</p>
<ul>
<li>环境变量量$GOMAXPROCS</li>
<li>在程序中通过runtime.GOMAXPROCS() 来设置</li>
</ul>
<p>M的数量：</p>
<ul>
<li>Go语⾔言本身 是限定M的最⼤大量量是10000(忽略略)</li>
<li>runtime/debug包中的SetMaxThreads函数来设置</li>
<li>有一个M阻塞，会创建一个新的M</li>
<li>如果有M空闲，那么就会回收或者睡眠</li>
</ul>
</blockquote>
<h2 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h2><ol>
<li><p>复用线程 避免频繁的创建、销毁线程，而是对线程的复用。</p>
<ul>
<li><p>work stealing机制</p>
<p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p>
</li>
<li><p>hand off机制</p>
<p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p>
</li>
</ul>
</li>
<li><p>利用并行 </p>
<p>GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。</p>
</li>
<li><p>抢占</p>
<p>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死.</p>
</li>
<li><p>全局G队列列 </p>
<p>当M执行work stealing从其他P偷不到G时，它可以从全局G队列列获取G。</p>
</li>
</ol>
<p>每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</p>
<p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p>
<h2 id="“go-func-”-经历了了什什么过程"><a href="#“go-func-”-经历了了什什么过程" class="headerlink" title="“go func()” 经历了了什什么过程"></a>“go func()” 经历了了什什么过程</h2><p>流程：</p>
<blockquote>
<ol>
<li>我们通过 go func()来创建⼀一个goroutine</li>
<li>有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</li>
<li>G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</li>
<li>一个M调度G执行的过程是一个循环机制；</li>
<li>当M执行某一个G时候如果发生了syscall或其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P</li>
<li>当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列列中。</li>
</ol>
</blockquote>
<p>调度器器的生命周期?</p>
<blockquote>
<p>M0</p>
<p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p>G0</p>
<p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数,每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
</blockquote>
<h1 id="GOMAXPROCS设置对性能的影响"><a href="#GOMAXPROCS设置对性能的影响" class="headerlink" title="GOMAXPROCS设置对性能的影响"></a>GOMAXPROCS设置对性能的影响</h1><p>一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。<br>在某些IO密集型的应用里，这个值可能并不意味着性能最好。<br>理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。<br>但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。</p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212038512.png" alt="image-20210824212038512" style="zoom:67%;">

<blockquote>
<p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。</p>
</blockquote>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212307079.png" alt="image-20210824212307079" style="zoom:67%;">

<blockquote>
<p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了了线程M1的复用。</p>
</blockquote>
<h2 id="场景3、4、5"><a href="#场景3、4、5" class="headerlink" title="场景3、4、5"></a>场景3、4、5</h2><center><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212818637.png" alt="image-20210824212818637" style="zoom:50%;"><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212858320.png" alt="image-20210824212858320" style="zoom:50%;"><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212951443.png" alt="image-20210824212951443" style="zoom:50%;"></center>

<h2 id="场景六"><a href="#场景六" class="headerlink" title="场景六"></a>场景六</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824213232136.png" alt="image-20210824213232136" style="zoom:67%;">

<blockquote>
<p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为<strong>自旋线程</strong>（没有G但为运行<br>状态的线程，不断寻找G）。</p>
</blockquote>
<h2 id="场景七"><a href="#场景七" class="headerlink" title="场景七"></a>场景七</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824213556496.png" alt="image-20210824213556496" style="zoom:67%;">

<blockquote>
<p>M2自旋线程，首先尝试从全局队列获取G。M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量量符合下面的公式：</p>
<p>​                            <strong>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</strong></p>
</blockquote>
<h2 id="场景八"><a href="#场景八" class="headerlink" title="场景八"></a>场景八</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214007571.png" alt="image-20210824214007571" style="zoom:50%;">

<blockquote>
<p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
</blockquote>
<h2 id="场景九"><a href="#场景九" class="headerlink" title="场景九"></a>场景九</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214402203.png" alt="image-20210824214402203" style="zoom:50%;">

<blockquote>
<p>最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
</blockquote>
<h2 id="场景十"><a href="#场景十" class="headerlink" title="场景十"></a>场景十</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214727895.png" alt="image-20210824214727895" style="zoom:67%;">

<blockquote>
<p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p>
</blockquote>
<h2 id="场景十一"><a href="#场景十一" class="headerlink" title="场景十一"></a>场景十一</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824215013595.png" alt="image-20210824215013595" style="zoom:50%;">

<blockquote>
<p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>逃逸分析</title>
    <url>/2021/08/24/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。</p>
<p>函数中申请一个新的对象：</p>
<blockquote>
<ul>
<li>如果分配在栈中，则函数执行结束可自动将内存回收；</li>
<li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；</li>
</ul>
</blockquote>
<p>有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。</p>
<h2 id="逃逸策略"><a href="#逃逸策略" class="headerlink" title="逃逸策略"></a>逃逸策略</h2><p>每当函数中申请新的对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中；</li>
</ol>
<p>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</p>
<h2 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h2><h3 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h3><p>道Go可以返回局部变量指针，这是一个典型的变量逃逸案例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数StudentRegister()内部s为局部变量，其值通过函数返回值返回，s本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>通过编译参数-gcflag=-m可以查看编译过程中的逃逸分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: can inline StudentRegister</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: can inline main</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">18</span>: inlining call to StudentRegister</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: leaking param: name</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">18</span>: main <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="栈空间不足逃逸"><a href="#栈空间不足逃逸" class="headerlink" title="栈空间不足逃逸"></a>栈空间不足逃逸</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。<br>直接查看编译提示，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>: Slice <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>) does not escape</span><br></pre></td></tr></table></figure>

<p>我们发现此处并没有发生逃逸。那么把切片长度扩大10倍即10000会如何呢?</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<p>发现当切片长度扩大到10000时就会逃逸。</p>
<p>实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="动态类型逃逸"><a href="#动态类型逃逸" class="headerlink" title="动态类型逃逸"></a>动态类型逃逸</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会产生逃逸。<br>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码s变量只是一个string类型变量，调用fmt.Println()时会产生逃逸：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: s escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: main ... argument does not escape</span><br></pre></td></tr></table></figure>

<h3 id="闭包引用对象逃逸"><a href="#闭包引用对象逃逸" class="headerlink" title="闭包引用对象逃逸"></a>闭包引用对象逃逸</h3><p>某著名的开源框架实现了某个返回Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回一个闭包，闭包引用了函数的局部变量a和b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出Fibonacci数列。<br>完整的示例程序如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: can inline Fibonacci.func1</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: &amp;a escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>: moved to heap: a</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: &amp;b escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>: moved to heap: b</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: f() escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: main ... argument does not escape</span><br></pre></td></tr></table></figure>

<h2 id="逃逸总结"><a href="#逃逸总结" class="headerlink" title="逃逸总结"></a>逃逸总结</h2><blockquote>
<ul>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
</blockquote>
<h2 id="函数传递指针真的比传值效率高吗？"><a href="#函数传递指针真的比传值效率高吗？" class="headerlink" title="函数传递指针真的比传值效率高吗？"></a>函数传递指针真的比传值效率高吗？</h2><blockquote>
<p>指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理01</title>
    <url>/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>程序:就是一个指令序列。</p>
<p>程序段、数据段、PCB三部分组成了<code>进程实体</code>(进程映像)。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。</p>
<blockquote>
<p>PCB是进程存在的唯一标志 !</p>
</blockquote>
<p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有:<br>1.进程是程序的一次执行过程。<br>2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p><font size="4" color="#D2691E">进程(进程实体)</font>由程序段、数据段、PCB三 部分组成。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221509898.png" alt="img " style="zoom:80%;">

<blockquote>
<p>进程的管理者(操作系统)所需的数据都在PCB中。</p>
<p>程序本身的运行所需的数据存放在程序段和数据段中。</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221519928.png" alt="img" style="zoom:80%;">

<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/202105052215334.png" alt="img" style="zoom:80%;">

<h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>
<p>注:进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221547119.png" alt="img" style="zoom:80%;">

<h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221601693.png" alt="在这里插入图片描述" style="zoom:80%;">

<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/202105052216120.png" alt="img" style="zoom:80%;">

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/image-20210827182825094.png" alt="image-20210827182825094" style="zoom:40%;">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221638460.png" alt="img" style="zoom:80%;">

<h2 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h2><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/2021050614465518.png" alt="img" style="zoom:80%;">

<blockquote>
<p><font size="4" color="#D2691E">注意:单核处理机环境下，每时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)</font></p>
<p><font size="4" color="#D2691E">进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即:万事俱备，只欠CPU</font></p>
<p><font size="4" color="#D2691E">如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</font></p>
</blockquote>
<h3 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a>另外两种状态</h3><blockquote>
<p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB (如:为进程分配PID)</p>
</blockquote>
<blockquote>
<p>进程运行结束(或者由于bug导致进程无法继续执行下去，比如数组越界错误)，需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144707756.png" alt="img" style="zoom:80%;">

<h3 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144726154.png" alt="img" style="zoom:67%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144737635.png" alt="img" style="zoom:67%;">

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144753359.png" alt="img" style="zoom:90%;">

<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<br>简化理解：反正进程控制就是要实现进程状态转换</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144809684.png" alt="img" style="zoom:80%;">

<h3 id="如何实现进程控制？"><a href="#如何实现进程控制？" class="headerlink" title="如何实现进程控制？"></a>如何实现进程控制？</h3><blockquote>
<p>用<font size="4" color="#D2691E">原语</font>实现</p>
<p>原语是一种特殊的程序，它的执行具有<font size="4" color="#D2691E">原子性</font>。也就是说，这段程序的运行必须一气呵成，不可中断</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144822199.png" alt="img" style="zoom:67%;">

<blockquote>
<p>思考：<font size="4" color="red">为何进程控制（状态转换）的过程要“一气呵成”？</font></p>
<p>如果不能“一气呵成”，就有可能导致操作系\统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。</p>
</blockquote>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144839638.png" alt="img" style="zoom:100%;">

<p>假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：</p>
<ol>
<li>将PCB2的 state 设为1</li>
<li>将PCB2从阻塞队列放到就绪队列</li>
</ol>
<p>完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里</p>
<h3 id="如何实现原语的“原子性”？"><a href="#如何实现原语的“原子性”？" class="headerlink" title="如何实现原语的“原子性”？"></a>如何实现原语的“原子性”？</h3><p>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。<br>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144853436.png" alt="img " style="zoom:80%;">

<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</p>
<p><font size="4" color="red">CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</font></p>
<h3 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h3><h4 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144909647.png" alt="img" style="zoom:80%;">

<h4 id="撤消原语"><a href="#撤消原语" class="headerlink" title="撤消原语"></a>撤消原语</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144920651.png" alt="img" style="zoom:80%;">

<h4 id="阻塞-唤醒"><a href="#阻塞-唤醒" class="headerlink" title="阻塞 唤醒"></a>阻塞 唤醒</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144935442.png" alt="img" style="zoom:80%;"> 

<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144955489.png" alt="img" style="zoom:80%;"></h4><h3 id="进程控制相关的原语-1"><a href="#进程控制相关的原语-1" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h3><ol>
<li>更新PCB中的信息<br>a. 所有的进程控制原语一定都会修改进程状态标志<br>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c. 某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配 / 回收资源</li>
</ol>
<h3 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145204110.png" alt="img" style="zoom:80%;">

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145251732.png" alt="在这里插入图片描述" style="zoom:80%;">

<p>顾名思义，进程通信就是指进程之间的信息交换。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145310313.png" alt="img" style="zoom:80%;">

<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<h3 id="进程通信——共享存储"><a href="#进程通信——共享存储" class="headerlink" title="进程通信——共享存储"></a>进程通信——共享存储</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/image-20210827202122804.png" alt="image-20210827202122804" style="zoom:80%;">

<p><font size="4" color="red">基础数据结构</font>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p>
<p><font size="4" color="red">基于存储区</font>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<font size="4" color="red">高级通信</font>方式。</p>
<h3 id="进程通信——管道通信"><a href="#进程通信——管道通信" class="headerlink" title="进程通信——管道通信"></a>进程通信——管道通信</h3><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145344648.png" alt="img" style="zoom:80%;">

<ol>
<li>管道只能采用<font size="4" color="red">半双工通信</font>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li>
<li>各进程要<font size="4" color="red">互斥</font>地访问管道。</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。（缓冲区的特性）</li>
<li>如果没写满，就不允许读。如果没读空，就不允许写。<strong>（缓冲区的特性）</strong></li>
<li><font size="4" color="red">数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</font></li>
</ol>
<h3 id="进程通信——消息传递"><a href="#进程通信——消息传递" class="headerlink" title="进程通信——消息传递"></a>进程通信——消息传递</h3><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息 / 接收消息”<font size="4" color="red">原语</font>进行数据交换。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145406491.png" alt="img" style="zoom:80%;">

<ul>
<li>直接消息传递：消息直接挂到接收进程的消息缓冲队列上</li>
<li>间接消息传递：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145419455.png" alt="img" style="zoom:80%;">]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理02</title>
    <url>/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大</p>
<p>引入线程后，线程是CPU调度的基本单位</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/202105061455388.png" alt="img" style="zoom:80%;">

<h2 id="线程的优点和特性"><a href="#线程的优点和特性" class="headerlink" title="线程的优点和特性"></a>线程的优点和特性</h2><ul>
<li>进程间并发，开销很大<ol>
<li>当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）</li>
</ol>
</li>
<li>线程间并发，开销更小<ol>
<li>同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力</li>
</ol>
</li>
</ul>
<p>引入线程机制后，并发带来的系统开销降低，系统并发性提升</p>
<blockquote>
<p><font color="red">注意：从属于不同进程的线程间通信，也必须请求操作系统服务！</font></p>
</blockquote>
<p>引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。</p>
<p>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。线程也有运行态、就绪态、阻塞态</p>
<p>在多CPU环境下，各个线程也可以分派到不同的CPU上并行地执行。</p>
<p>线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145558176.png" alt="img" style="zoom:80%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210827205628248.png" alt="image-20210827205628248" style="zoom:80%;">

<h1 id="线程的实现方式多线程模型"><a href="#线程的实现方式多线程模型" class="headerlink" title="线程的实现方式多线程模型"></a>线程的实现方式多线程模型</h1><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145612404.png" alt="img" style="zoom:67%;">

<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h3><p>历史背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145625241.png" alt="img" style="zoom:80%;">

<ol>
<li><p>线程的管理工作由谁来完成？</p>
<blockquote>
<p>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</p>
</blockquote>
</li>
<li><p>线程切换是否需要CPU？</p>
<blockquote>
<p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
</blockquote>
</li>
<li><p>操作系统是否能意识到用户级线程的存在？</p>
<blockquote>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</p>
</blockquote>
</li>
<li><p>这种线程的实现方式有什么优点和缺点？</p>
</li>
</ol>
<blockquote>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统<br>开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
</blockquote>
<h3 id="内核级"><a href="#内核级" class="headerlink" title="内核级"></a>内核级</h3><p>内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”） 由操作系统支持的线程</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145742221.png" alt="img" style="zoom:80%;">

<blockquote>
<p>现代操作系统都实现了内核级线程，如Windows、Linux</p>
</blockquote>
<ol>
<li><p>线程的管理工作由谁来完成？</p>
<blockquote>
<p>内核级线程的管理工作由操作系统内核完成。</p>
</blockquote>
</li>
<li><p>线程切换是否需要CPU？</p>
<blockquote>
<p>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</p>
</blockquote>
</li>
<li><p>操作系统是否能意识到内核级线程的存在？</p>
<blockquote>
<p>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</p>
</blockquote>
</li>
<li><p>这种线程的实现方式有什么优点和缺点？</p>
<blockquote>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
</blockquote>
</li>
</ol>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145758880.png" alt="img" style="zoom:80%;">

<blockquote>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
</blockquote>
<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145815581.png" alt="img " style="zoom:80%;">

<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<blockquote>
<p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</p>
</blockquote>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多模型：n 用户及线程映射到m 个内核级线程（n &gt;= m）。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145838455.png" alt="img" style="zoom:80%;">

<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145853642.png" alt="在这里插入图片描述" style="zoom:80%;">

<h1 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h1><h2 id="处理机调度概念、层次"><a href="#处理机调度概念、层次" class="headerlink" title="处理机调度概念、层次"></a>处理机调度概念、层次</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145931264.png" alt="在这里插入图片描述" style="zoom:80%;">

<h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145942297.png" alt="img" style="zoom:67%;">

<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p>
<p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p>
<h3 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145957668.png" alt="img" style="zoom:80%;">

<blockquote>
<p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
<p>高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p>
<p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
</blockquote>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150011732.png" alt="img" style="zoom:67%;">

<blockquote>
<p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p>
<p>这么做的目的是为了<font color="red">提高内存利用率和系统吞吐量</font>。</p>
<p>暂时调到外存等待的进程状态为<font color="red">挂起状态</font>。值得注意的是，<font color="red">PCB并不会一起调到外存，而是会常驻内存</font>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<font color="red">被挂起的进程PCB会被放到的挂起队列中</font>。</p>
<p><font color="red">中级调度（内存调度</font>），就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>一个进程可能会被多次调出、调入内存，因此<font color="red">中级调度发生的频率要比高级调度更高</font>。</p>
</blockquote>
<h5 id="补充知识：进程的挂起态与七状态模型"><a href="#补充知识：进程的挂起态与七状态模型" class="headerlink" title="补充知识：进程的挂起态与七状态模型"></a>补充知识：进程的挂起态与七状态模型</h5><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态<br>五状态模型 —–&gt; 七状态模型</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615002451.png" alt="img" style="zoom:80%;">

<p>注意“挂起”和“阻塞”的区别，两种就绪挂起 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为阻塞挂起 多个队列。</p>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150036446.png" alt="img" style="zoom:80%;">

<p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150053987.png" alt="img" style="zoom:80%;">

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150104532.png" alt="img" style="zoom:80%;">

<h2 id="进程调度的时机切换与过程调度方式"><a href="#进程调度的时机切换与过程调度方式" class="headerlink" title="进程调度的时机切换与过程调度方式"></a>进程调度的时机切换与过程调度方式</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150114745.png" alt="img" style="zoom:80%;">

<h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615013284.png" alt="img" style="zoom:80%;">

<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>临界区：访问临界资源的那段代码。</p>
<p><font color="red">内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</font></p>
<blockquote>
<p>有的系统中，只允许进程主动放弃处理机有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
</blockquote>
<p>进程在普通临界区中是可以进行调度、切换的。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828152941229.png" alt="image-20210828152941229" style="zoom:80%;">

<blockquote>
<p>正在运行的进程如果正在访问就绪队列，会对其进行上锁，如果还没有退出临界区（解锁），就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行调度。</p>
<p><font color="red">内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</font></p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828153416754.png" alt="image-20210828153416754" style="zoom:80%;">

<blockquote>
<p>进程使用打印机时，会对打印机这一临界资源进行上锁，进程一直处于临界区内，临界资源不会解锁。但是打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。</p>
<p><font color="red">普通临界区访问的临界资源不会直接影响操作心痛内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</font></p>
</blockquote>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><font color="red">剥夺调度方式，又称非抢占方式</font>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<blockquote>
<p># 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
</blockquote>
<p><font color="red">剥夺调度方式，又称抢占方式</font>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<blockquote>
<p># 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
</blockquote>
<h3 id="进程切换的过程主要完成了："><a href="#进程切换的过程主要完成了：" class="headerlink" title="进程切换的过程主要完成了："></a>进程切换的过程主要完成了：</h3><p>对原来运行进程各种数据的保存</p>
<p>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p>
<p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150219719.png" alt="img" style="zoom:80%;">

<h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>CPU利用率：指CPU “忙碌”的时间占总时间的比例。</p>
<blockquote>
<p>利 用 率 = 忙 碌 的 时 间 / 总 时 间</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150229620.png" alt="img" style="zoom:70%;">

<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</p>
<p>系统吞吐量：单位时间内完成作业的数量</p>
<blockquote>
<p>系统吞吐量=总共完成了多少道作业/总共花了多少时间</p>
</blockquote>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？ 10/100 = 0.1 道 / 秒</p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
<p>它包括四个部分：</p>
<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间、</li>
<li>进程在CPU上执行的时间、</li>
<li>进程等待I/O操作完成的时间。</li>
</ul>
<p>后三项在一个作业的整个处理过程中，可能发生多次。对于用户来说，更关心自己的单个作业的周转时间</p>
<blockquote>
<p>(作业）周转时间=作业完成时间–作业提交时间</p>
</blockquote>
<p>对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值</p>
<blockquote>
<p>平均周转时间=各作业周转时间之和/作业数</p>
</blockquote>
<h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间，指进程 / 作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150322912.png" alt="img" style="zoom:80%;">

<blockquote>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p>
</blockquote>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150344160.png" alt="img" style="zoom:100%;">

<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150354868.png" alt="img " style="zoom:80%;">

<blockquote>
<p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度？</li>
<li>抢占式？非抢占式？</li>
<li>优点和缺点</li>
<li>是否会导致饥饿</li>
</ol>
<p>饥饿:某进程 / 作业长期得不到服务.</p>
</blockquote>
<h3 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h3><p>按照作业 / 进程到达的先后顺序进行服务</p>
<p>用于作业 / 进程调度: 用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。</p>
<p>非抢占式的算法</p>
<p>优点：公平、算法实现简单<br>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶…）</p>
<p>不会产生饥饿现象</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615041251.png" alt="img" style="zoom:80%;">

<h3 id="短作业优先（SJF-Shortest-Job-First）"><a href="#短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="短作业优先（SJF, Shortest Job First）"></a>短作业优先（SJF, Shortest Job First）</h3><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p>
<p>算法规则： 最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p>
<p>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</p>
<p><font color="red">SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）</font></p>
<p>优缺点：</p>
<blockquote>
<p>优点：“最短的”平均等待时间、平均周转时间</p>
<p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>
</blockquote>
<p>是否会产生饥饿？</p>
<blockquote>
<p>会。如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。</p>
</blockquote>
<p>非抢占式：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828161614275.png" alt="image-20210828161614275" style="zoom:80%;">

<p>抢占式：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828161853587.png" alt="image-20210828161853587 " style="zoom:80%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828162029637.png" alt="image-20210828162029637" style="zoom:80%;">

<p>先来先服务（FCFS） 和 短作业优先（SJF） 的思考？</p>
<blockquote>
<p><font color="red">FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此对短作业不友好。</font></p>
<p><font color="red">SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑哥哥作业的等待时间，因此导致对长作业不友好的问题，甚至会产生饥饿问题</font></p>
</blockquote>
<p>设计一个算法，既考虑各个作业的等待时间，也能兼顾运行时间？ </p>
<h3 id="高响应比优先（HRRN，Highest-Response-Ratio-Next）"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next）" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next）"></a>高响应比优先（HRRN，Highest Response Ratio Next）</h3><p>算法思想：综合考虑作业/进程的等待时间和要求服务的时间。</p>
<p>算法规则： 在每次调度时先计算各个作业/进程的响应比，选择相应比最高的作业/进程为其服务。</p>
<blockquote>
<p>响应比=（等待时间+要求服务时间）/ 要求服务时间</p>
</blockquote>
<p>是否可抢占？</p>
<blockquote>
<p>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
</blockquote>
<p>优缺点：</p>
<blockquote>
<p>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先。要求服务时间相同时，等待时间长的优先。对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饿死的问题。</p>
</blockquote>
<p>不会导致饥饿。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828163921731.png" alt="image-20210828163921731" style="zoom:80%;">





<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828164332921.png" alt="image-20210828164332921" style="zoom:80%;">

<h3 id="时间片轮转-RR"><a href="#时间片轮转-RR" class="headerlink" title="时间片轮转(RR)"></a>时间片轮转(RR)</h3><p>轮流让就绪队列中的进程依次执行一个时间片 (当前的进程会被抢占)</p>
<p>注意：<br>(1) 每次选择的上处理机的进程都是排在就绪队列队头的进程<br>(2) 一个进程执行完会移动到就绪队列的尾部<br>(3) 一个进程时间片到，刚下处理机要移至就绪队列的尾部的同时有一个新进程到达就绪队 列，则新进程先到达就绪队列的尾部<br>时间片轮转算法过程详解(假设时间片大小为2)，如图：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094355454.png" alt="img " style="zoom:80%;">

<blockquote>
<p>(1) 0时刻，只有P1，P1运行2时间片<br>(2) 2时刻，P1下处理机(P1剩3)，同时P2到达，P2先进入就绪队列(P2 → P1)，P2运行2时间片<br>(3) 4时刻，P2下处理机(P2剩2)，同时P3到达，P3比P2先到达就绪队列(P1 → P3 → P2)，P1运行2时间片<br>(4) 5时刻，P4到达，此时的就绪队列(P1 → P3 → P2 → P4)<br>(5) 6时刻，P1下处理机(P1剩1)，P3运行1时间片，此时的就绪队列(P3 → P2 → P4 → P1)<br>(6) 7时刻，P3下处理机(P3运行结束)，P2运行2时间片<br>(7) 9时刻，P2下处理机(P2运行结束)，P4运行2时间片，就绪队列(P4 → P1)<br>(8) 11时刻，P4下处理机(P4剩4)，P1运行1时间片<br>(9) 12时刻，P1下处理机(P1运行结束)，此后一直运行P4，16时刻所有进程结束</p>
</blockquote>
<p>注意：<br>(1) 若时间片太大，使得每个进程都可以在一个时间片完成，此算法会退化为先来先服务算 法，因此时间片不能太大<br>(2) 若时间片太小，进程切换过于频繁，因此时间片不能太小</p>
<p>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094404849.png" alt="img" style="zoom:80%;">

<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>(1) 非抢占式的优先级调度算法<br>每次调度时选择当前已到达且优先级最高的进程 (执行完当前的进程才会执行下一个进 程，不会被抢占)，如图：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094424713.png" alt="img" style="zoom:80%;">

<p> P2与P4优先级相同，先到达的先执行</p>
<p>(2) 抢占式的优先级调度算法<br>每次调度时选择当前已到达且优先级最高的进程，当前进程主动放弃处理机时会发生调度， 就绪队列发生改变时会发生抢占 (当前的进程会被抢占)，如图</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094434296.png" alt="img" style="zoom:80%;">

<p><font color="red">应当适当提升I/O型进程的优先级</font></p>
<p>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094448494.png" alt="img" style="zoom:80%;">

<h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h3><p>(1) 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br>(2) 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程 还未结束，则进程进入下一级队列队尾，如果此时已经在最下级的队列，则重新放回最下级 队列的队尾<br>(3) 只有第K级队列为空时，才会为第K + 1级队列队头的进程分配时间片<br>(4) 被抢占处理机的进程重新放回原队列队尾<br>执行过程详解，如图</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094521559.png" alt="img" style="zoom:80%;">

<p>P1运行1个时间片(P1剩7)，P1进入第二级队列，P2到达第一级队列，P2运行1个时间片(P2剩3)，P2进入第二级队列，第一级队列为空，执行第二级队列的P1，P1运行2时间片(P1剩5)，P1进入第三级队列，执行第二级队列的P2，P2运行1个时间片(P2被抢占，P2剩2)，P3到达第一级队列，执行P3，P3运行1个时间片(P3运行结束)，执行第二级队列的P2，P2运行2个时间片(P2运行结束)，剩余时间执行P1直至结束<br>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2020092709452942.png" alt="img" style="zoom:80%;">]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理03</title>
    <url>/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/</url>
    <content><![CDATA[<h2 id="一、进程同步、互斥"><a href="#一、进程同步、互斥" class="headerlink" title="一、进程同步、互斥"></a>一、进程同步、互斥</h2><h3 id="1-进程同步的概念"><a href="#1-进程同步的概念" class="headerlink" title="1. 进程同步的概念"></a>1. 进程同步的概念</h3><blockquote>
<p>进程同步指的是协调多个并发执行进程的工作先后次序</p>
</blockquote>
<h3 id="2-进程互斥的概念"><a href="#2-进程互斥的概念" class="headerlink" title="2. 进程互斥的概念"></a>2. 进程互斥的概念</h3><blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源</p>
<p>进程互斥指的是当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待， 当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源</p>
</blockquote>
<h3 id="3-访问临界资源"><a href="#3-访问临界资源" class="headerlink" title="3. 访问临界资源"></a>3. 访问临界资源</h3><p>对临界资源的互斥访问，可在逻辑上分为如下四个部分：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102144475.png" alt="img" style="zoom:150%;">

<h3 id="4-访问临界资源需要遵循的原则"><a href="#4-访问临界资源需要遵循的原则" class="headerlink" title="4. 访问临界资源需要遵循的原则"></a>4. 访问临界资源需要遵循的原则</h3><ol>
<li>空闲让进  <ul>
<li>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
</ul>
</li>
<li>忙则等待 <ul>
<li> 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
</ul>
</li>
<li>有限等待  <ul>
<li>对请求访问的进程，应保证能在有限时间内进入临界区 (保证不会饥饿)</li>
</ul>
</li>
<li>让权等待 <ul>
<li>当进程不能进入临界区，应当立即释放处理机，防止进程忙等待 (不应该让他占用处理机 一直执行循环无法前进，应当得知无法进入临界区时不执行循环，直接切换进程)</li>
</ul>
</li>
</ol>
<h3 id="5-知识回顾"><a href="#5-知识回顾" class="headerlink" title="5. 知识回顾"></a>5. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102207229.png" alt="img" style="zoom:80%;">

<h2 id="二、进程互斥的软件实现方法"><a href="#二、进程互斥的软件实现方法" class="headerlink" title="二、进程互斥的软件实现方法"></a>二、进程互斥的软件实现方法</h2><h3 id="1-单标志法"><a href="#1-单标志法" class="headerlink" title="1. 单标志法"></a>1. 单标志法</h3><p>思想：一个进程访问完临界区后会把使用临界区的权限交给另一个进程，即每个进程进入临界 区的权限只能被另一个进程赋予</p>
<p>过程：<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102234925.png" alt="img" style="zoom:150%;"></p>
<p>若P0要访问临界区，turn变为0，P1会一直在⑤循环，无法向下进行，P0访问完，将 turn改为1，P1跳出循环，P1可访问临界区</p>
<p>注意：<br>(1) 该算法可以实现同一时刻最多只允许一个进程访问临界区<br>(2) 如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么此时虽然临界区 空闲，但一直不允许P1访问，因此，单标志法存在的问题是：违背空闲让进原则</p>
<h3 id="2-双标志先检查法"><a href="#2-双标志先检查法" class="headerlink" title="2. 双标志先检查法"></a>2. 双标志先检查法</h3><p>思想：设置一个布尔数组flag[]，数组中各元素标记各进程是否想进入临界区，true表示想进入， false表示不想进入；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界 区，如果没有，把自身对应的标志flag[i]改为true，之后开始访问临界区</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102253393.png" alt="img " style="zoom:150%;">

<p>存在的问题：P0进程进入之后，在修改P0为true之前，切换到P1，P1检查无别的进程 想进入临界区，故会将P1改为true，导致两个进程都为true，会同时访问</p>
<p>注意：<br>(1) 双标志先检查法存在的问题是：违背忙则等待原则<br>(2) 出现的原因：进入区的检查和上锁不是一气呵成的</p>
<h3 id="3-双标志后检查法"><a href="#3-双标志后检查法" class="headerlink" title="3. 双标志后检查法"></a>3. 双标志后检查法</h3><p>思想：双标志先检查法的改版，先上锁后检查，谁想进谁直接将自身改为true，不关心其他进 程，改为true之后，再检查有没有其他进程想访问</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102304319.png" alt="img" style="zoom:150%;">

<blockquote>
<p>存在的问题：P0想进入，P0改为true，在检查之前切换到P1，P1想进入，改为true，                      </p>
<p>导致两个进程都为true，谁都无法访问临界区，产生饥饿现象</p>
</blockquote>
<p>注意：<br>(1) 双标志后检查法解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则<br>(2) 出现的原因：进入区的检查和上锁不是一气呵成的</p>
<h3 id="4-Peterson算法"><a href="#4-Peterson算法" class="headerlink" title="4. Peterson算法"></a>4. Peterson算法</h3><p>思想：双标志后检查法的改版，若两个进程都想进入临界区，可以主动让对方优先访问临界区</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102354672.png" alt="img" style="zoom:120%;">

<p>进入区做了三件事：1. 主动争取 2. 主动谦让 3. 检查对方</p>
<p>注意：<br>Peterson算法解决了空闲让进，忙则等待，有限等待三个原则，但违背了让权等待原则</p>
<h3 id="5-知识回顾-1"><a href="#5-知识回顾-1" class="headerlink" title="5. 知识回顾"></a>5. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102412523.png" alt="img" style="zoom:150%;">

<h2 id="三、进程互斥的硬件实现方法"><a href="#三、进程互斥的硬件实现方法" class="headerlink" title="三、进程互斥的硬件实现方法"></a>三、进程互斥的硬件实现方法</h2><h3 id="1-中断屏蔽方法"><a href="#1-中断屏蔽方法" class="headerlink" title="1. 中断屏蔽方法"></a>1. 中断屏蔽方法</h3><p>利用开/关中断指令实现，与原语思想相同，即在某进程开始访问临界区到结束访问为止都不允 许被中断，也就不能发生进程切换，因此也不可能出现两个进程同时访问临界区的情况</p>
<p>优点：简单、高效</p>
<p>缺点：不适用于多处理机；只适用于内核进程，不适用于用户进程</p>
<h3 id="2-TestAndSet指令-TS指令"><a href="#2-TestAndSet指令-TS指令" class="headerlink" title="2. TestAndSet指令(TS指令)"></a>2. TestAndSet指令(TS指令)</h3><p>又称为TestAndSetLock指令(TSL指令)</p>
<p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102423874.png" alt="img" style="zoom:150%;">

<p>若刚开始lock是false(没有进程访问临界区)，则TSL返回值是false，不会卡在while循环，此 进程可以访问临界区；若刚开始是true(有进程在访问临界区)，TSL返回值是true，会卡在while 循环，直到正在访问临界区的进程访问结束，将lock值改为false，此进程才可进入临界区</p>
<p>优点：实现简单，适用于多处理机环境</p>
<p>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致忙等</p>
<h3 id="3-Swap指令"><a href="#3-Swap指令" class="headerlink" title="3.Swap指令"></a>3.Swap指令</h3><p>又称为Exchange指令(XCHG指令)</p>
<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102445294.png" alt="img" style="zoom:150%;">

<p>当lock为false(无进程访问临界区时)才可以跳出循环，访问临界区</p>
<p>优点：实现简单，适用于多处理机环境</p>
<p>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令， 从而导致忙等</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102454314.png" alt="img" style="zoom:150%;">

<h2 id="四、信号量机制"><a href="#四、信号量机制" class="headerlink" title="四、信号量机制"></a>四、信号量机制</h2><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h3><p>进程互斥的四种软件实现方法、三种硬件实现方法都无法实现让权等待，也就是进程无法进入 临界区时，会占用处理机一直循环(因为并没有必要一直循环，可以直接切换进程)</p>
<h3 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h3><ol>
<li>信号量就是一个变量，表示系统中某种资源的数量</li>
<li>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作</li>
<li> 一对原语是：wait(S)原语和signal(S)原语，S是信号量 (将此对原语理解为函数)</li>
<li> 通常将wait(S)称为P操作，写为P(S)；通常将signal(S)称为V操作，写为V(S)</li>
</ol>
<h3 id="3-整型信号量"><a href="#3-整型信号量" class="headerlink" title="3. 整型信号量"></a>3. 整型信号量</h3><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量，如下：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102523953.png" alt="img" style="zoom:150%;">

<h3 id="4-记录型信号量"><a href="#4-记录型信号量" class="headerlink" title="4. 记录型信号量"></a>4. 记录型信号量</h3><p>在整型信号量(不满足让权等待)的基础上进行改进，使用记录型数据结构表示信号量，如下：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102528780.png" alt="img" style="zoom:150%;">

<p>举个例子：<br>计算机有两台打印机，需要分配给不同的进程使用，value初始值为2，等待队列为空：</p>
<ol>
<li>P0进程使用打印机，执行wait，value–，value值成为1</li>
<li>P1进程使用打印机，执行wait，value–，value值成为0 (无打印机可用)</li>
<li>P2进程使用打印机，执行wait，value–，value值成为-1，value &lt; 0，执行block，成为等 待队列的队首 (无法使用时，不会占用处理机执行循环，未出现忙等现象)</li>
<li>P3进程使用打印机，执行wait，value–，value值成为-2，value &lt; 0，执行block，成为等 待队列的第二个进程</li>
<li>切换到P0，P0使用完打印机，执行signal，value++，value值成为-1，value &lt;= 0，执行 wakeup，唤醒等待队列的队首进程(P2进程)，P2移出等待队列，P2使用打印机</li>
<li>切换到P2，P2使用完打印机，执行signal，value++，value值成为-1，value &lt;= 0，执行 wakeup，唤醒等待队列的队首进程(P3进程)，P3移出等待队列，P3使用打印机</li>
</ol>
<h3 id="5-知识回顾-2"><a href="#5-知识回顾-2" class="headerlink" title="5.知识回顾"></a>5.知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102545233.png" alt="img" style="zoom:150%;">

<h2 id="五、用信号量实现进程互斥、同步、前驱关系"><a href="#五、用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="五、用信号量实现进程互斥、同步、前驱关系"></a>五、用信号量实现进程互斥、同步、前驱关系</h2><h3 id="1-信号量机制实现进程互斥"><a href="#1-信号量机制实现进程互斥" class="headerlink" title="1. 信号量机制实现进程互斥"></a>1. 信号量机制实现进程互斥</h3><p>设置互斥信号量mutex，初值为1，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102555237.png" alt="img" style="zoom:150%;">

<p>注意：<br>(1) 对不同的临界资源需要设置不同的互斥信号量<br>(2) P、V操作必须成对出现，缺少P无法保证互斥访问，缺少V无法唤醒等待进程</p>
<h3 id="2-信号量机制实现进程同步"><a href="#2-信号量机制实现进程同步" class="headerlink" title="2. 信号量机制实现进程同步"></a>2. 信号量机制实现进程同步</h3><p>实现进程同步，必须保证进程的执行是有先后次序的，即一前一后</p>
<ol>
<li>设置同步信号量S，初值为0 (理解为刚开始没有资源，P1进程想使用必须通过P2产生资源)</li>
<li>在前进程之后执行V(S)</li>
<li>在后进程之前执行P(S)</li>
</ol>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102614435.png" alt="img" style="zoom:150%;">

<h3 id="3-信号量机制实现前驱关系"><a href="#3-信号量机制实现前驱关系" class="headerlink" title="3. 信号量机制实现前驱关系"></a>3. 信号量机制实现前驱关系</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102623827.png" alt="img" style="zoom:150%;">

<h3 id="4-知识回顾-1"><a href="#4-知识回顾-1" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102635850.png" alt="img" style="zoom:150%;">

<h2 id="六、生产者-消费者问题"><a href="#六、生产者-消费者问题" class="headerlink" title="六、生产者 - 消费者问题"></a>六、生产者 - 消费者问题</h2><p>问题分析<br>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费 者进程每次从缓冲区中取出一个产品并使用，生产者、消费者共享一个初始为空、大小为n的 缓冲区<br>2. 关系分析</p>
<p>(1) 同步关系</p>
<p>i. 缓冲区满时，生产者需要等消费者取走产品<br>ii. 缓冲区空时，消费者需要等生产者放入产品</p>
<p>(2) 互斥关系</p>
<p>i. 生产者与消费者要互斥访问缓冲区 (缓冲区是临界资源)<br>ii. 生产者与生产者要互斥访问缓冲区 (两个生产者可能会覆盖数据)<br>iii. 消费者与消费者要互斥访问缓冲区 (两个消费者可能有一个读的是空数据)</p>
<p>实现<br><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102656876.png" alt="img" style="zoom:150%;"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2021/08/28/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="一、死锁的概念"><a href="#一、死锁的概念" class="headerlink" title="一、死锁的概念"></a>一、死锁的概念</h2><h3 id="1-死锁、饥饿、死循环的区别"><a href="#1-死锁、饥饿、死循环的区别" class="headerlink" title="1. 死锁、饥饿、死循环的区别"></a>1. 死锁、饥饿、死循环的区别</h3><p>(1) 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进<br>(2) 饥饿：长期得不到想要的资源，某进程无法向前推进<br>(3) 死循环：某进程执行过程中一直跳不出某个循环</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103625525.png" alt="img" style="zoom:150%;">

<h3 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，若有一个不满足，死锁就不会发生</p>
<p>(1) 互斥条件：对互斥使用的资源的争夺才会导致死锁<br>(2) 不剥夺条件：进程获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放<br>(3) 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又 被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放<br>(4) 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被 下一个进程所请求</p>
<p>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁</p>
<h3 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3.死锁的处理策略"></a>3.死锁的处理策略</h3><p>(1) 预防死锁：破坏死锁产生的四个必要条件中的一个或几个<br>(2) 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁<br>(3) 死锁的检测和解除：允许死锁的发生，操作系统检测出死锁后，会采取措施解除死锁</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103641570.png" alt="img" style="zoom:150%;">

<h2 id="二、死锁的处理策略-—-预防死锁"><a href="#二、死锁的处理策略-—-预防死锁" class="headerlink" title="二、死锁的处理策略 — 预防死锁"></a>二、死锁的处理策略 — 预防死锁</h2><img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828221812000.png" alt="image-20210828221812000" style="zoom:67%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828221834071.png" alt="image-20210828221834071" style="zoom:70%;">

<p><strong>破坏互斥条件</strong></p>
<p>只有对必须互斥使用的资源的争夺才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。<font color="red">比如:SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如用SPOOLing技术将打印机改造为共享设备….</font></p>
<p>该策略的缺点：并不是所有的资源都可以改造成可以共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103647730.png" alt="img" style="zoom:150%;">

<h2 id="三、死锁的处理策略-—-避免死锁"><a href="#三、死锁的处理策略-—-避免死锁" class="headerlink" title="三、死锁的处理策略 — 避免死锁"></a>三、死锁的处理策略 — 避免死锁</h2><h3 id="1-安全序列的介绍"><a href="#1-安全序列的介绍" class="headerlink" title="1. 安全序列的介绍"></a>1. 安全序列的介绍</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找 出一个安全序列，系统就是安全状态 (安全序列可能有多个)</p>
<p>如果分配了资源以后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味 着之后可能所有进程都无法顺利的执行下去</p>
<p>注意：</p>
<p>(1) 如果系统处于安全状态，就一定不会发生死锁<br>(2) 如果系统进入不安全状态，就可能发生死锁<br>(3) 处于不安全状态未必会发生死锁，但发生死锁时一定处于不安全状态</p>
<h3 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h3><p>思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，由此决定是否答应 资源分配请求</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103704759.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/202012271037089.png" alt="img" style="zoom:90%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828225137636.png" alt="image-20210828225137636" style="zoom:80%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828225049182.png" alt="image-20210828225049182" style="zoom:80%;">

<p>注：如果银行家算法是安全性算法，说明此时系统处于安全状态，不会发生死锁</p>
<h2 id="四、死锁的处理策略-—-死锁的检测与解除"><a href="#四、死锁的处理策略-—-死锁的检测与解除" class="headerlink" title="四、死锁的处理策略 — 死锁的检测与解除"></a>四、死锁的处理策略 — 死锁的检测与解除</h2><h3 id="1-死锁的检测"><a href="#1-死锁的检测" class="headerlink" title="1. 死锁的检测"></a>1. 死锁的检测</h3><p>为了能对系统是否发生了死锁进行检测，必须：</p>
<p>(1) 用资源分配图保存资源的请求和分配信息<br>(2) 提供一种算法，利用上述信息检测系统是否进入死锁状态</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103722593.png" alt="img" style="zoom:150%;">

<p>P2进程请求1个资源，但R1的3个资源都已经分配出去，无法执行；P1进程请求1个资 源，R2剩余1个资源，P1执行；P1执行完毕之后，释放自身的所有资源，P1的三条边全 部消除；R1剩余的资源可满足P2进程；P2进程执行，P2的三条边全部消除</p>
<p>注意：</p>
<p>(1) 如果按照上述过程可以消除所有的边，表示此图可完全简化，不会发生死锁<br>(2) 如果不能消除所有的边，说明发生了死锁<br>(3) 最终还连着边的那些进程就是死锁进程</p>
<h3 id="2-死锁的解除"><a href="#2-死锁的解除" class="headerlink" title="2. 死锁的解除"></a>2. 死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁，解除死锁的方法有：</p>
<p>(1) 资源剥夺法</p>
<p>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程；但是应防止被 挂起的进程长时间得不到资源而饥饿</p>
<p>(2) 撤销进程法</p>
<p>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源</p>
<p>(3) 进程回退法</p>
<p>让死锁进程回退到足以避免死锁的地步 (这就要求系统记录历史信息、设置还原点)</p>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103747269.png" alt="img" style="zoom:150%;">

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理的概念</title>
    <url>/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="一、内存管理的概念"><a href="#一、内存管理的概念" class="headerlink" title="一、内存管理的概念"></a>一、内存管理的概念</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210828232818560.png" alt="image-20210828232818560" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227131925434.png" alt="img " style="zoom:100%;">

<h2 id="二、覆盖与交换"><a href="#二、覆盖与交换" class="headerlink" title="二、覆盖与交换"></a>二、覆盖与交换</h2><h3 id="1-覆盖技术"><a href="#1-覆盖技术" class="headerlink" title="1. 覆盖技术"></a>1. 覆盖技术</h3><p>将程序分成多个段，常用的段常驻内存的固定区，不常用的段放在内存的覆盖区，在需要的时 候调入内存</p>
<p><font color="red">覆盖技术是早期 在单一连续存储管理中使用的扩大存储器容量的一种技术。</font></p>
<h3 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h3><p>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程 换入内存，使用中级调度来完成</p>
<ul>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？</li>
</ul>
<blockquote>
<p>1.具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的/0速度比文件区的更快。</p>
</blockquote>
<ul>
<li>什么时候应该交换?</li>
</ul>
<blockquote>
<p> 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出–些进程;.如果缺页率明显下降，就可以暂停换出。</p>
</blockquote>
<ul>
<li>应该换出哪些进程?</li>
</ul>
<blockquote>
<p>3.可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p>
</blockquote>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713194229.png" alt="img " style="zoom:150%;">

<h2 id="三、连续分配管理方式"><a href="#三、连续分配管理方式" class="headerlink" title="三、连续分配管理方式"></a>三、连续分配管理方式</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829110339431.png" alt="image-20210829110339431 " style="zoom:80%;">

<p>连续分配指为进程分配的必须是一个连续的内存空间</p>
<p>内部碎片指分配给某进程的内存区域中，有些部分没有用上</p>
<p>外部碎片指内存中的某些空闲分区由于太小而难以利用</p>
<h3 id="1-单一连续分配"><a href="#1-单一连续分配" class="headerlink" title="1. 单一连续分配"></a>1. 单一连续分配</h3><ul>
<li><p>介绍</p>
<p>内存被分为系统区和用户区；系统区用于存放操作系统相关数据，用户区用于存放用户进 程相关数据</p>
</li>
<li><p>图示</p>
</li>
</ul>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713195680.png" alt="img" style="zoom:100%;">

<ul>
<li>特点：内存中只能有一道用户程序，用户程序独占整个用户区</li>
<li>优点：实现简单，无外部碎片</li>
<li>缺点：只能用于单用户、单系统的操作系统中，有内部碎片</li>
</ul>
<h3 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2. 固定分区分配"></a>2. 固定分区分配</h3><p>(1) 介绍</p>
<p>i. 将整个用户区划分成若干个固定大小的分区，在每个分区中只装入一道作业，某个作业 独占一个固定分区</p>
<p>ii. 固定分区分配分为分区大小相等和分区大小不相等</p>
<p>(2) 图示</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132006159.png" alt="img" style="zoom:80%;">

<p>(3) 特点：无外部碎片，有内部碎片</p>
<p>(4) 需要使用分区说明表实现各个分区的分配与回收</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132009447.png" alt="img" style="zoom:80%;">

<h3 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3. 动态分区分配"></a>3. 动态分区分配</h3><p>(1) 介绍</p>
<p>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使 分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的</p>
<p>(2) 系统使用空闲分区表和空闲分区链记录内存的使用情况</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132015603.png" alt="img" style="zoom:80%;">

<p>(3) 当一个作业装入内存时，按照动态分区分配算法，从空闲分区表/链中选出一个分区分配给 该作业</p>
<p>(4) 根据动态分区分配算法算得进程5(4MB)应将分区1分配给该进程</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132020810.png" alt="img" style="zoom:80%;">

<p>(5) 其余几种情况</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132026498.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132028740.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132031463.png" alt="img" style="zoom:80%;">

<p>(6) 特点：无内部碎片，有外部碎片</p>
<p>(7) 拼凑技术：将原本不相邻的空闲分区合并成一个更大的空闲分区，用于解决碎片分区不满 足进程的需求的问题</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132041224.png" alt="img" style="zoom:80%;">

<h2 id="四、动态分区分配算法"><a href="#四、动态分区分配算法" class="headerlink" title="四、动态分区分配算法"></a>四、动态分区分配算法</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132046314.png" alt="img" style="zoom:80%;">

<h3 id="1-首次适应算法"><a href="#1-首次适应算法" class="headerlink" title="1. 首次适应算法"></a>1. 首次适应算法</h3><p>思想：空闲分区以地址递增的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132051978.png" alt="img" style="zoom:80%;">

<p>注意：链表中的结点即使大小发生变化后，结点顺序依旧不变，因为结点只按照地址排序</p>
<h3 id="2-最佳适应算法"><a href="#2-最佳适应算法" class="headerlink" title="2. 最佳适应算法"></a>2. 最佳适应算法</h3><p>思想：空闲分区以容量递增的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132059944.png" alt="img" style="zoom:80%;">

<p>注意：链表中的结点当大小发生变化之后，需要调整结点顺序</p>
<h3 id="3-最坏适应算法"><a href="#3-最坏适应算法" class="headerlink" title="3. 最坏适应算法"></a>3. 最坏适应算法</h3><p>思想：空闲分区以容量递减的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选择最大的分区进行分配，会导致较大的连续空间被迅速用完，当之后有大进程 到达时，无内存空间可分配</p>
<h3 id="4-邻近适应算法"><a href="#4-邻近适应算法" class="headerlink" title="4. 邻近适应算法"></a>4. 邻近适应算法</h3><p>思想：空闲分区以地址递增的次序排列，每次分配内存空间时从上次查找结束的位置开始查找 空闲分区表/链，找到大小能满足要求的第一个空闲分区</p>
<h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132110832.png" alt="img" style="zoom:80%;">

<h2 id="五、基本分页存储管理"><a href="#五、基本分页存储管理" class="headerlink" title="五、基本分页存储管理"></a>五、基本分页存储管理</h2><p>连续分配：为进程分配的是连续的内存空间<br>非连续分配：为进程分配的是分散的内存空间，可以将进程分成几个部分，分散的放入空闲区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132118893.png" alt="img" style="zoom:80%;">

<h3 id="1-页框"><a href="#1-页框" class="headerlink" title="1. 页框"></a>1. 页框</h3><p>将内存空间分为一个个大小相等的分区，每个分区就是一个页框，<br>每个页框有一个编号，即页框号，页框号从0开始</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132142593.png" alt="img" style="zoom:80%;">

<h3 id="2-页面"><a href="#2-页面" class="headerlink" title="2. 页面"></a>2. 页面</h3><p>将进程的逻辑地址空间分为与页框大小相等的一个个部分，<br>每个部分称为一个页或页面，每个页面都有一个编号，即页号，页号从0开始</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132138965.png" alt="img" style="zoom:80%;">

<h3 id="3-分页存储"><a href="#3-分页存储" class="headerlink" title="3. 分页存储"></a>3. 分页存储</h3><p>(1) 操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中， 即进程的页面与内存的页框有一一对应的关系</p>
<p>(2) 各个页面无需连续存放，可以放到不相邻的各个页框中</p>
<p>(3) 页框不能太大，否则可能会产生过大的内部碎片造成浪费</p>
<h3 id="4-页表"><a href="#4-页表" class="headerlink" title="4. 页表"></a>4. 页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，需要为每个进程建立一张页表<br>(页表通常存在于进程控制块PCB中)</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132147655.png" alt="img" style="zoom:80%;">

<p>(1) 页表项连续存放，因此页号可以是隐藏的，不占用存储空间 (类比数组)</p>
<p>(2) 页表记录的只是内存块号，而不是内存块的物理起始地址</p>
<p>n号内存块的物理起始地址 = n * 内存块大小</p>
<h3 id="5-页号、页内偏移量的计算"><a href="#5-页号、页内偏移量的计算" class="headerlink" title="5. 页号、页内偏移量的计算"></a>5. 页号、页内偏移量的计算</h3><p>(1) 问题描述：在某计算机系统中，页面大小是50B；某进程逻辑地址空间大小为200B，则逻 辑地址110对应的页号、页内偏移量是多少？</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132158205.png" alt="img" style="zoom:80%;">

<p>(2) 计算方法：</p>
<p>页号 = 逻辑地址 / 页面长度</p>
<p>页内偏移量 = 逻辑地址 % 页面长度</p>
<p>物理地址 = 页号对应页框的起始地址 + 页内偏移量</p>
<p>页号对应页框的起始地址 = 根据页号查页表得到的页框号 * 页框大小</p>
<p>(3) 计算结果：</p>
<p>页号 = 110 / 50 = 2</p>
<p>页内偏移量 = 110 % 50 = 10</p>
<h3 id="6-逻辑地址结构"><a href="#6-逻辑地址结构" class="headerlink" title="6. 逻辑地址结构"></a>6. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132204229.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132218741.png" alt="img" style="zoom:80%;">

<h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器(PTR) ，存放页表在内存中的起始地址F和页表长度M。</p>
<p>进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:页面大小是2的整数幂</p>
<p>例子：</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829150011013.png" alt="image-20210829150011013" style="zoom:80%;">

<h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829150345182.png" alt="image-20210829150345182" style="zoom:80%;">

<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在大量的循环)</p>
<p>空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。( 因为很多数据在内存中都是连续存放的)</p>
<p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p>
<h4 id="什么是快表？"><a href="#什么是快表？" class="headerlink" title="什么是快表？"></a>什么是快表？</h4><p>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829151013541.png" alt="image-20210829151013541" style="zoom:80%;">

<p>小结：</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829151227125.png" alt="image-20210829151227125" style="zoom:80%;">

<h2 id="六、基本分段存储管理"><a href="#六、基本分段存储管理" class="headerlink" title="六、基本分段存储管理"></a>六、基本分段存储管理</h2><p>与分页最大的区别：进程所划分的基本单位不同 (各段的大小可以不同)</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>(1) 进程按照自身的逻辑关系划分为若干个段，每段都有一个段名，每段从0开始编址</p>
<p>(2) 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>
<h3 id="2-逻辑地址结构"><a href="#2-逻辑地址结构" class="headerlink" title="2. 逻辑地址结构"></a>2. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713222756.png" alt="img" style="zoom:80%;">

<h3 id="3-段表"><a href="#3-段表" class="headerlink" title="3. 段表"></a>3. 段表</h3><p>记录各个逻辑段与实际的物理位置存放地址的对应关系</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132249865.png" alt="img" style="zoom:80%;">

<h3 id="4-知识回顾-1"><a href="#4-知识回顾-1" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132253814.png" alt="img" style="zoom:150%;">

<h2 id="七、段页式管理方式"><a href="#七、段页式管理方式" class="headerlink" title="七、段页式管理方式"></a>七、段页式管理方式</h2><p>段页式管理 = 分段 + 分页</p>
<h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>(1) 将进程按照逻辑模块分段，再将各段分页 (如每个页面4KB)</p>
<p>(2) 将内存空间按照4KB划分成多个页框</p>
<p>(3) 将进程的各页面分别装入对应的页框中</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132308534.png" alt="img" style="zoom:80%;">

<h3 id="2-段表、页表"><a href="#2-段表、页表" class="headerlink" title="2. 段表、页表"></a>2. 段表、页表</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132314153.png" alt="img" style="zoom:80%;">

<h3 id="3-逻辑地址结构"><a href="#3-逻辑地址结构" class="headerlink" title="3. 逻辑地址结构"></a>3. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132322294.png" alt="img" style="zoom:80%;">

<h3 id="4-知识回顾-2"><a href="#4-知识回顾-2" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132328319.png" alt="img" style="zoom:80%;">]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="布隆过滤器的理解"><a href="#布隆过滤器的理解" class="headerlink" title="布隆过滤器的理解"></a>布隆过滤器的理解</h1><h2 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h2><p>黑名单问题：</p>
<p>需求大致为：100亿个url为黑名单，搜索公司想让用户搜索黑名单里的url时，不给用户显示。如果url输入这100亿黑名单则返回True，否则返回False。假设每个url64kb。</p>
<p>如果使用hashset实现该功能的话，需要6400亿字节（640G）的内存。浪费大量空间，不现实。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>算法：</p>
<blockquote>
<p>准备k个相互独立哈希函数，长度为n的比特数组，比特数组的每个比特位初始化为0。</p>
<p>存入流程：</p>
<ol>
<li>使用k个哈希函数，计算某个url的哈希值，使用哈希值对n取模。<strong>idx = hash(url)%n</strong></li>
<li>将相对的比特数组位置描黑。 比特数组【idx】 = 1</li>
</ol>
<p>while k个哈希函数：</p>
<p>​    idx = hash(url) % n</p>
<p>​    比特数组【idx】 = 1</p>
<p>查询流程：</p>
<p>使用k个哈希函数，计算哈希值，对n取模，如果所有位置都为1，则该url属于这100亿黑名单。</p>
</blockquote>
<p>重要公式：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317223869.png" alt="img " style="zoom:150%;">

<p>p为预计的失误率。n为样本个数。m为最优比特位个数。</p>
<p> Hash 函数个数选取最优数目：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317394641.png" alt="img" style="zoom:150%;">

<p>m为比特位个数，n为样本个数，k为哈希函数个数</p>
<p>在确定m和k后计算失误率：</p>
<center>p = (1-e<sup>(-kn/m)</sup>)<sup>k</sup>​</center>



]]></content>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希</title>
    <url>/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么，我们应该怎样做呢？</p>
<h3 id="落伍的方式"><a href="#落伍的方式" class="headerlink" title="落伍的方式"></a>落伍的方式</h3><blockquote>
<p>原始的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上。</p>
<p>举例说明，仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的key，假设图片名称是不重复的，那么，我们可以使用如下公式，计算出图片应该存放在哪台服务器上。</p>
<p><strong>hash（图片名称）% N</strong></p>
</blockquote>
<p><font color="red">哈希函数最重要的一个特征：无限的输入经过哈希函数得到的哈希值均匀的分布在有限的输出域上。</font></p>
<p><font color="red">假设某哈希函数输出16位数据，可以截取前八位和后八位作为两个相互独立的哈希函数，假设这两个哈希函数为a和b，则a+1b,a+2b,a+3b….也是相互独立的，我们可以以此方式拼接处无数个相互独立的哈希函数。</font></p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830194520098.png" alt="image-20210830194520098" style="zoom:60%;">

<h3 id="上述方法存在的问题："><a href="#上述方法存在的问题：" class="headerlink" title="上述方法存在的问题："></a>上述方法存在的问题：</h3><blockquote>
<p>如果3台缓存服务器已经不能满足我们的缓存需求，怎么办呢？多增加两台缓存服务器，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。</p>
</blockquote>
<h2 id="一致性哈希算法的基本概念"><a href="#一致性哈希算法的基本概念" class="headerlink" title="一致性哈希算法的基本概念"></a>一致性哈希算法的基本概念</h2><p>一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对2^32取模，什么意思呢？</p>
<p>首先，我们把二的三十二次方想象成一个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195432751.png" alt="image-20210830195432751" style="zoom:80%;">

<p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p>
<p>我们把这个由2的32次方个点组成的圆环称为hash环。</p>
<p>那么，一致性哈希算法与上图中的圆环有什么关系呢？</p>
<blockquote>
<p>仍然以之前描述的场景为例，假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p>
</blockquote>
<blockquote>
<p><strong>hash（服务器A的IP地址） %  2^32</strong></p>
</blockquote>
<p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意:</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/020717_1707_3.png" alt="img " style="zoom:150%;">

<p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中</p>
<p><strong>hash（服务器B的IP地址） %  2^32</strong></p>
<p><strong>hash（服务器C的IP地址） %  2^32</strong></p>
<p>通过上述方法，可以将服务器B与服务器C映射到上图中的hash环上，示意图如下</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195650374.png" alt="image-20210830195650374" style="zoom:40%;">

<p>假设3台服务器映射到hash环上以后如上图所示（当然，这是理想的情况)</p>
<p>好了，到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环上，那么使用同样的方法，我们也可以将需要缓存的对象映射到hash环上。</p>
<p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。</p>
<blockquote>
<p> <strong>hash（图片名称） %  2^32</strong></p>
</blockquote>
<p>映射后的示意图如下，下图中的橘黄色圆形表示图片</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195804698.png" alt="image-20210830195804698" style="zoom:40%;">

<p>好了，现在服务器与图片都被映射到了hash环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的图片将会被缓存到服务器A上，为什么呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器就是A服务器，所以，上图中的图片将会被缓存到服务器A上，如下图所示。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195840410.png" alt="image-20210830195840410" style="zoom:33%;">

<p>一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p>
<p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195944118.png" alt="image-20210830195944118" style="zoom:33%;">

<p>1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p>
<h2 id="一致性哈希算法的优点"><a href="#一致性哈希算法的优点" class="headerlink" title="一致性哈希算法的优点"></a>一致性哈希算法的优点</h2><p>假设，服务器B出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以后示意图如下。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200147236.png" alt="image-20210830200147236" style="zoom:33%;">

<p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200208142.png" alt="image-20210830200208142" style="zoom:33%;">

<p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点，如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p>
<h2 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h2><p>在介绍一致性哈希的概念时，我们理想化的将3台服务器均匀的映射到了hash环上，如下图所示</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200311037.png" alt="image-20210830200311037" style="zoom:30%;">

<p>在实际的映射中，服务器可能会被映射成如下模样。<font color="red">哈希函数在大数据下保证大致的平均（并不是绝对平均）。</font></p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200339888.png" alt="image-20210830200339888" style="zoom:33%;">

<p>如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上，如下图所示。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200448650.png" alt="image-20210830200448650" style="zoom:33%;">

<p>如上图所示就造成了服务器A负责大量工作，而服务器B和C则很闲。没有达到负载均衡的目的。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>由于我们只有3台服务器，当我们把服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，当hash环偏斜以后，缓存往往会极度不均衡的分布在各服务器上。</p>
<p>如果想要均衡的将缓存分布到3台服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，但是，真实的服务器资源只有3台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash环如下。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200726308.png" alt="image-20210830200726308" style="zoom:33%;">

<p>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</p>
<p>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p>
<p><font color="red">保存两个字典：每个服务器对应的多个虚拟节点；每个虚拟节点相对应的服务器。</font></p>
]]></content>
      <tags>
        <tag>一致性哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>PV操作--经典问题分析</title>
    <url>/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、多生产者-多消费者问题"><a href="#一、多生产者-多消费者问题" class="headerlink" title="一、多生产者 - 多消费者问题"></a>一、多生产者 - 多消费者问题</h1><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><blockquote>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610154557852.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a>2 问题分析</h2><ol>
<li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。<br>多生产者-多消费者问题关系分析如下：</p>
<blockquote>
<p>互斥关系： 对缓冲区（盘子）的访问要互斥地进行<br>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果</li>
</ol>
</blockquote>
</li>
</ol>
<p>注意：“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</p>
<ol start="2">
<li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p>
<blockquote>
<p>由以上的同步、互斥关系分析，将多生产者-多消费者问题描绘出图形：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155007683.png" alt="img" style="zoom:80%;"></blockquote>
</li>
<li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。<br>（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）<br><strong>本问题中信号量设置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">semaphore plate = 1;    //盘子中还可以放多少个水果</span><br></pre></td></tr></table></figure></li>
<li><p>模型实现：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155634180.png" alt="img" style="zoom:80%;"></li>
</ol>
<blockquote>
<p>dad：先准备一个苹果，放苹果之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将苹果放入进去（V一下苹果，数量+1）<br>mom：先准备一个橘子，放橘子之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将橘子放入进去（V一下橘子，数量+1）<br>daughter：拿苹果之前，先判断盘子里有没有苹果（P一下苹果，若没有苹果，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）<br>son：拿橘子之前，先判断盘子里有没有橘子（P一下橘子，若没有橘子，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）</p>
</blockquote>
<blockquote>
<p><strong>以下实现了所有进程之间的同步关系：</strong></p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161040503.png" alt="img" style="zoom:80%;">

<p>还需要实现各个进程对盘子（缓冲区）的互斥访问：<br>就是所有进程对盘子进行PV操作，即加锁和解锁的过程</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161420106.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">  semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">  semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">  semaphore plate = 1;    //盘子中还可以放多少个水果</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dad</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个苹果;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(apple);       //允许女儿进程取苹果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mom</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个橘子;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(orange);        //允许儿子进程取橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">daughter</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(apple);</span><br><span class="line">           P(mutex);</span><br><span class="line">          从盘子中取出苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">son</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(orange);</span><br><span class="line">           P(mutex);</span><br><span class="line">           从盘子中取出橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、吸烟者问题"><a href="#二、吸烟者问题" class="headerlink" title="二、吸烟者问题"></a>二、吸烟者问题</h1><h2 id="1、问题描述-1"><a href="#1、问题描述-1" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉，但是要卷起并抽掉一支烟，需要三种材料：烟草、纸、胶水。三个抽烟者中，每一个第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者无限提供三种材料，供应者每次将两种材料放桌子上，拥有剩下材料的抽烟者卷一支烟并抽掉它，并给供应者一个信号完成了，供应者就会把另外两种材料再放桌子上，这个过程一直重复（三个抽烟者轮流抽烟）<br><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319181813857.png" alt="img" style="zoom:80%;"></p>
<h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><h3 id="1、关系分析。"><a href="#1、关系分析。" class="headerlink" title="1、关系分析。"></a>1、关系分析。</h3><p>供应者与三个抽烟者分别是同步关系。由于抽烟者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）</p>
<h3 id="2、整理思路。"><a href="#2、整理思路。" class="headerlink" title="2、整理思路。"></a>2、整理思路。</h3><p>四个进程，供应者作为生产者向三个抽烟者提供材料</p>
<h3 id="3、信号量设置"><a href="#3、信号量设置" class="headerlink" title="3、信号量设置"></a>3、信号量设置</h3><p>信号量offer1、offer2、offer3分别表示烟草和纸组合，烟草和胶水组合，胶水和纸组合。信号量finish表示抽烟完成信号</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183414832.png" alt="img" style="zoom:80%;">

<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183610850.png" alt="img" style="zoom:80%;">

<h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319185437858.png" alt="img" style="zoom:80%;">

<h1 id="二、读者-写者问题"><a href="#二、读者-写者问题" class="headerlink" title="二、读者-写者问题"></a>二、读者-写者问题</h1><h2 id="1、问题描述-2"><a href="#1、问题描述-2" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程 和其他进程（写进程或读进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者再完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320135112282.png" alt="img" style="zoom:80%;">

<h2 id="2、问题分析-1"><a href="#2、问题分析-1" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182746487.png" alt="img" style="zoom:80%;">

<h2 id="3、实现-1"><a href="#3、实现-1" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182822669.png" alt="img" style="zoom:80%;">

<p>写优先：</p>
<p><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182907776.png" alt="img"></p>
<h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由Dijkstra提出并解决的哲学家进餐问题（The Dinning Philosophers Problems）是典型的同步问题。五个哲学家共用一张圆桌，分别坐在周围的五把椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有当他拿到两只筷子时，才能进餐，进餐完毕，放下筷子，继续思考。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用记录型信号量解决哲学家进餐问题，经分析，筷子是邻接资源，在一段时间内只允许一位哲学家使用，可以用一个互斥型信号量表示一只筷子，由这个五个信号量构成信号量数组。<br>semaphore chopstick[5] = {1, 1, 1, 1, 1};<br>所有信号量初始为1，第i位哲学家的活动可描述为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"> 	p(chopstick[i]);  // 申请左边的一只筷子</span><br><span class="line"> 	p(chopstick[(i+1)%5]];  // 申请右边筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	eat</span><br><span class="line"> 	...</span><br><span class="line"> 	v(chopstick[i]);  // 释放左边的一只筷子</span><br><span class="line"> 	v(chopstick[(i+1)%5];  // 释放右边的筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	think</span><br><span class="line"> 	...</span><br><span class="line">&#125; <span class="keyword">while</span> (True);</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>问题</strong>：<br> 哲学家饥饿时总是先拿起左边的筷子，之后拿起右边的筷子，成功后便可进餐。进餐后又放下左边的筷子，再放下右边的筷子。显然不会有两个相邻的哲学家同时进餐，有可能引起<strong>死锁</strong>：即每一个哲学家都拿起左边的筷子，当他们拿右边筷子，便会无限等待。</font></p>
<p><strong>共有三种解决办法：</strong></p>
<h2 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h2><ul>
<li><p><strong>利用and型信号量机制</strong>：仅当哲学家左右两只筷子均可用时，才允许他拿起筷子进餐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>另一种方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, mutex = 1; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(mutex);  // 申请临界资源</span><br><span class="line">	p(chopstick[i]);  // 拿左</span><br><span class="line">	p(chopstick[(i+1)%5]);  // 拿右</span><br><span class="line">	v(mutex);  // 释放临界资源</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>至多允许有<strong>四位哲学家</strong>同时去拿左边筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放他的两只筷子，从而使更多的哲学家能够进餐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, L = 4; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(L);</span><br><span class="line">	p(chopstick[i]);</span><br><span class="line">	p(chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(L);</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
<li><p>规定奇数号哲学家先拿起左边筷子，然后在去拿右边筷子，偶数号相反。按此规定，将是1,2号哲学家竞争1号筷子，3,4竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后才去竞争偶数号筷子，最后总有人获得两只筷子。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (i % 2 == 0):</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈TCP</title>
    <url>/2021/09/01/%E6%B5%85%E8%B0%88TCP/</url>
    <content><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><ol>
<li><p>TCP是面向连接(虚连接)的传输层协议。</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接 只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。可靠有序，不丢不重</p>
</li>
<li><p>4.TCP提供全双工通信。</p>
<ul>
<li>发送缓存准备发送的数据&amp;已发送但尚未收到确认的数据</li>
<li>接收缓存按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</li>
</ul>
</li>
<li><p>TCP面向字节流口。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
<p>流:流入到进程或从进程流出的字节序列。.</p>
</li>
</ol>
<p>TCP传输数据是随机切割数据的</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/2020063020421472.png" alt="img " style="zoom:70%;">

<h2 id="TCP报文段的首部"><a href="#TCP报文段的首部" class="headerlink" title="TCP报文段的首部"></a>TCP报文段的首部</h2><p>注释：见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号<br>确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据<br>偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630210441410.png" alt="img" style="zoom:80%;"></p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630212601599.png" alt="img" style="zoom:80%;">

<p>窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据<br>紧急指针就是告诉TCP从哪里到哪里是紧急数据</p>
<h3 id="TCP的六个控制位"><a href="#TCP的六个控制位" class="headerlink" title="TCP的六个控制位"></a>TCP的六个控制位</h3><p>紧急位URG: URG=1时， 标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p>
<p>确认位ACK: ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p>
<p>推送位PSH: 就是接收端的URG，将PSH=1的数据尽快接收。注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机</p>
<p>复位RST: RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p>
<p>同步位SYN： A和B主机要建立连接，就A先发一个报文，其中SYN=1；B收到之后也回复一个SYN=1的报文，代表接受连接；表明此报文段是一个连接请求/连接接受报文。</p>
<p>终止位FIN; FIN=1时， 表明此报文段发送方数据己发完，要求释放连接。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>SYN=1：(A)要建立连接了！<br>seq=x（随机）：因为还没有数据，所以写什么都无所谓第<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:二段的意思是<br>SYN=1：我(B)同意你(A)建立连接！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=y（随机）：因为还没有数据，所以写什么都无所谓<br>ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据第三<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:三段的意思是<br>SYN=0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p>
<p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630213814996.png" alt="img" style="zoom:80%;"></p>
<h4 id="TCP三次握手特定导致的SYN洪泛攻击"><a href="#TCP三次握手特定导致的SYN洪泛攻击" class="headerlink" title="TCP三次握手特定导致的SYN洪泛攻击"></a>TCP三次握手特定导致的SYN洪泛攻击</h4><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630214925395.png" alt="img" style="zoom:80%;">

<p><font color="red">SYN洪泛攻击，解决方式通过SYN cookie，//TODO</font></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第二段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第三段的意思是:FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第四段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据<br><font color="red">为什么需要等待计时2MSL？</font><br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630215522825.png" alt="img" style="zoom:80%;">

<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><blockquote>
<p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
</blockquote>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>CP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630220542461.png" alt="img" style="zoom:75%;">

<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221424853.png" alt="img" style="zoom:80%;">

<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中4、5、6丢失，7、8到达，但仍然请求发送的数据序号是4。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221636424.png" alt="img" style="zoom:75%;">

<h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630222205619.png" alt="img" style="zoom:75%;">

<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。<br>接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了<br>接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/202006302226272.png" alt="img" style="zoom:80%;"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。<br>但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象<br>解决方法：使用计时器<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630223616929.png" alt="img" style="zoom:75%;"></p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>流量控制是对单独一个来说的，拥塞控制是一群</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630224242515.png" alt="img" style="zoom:75%;">

<h3 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h3><p>这里虽然是四种算法，但是通常是两两结合进行使用</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232411944.png" alt="img" style="zoom:75%;">

<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。<br>之后一段都是线性增长，每次增加1，直至达到网络拥塞状态<br>瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）<br>重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232910475.png" alt="img" style="zoom:75%;"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。<br>不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630233701386.png" alt="img " style="zoom:75%;"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存管理</title>
    <url>/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><h3 id="1-传统存储管理方式的缺点"><a href="#1-传统存储管理方式的缺点" class="headerlink" title="1. 传统存储管理方式的缺点"></a>1. 传统存储管理方式的缺点</h3><p>连续分配与非连续分配都属于传统存储管理方式</p>
<p>(1) 一次性</p>
<p>作业必须一次性全部装入内存后才能开始运行</p>
<p>(2) 驻留性</p>
<p>一旦作业被装入内存，就会一直驻留在内存中直至作业运行结束；但事实上，一个时间段内，只需要作业的一小部分数据即可正常运行</p>
<h3 id="2-虚拟内存的定义"><a href="#2-虚拟内存的定义" class="headerlink" title="2. 虚拟内存的定义"></a>2. 虚拟内存的定义</h3><p>(1) 程序装入内存时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存</p>
<p>(2) 程序运行过程中，所要访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>
<p>(3) 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>
<p>(4) 使得用户感觉有一个比实际内存大得多的内存，实际上物理内存大小并未改变，只是在逻 辑上进行了扩充，这就是虚拟内存</p>
<h3 id="3-虚拟内存的特征"><a href="#3-虚拟内存的特征" class="headerlink" title="3. 虚拟内存的特征"></a>3. 虚拟内存的特征</h3><p>(1) 多次性 ：作业被分成多次调入内存</p>
<p>(2) 对换性：作业在运行过程中，可以将作业换入、换出</p>
<p>(3) 虚拟性：从逻辑上扩充了内存的容量，使用户感觉有一个更大的内存</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4.  知识回顾"></a>4.  知识回顾</h3><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132643299.png" alt="img" style="zoom:67%;">

<h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>请求分页管理方式与基本分页管理的主要区别在于增加了请求调页和页面置换两个功能</p>
<h3 id="1-页表机制"><a href="#1-页表机制" class="headerlink" title="1. 页表机制"></a>1. 页表机制</h3><p>(1) 为了实现请求调页，操作系统需要通过状态位知道每个页面是否已经调入内存；如果还没 有调入，也需要知道该页面在外存中存放的位置</p>
<p>(2) 为了实现页面置换，操作系统需要决定将哪个页面换出到外存：有的页面没有被修改过， 就不必浪费时间写回外存；有的页面被修改过，就需要将外存中的旧数据覆盖；因此，操 作系统还需要记录每个页面是否被修改过的信息<br><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132658444.png" alt="img" style="zoom:110%;"></p>
<h3 id="2-缺页中断机构"><a href="#2-缺页中断机构" class="headerlink" title="2. 缺页中断机构"></a>2. 缺页中断机构</h3><p>(1) 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系 统的缺页中断处理程序处理中断；此时缺页的进程阻塞，放入阻塞队列中，调页完成后再 将其唤醒，放回就绪队列</p>
<p>(2) 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相 应的页表项</p>
<p>(3) 如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修 改过，则要将其写回外存；未修改过的页面不用写回外存</p>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132707611.png" alt="img" style="zoom:80%;">

<h2 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h2><p>使用页面置换算法决定将哪个页面换出，好的页面置换算法应当追求更少的缺页率，即换入、换出 的次数尽可能的少</p>
<h3 id="1-最佳置换算法-OPT"><a href="#1-最佳置换算法-OPT" class="headerlink" title="1. 最佳置换算法(OPT)"></a>1. 最佳置换算法(OPT)</h3><p>每次选择淘汰的页面是以后永不使用或者最长时间内不再被访问的页面，以保证最低的缺页率</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132717866.png" alt="img" style="zoom:67%;">

<p>操作系统无法预判页面访问顺序，故最佳置换算法无法实现</p>
<h3 id="2-先进先出置换算法-FIFO"><a href="#2-先进先出置换算法-FIFO" class="headerlink" title="2. 先进先出置换算法(FIFO)"></a>2. 先进先出置换算法(FIFO)</h3><p>每次选择淘汰的页面是最早进入内存的页面</p>
<p>实现方法：每次向内存中调入页面时，将页面添加到一个队列的队尾，需要换出页面时换出队 头的页面即可，队列的最大长度取决于内存块的个数</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132724177.png" alt="img" style="zoom:80%;">

<p>注意：FIFO算法会产生Belady异常，即为进程分配的内存块增多时，缺页次数不减反增的现象，因此，FIFO算法性能较差</p>
<h3 id="3-最近最久未使用置换算法-LRU"><a href="#3-最近最久未使用置换算法-LRU" class="headerlink" title="3. 最近最久未使用置换算法(LRU)"></a>3. 最近最久未使用置换算法(LRU)</h3><p>每次选择淘汰的页面是最近最久未使用的页面</p>
<p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的 时间t，当需要淘汰一个页面时，选择现有页面中t值最大的</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132730300.png" alt="img" style="zoom:150%;">

<h3 id="4-最不常用算法（LFU）"><a href="#4-最不常用算法（LFU）" class="headerlink" title="4.最不常用算法（LFU）"></a>4.最不常用算法（LFU）</h3><p>当缺页中断时，选择访问次数最少的那个页面，淘汰之<br>这样新页很吃亏啊<br>取决于程序访问特征</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132735208.png" alt="img" style="zoom:150%;">







]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>03地支三合局与相刑相害</title>
    <url>/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/</url>
    <content><![CDATA[<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902192840745.png" alt="image-20210902192840745" style="zoom:67%;">

<blockquote>
<p>丑土子水 ===&gt; 合克</p>
<p>寅木亥水 ===&gt; 合生</p>
<p>卯木戌土 ===&gt; 合克</p>
<p>辰土酉金 ===&gt; 合生</p>
<p>午火未土 ===&gt; 合生</p>
<p>巳火申金 ===&gt; 合克（在六爻中以合为主）巳与申以合论</p>
</blockquote>
<h2 id="地支三合局"><a href="#地支三合局" class="headerlink" title="地支三合局"></a>地支三合局</h2><blockquote>
<p>寅午戌合火局              寅（木）   午（火） 戌（土）   火局</p>
<p>申子辰合水局              申（金）   子（水） 辰（土）   水局</p>
<p>亥卯未合木局</p>
<p>巳酉丑合金局</p>
</blockquote>
<h2 id="地支相刑"><a href="#地支相刑" class="headerlink" title="地支相刑"></a>地支相刑</h2><blockquote>
<p>三刑</p>
<p>寅巳申</p>
<p>丑未戌</p>
</blockquote>
<blockquote>
<p>两刑</p>
<p>寅刑巳                    巳刑申</p>
<p>申刑寅                    丑刑未</p>
<p>未刑戌                    戌刑丑</p>
<p>子刑卯                    卯刑子   ====&gt; 相互刑     一般乱搞男女关系</p>
<p>辰午酉亥 ===&gt; 自己刑自己，自己伤害自己</p>
<p>三刑考虑的较多，两刑考虑的较少。</p>
</blockquote>
<h2 id="地支相害"><a href="#地支相害" class="headerlink" title="地支相害"></a>地支相害</h2><blockquote>
<p>子未相害</p>
<p>丑午相害</p>
<p>寅巳相害</p>
<p>卯辰相害</p>
<p>申亥相害</p>
<p>酉戌相害</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902200048607.png" alt="image-20210902200048607" style="zoom:67%;">

<p>举例：</p>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902200856012.png" alt="image-20210902200856012" style="zoom:50%;">

<blockquote>
<p>婚外恋：子（妻子）  丑（丈夫） 未（小三），丑未相冲，子未相害。小三向丈夫发起进攻，则害了妻子。</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902202953530.png" alt="image-20210902202953530" style="zoom:50%;">

<blockquote>
<p>午丑相害（美国侵略朝鲜），敌人的敌人就是朋友！</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902203056376.png" alt="image-20210902203056376" style="zoom:50%;">

<blockquote>
<p>敌人的朋友就是敌人。</p>
</blockquote>
<h2 id="地支与生肖"><a href="#地支与生肖" class="headerlink" title="地支与生肖"></a>地支与生肖</h2><blockquote>
<p>子    丑    寅    卯    辰    巳    午    未    申    酉    戌    亥</p>
<p>鼠    牛    虎    兔    龙    蛇    马    羊    猴    鸡    狗    猪</p>
</blockquote>
<h2 id="地支与时辰"><a href="#地支与时辰" class="headerlink" title="地支与时辰"></a>地支与时辰</h2><img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902203417019.png" alt="image-20210902203417019" style="zoom:67%;">

<p>P11</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>周易基础及其应用</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>04长生掌决</title>
    <url>/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">金</th>
<th align="center">木</th>
<th align="center">火</th>
<th align="center">水土</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">长生</font></td>
<td align="center"><font color="yellow">巳</font></td>
<td align="center"><font color="yellow">亥</font></td>
<td align="center"><font color="yellow">寅</font></td>
<td align="center"><font color="yellow">申</font></td>
</tr>
<tr>
<td align="center">沐浴</td>
<td align="center">午</td>
<td align="center">子</td>
<td align="center">卯</td>
<td align="center">酉</td>
</tr>
<tr>
<td align="center">冠带</td>
<td align="center">未</td>
<td align="center">丑</td>
<td align="center">辰</td>
<td align="center">戌</td>
</tr>
<tr>
<td align="center">临官</td>
<td align="center">申</td>
<td align="center">寅</td>
<td align="center">巳</td>
<td align="center">亥</td>
</tr>
<tr>
<td align="center"><font color="red">帝旺</font></td>
<td align="center"><font color="yellow">酉</font></td>
<td align="center"><font color="yellow">卯</font></td>
<td align="center"><font color="yellow">午</font></td>
<td align="center"><font color="yellow">子</font></td>
</tr>
<tr>
<td align="center">衰</td>
<td align="center">戌</td>
<td align="center">辰</td>
<td align="center">未</td>
<td align="center">丑</td>
</tr>
<tr>
<td align="center">病</td>
<td align="center">亥</td>
<td align="center">巳</td>
<td align="center">申</td>
<td align="center">寅</td>
</tr>
<tr>
<td align="center">死</td>
<td align="center">子</td>
<td align="center">午</td>
<td align="center">酉</td>
<td align="center">卯</td>
</tr>
<tr>
<td align="center"><font color="red">墓</font></td>
<td align="center"><font color="yellow">丑</font></td>
<td align="center"><font color="yellow">未</font></td>
<td align="center"><font color="yellow">戌</font></td>
<td align="center"><font color="yellow">辰</font></td>
</tr>
<tr>
<td align="center"><font color="red">绝</font></td>
<td align="center"><font color="yellow">寅</font></td>
<td align="center"><font color="yellow">申</font></td>
<td align="center"><font color="yellow">亥</font></td>
<td align="center"><font color="yellow">巳</font></td>
</tr>
<tr>
<td align="center">胎</td>
<td align="center">卯</td>
<td align="center">酉</td>
<td align="center">子</td>
<td align="center">午</td>
</tr>
<tr>
<td align="center">养</td>
<td align="center">辰</td>
<td align="center">戌</td>
<td align="center">丑</td>
<td align="center">未</td>
</tr>
</tbody></table>
<blockquote>
<p>水土的十二长生一起，六爻就这么规定；命理中土是附在火上面。</p>
<p>在六爻中主要记住：长生，帝旺，墓，绝</p>
</blockquote>
<h2 id="金的记忆方法"><a href="#金的记忆方法" class="headerlink" title="金的记忆方法"></a>金的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223723589.png" alt="image-20210903223723589" style="zoom:70%;">

<h2 id="木的记忆方法"><a href="#木的记忆方法" class="headerlink" title="木的记忆方法"></a>木的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223819633.png" alt="image-20210903223819633" style="zoom:70%;">

<h2 id="火的记忆方法"><a href="#火的记忆方法" class="headerlink" title="火的记忆方法"></a>火的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223915736.png" alt="image-20210903223915736 " style="zoom:70%;">

<h2 id="水土的记忆方法"><a href="#水土的记忆方法" class="headerlink" title="水土的记忆方法"></a>水土的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223941093.png" alt="image-20210903223941093" style="zoom:70%;">

<h1 id="地支与节令"><a href="#地支与节令" class="headerlink" title="地支与节令"></a>地支与节令</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">春季</td>
<td align="center">立春</td>
<td align="center">正月</td>
<td align="center">建寅</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">惊蛰</td>
<td align="center">二月</td>
<td align="center">建卯</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">清明</td>
<td align="center">三月</td>
<td align="center">建辰</td>
</tr>
<tr>
<td align="center">夏季</td>
<td align="center">立夏</td>
<td align="center">四月</td>
<td align="center">建巳</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">芒种</td>
<td align="center">五月</td>
<td align="center">建午</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小暑</td>
<td align="center">六月</td>
<td align="center">建未</td>
</tr>
<tr>
<td align="center">秋季</td>
<td align="center">立秋</td>
<td align="center">七月</td>
<td align="center">建申</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">白露</td>
<td align="center">八月</td>
<td align="center">建酉</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">寒露</td>
<td align="center">九月</td>
<td align="center">建戌</td>
</tr>
<tr>
<td align="center">冬季</td>
<td align="center">立冬</td>
<td align="center">十月</td>
<td align="center">建亥</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">大雪</td>
<td align="center">十一月</td>
<td align="center">建子</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小寒</td>
<td align="center">十二月</td>
<td align="center">建丑</td>
</tr>
</tbody></table>
<blockquote>
<p>以上月份均为阴历</p>
</blockquote>
<p>子丑寅卯辰巳午未申酉戌亥</p>
<img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903225507640.png" alt="image-20210903225507640" style="zoom:50%;">

<img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903225638514.png" alt="image-20210903225638514" style="zoom:50%;">

<blockquote>
<p><font color="red">年以立春作为界限，立春以前按前一年算，立春以后按这一年算</font></p>
</blockquote>
<p>P12</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>周易基础及其应用</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>const修饰指针and引用</title>
    <url>/2021/09/08/const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88and%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="comment">// int&amp; v = int* const v</span></span><br><span class="line"><span class="comment">// const int&amp; v =  const int * const v </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>题目01</title>
    <url>/2021/09/11/%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构按照操作系统的分类，属于分时操作系统。<br>UNIX系统是一个多用户，多任务的分时操作系统。<br>UNIX的系统结构可分为三部分：<pre><code>操作系统内核（是UNIX系统核心管理和控制中心，在系统启动或常驻内存），
系统调用（供程序开发者开发应用程序时调用系统组件，包括进程管理，文件管理，设备状态等），
应用程序（包括各种开发工具，编译器，网络通讯处理程序等，所有应用程序都在Shell的管理和控制下为用户服务）。     
</code></pre>
UNIX系统大部分是由C语言编写的。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下4G虚拟地址空间的分布</title>
    <url>/2021/09/13/Linux%E4%B8%8B4G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>所编写的源代码并不是程序，从C代码（.c/.cpp)—-&gt;链接程序（.exe）是要经过以下几个过程才能真正的运行链接的；</p>
<p>C源程序—&gt;预编译处理（.c/.cpp）–&gt;编译，优化程序（.s）—&gt;汇编程序(.o)—&gt;链接(.exe)</p>
<p>在编译运行过程中，首先需要将程序存储到内存中才能调取运行，但是内存是有限的，不可能将所有的进程都放在内存中去，所以都会给给进程分配一个4G的虚拟地址空间存储数据，在进程运行时在映射到内存中去。</p>
<blockquote>
<p>windows下 4G的空间分布为 ：  用户态：内核态=1：1</p>
<p>Linux下    4G的空间分布为：   用户态：内核态=3：1  </p>
</blockquote>
<p>32位处理机 32 指计算机最多一次处理的比特位, 进程地址空间需要隔离，防止恶意的程序修改其他程序的内存数据，因此计算机中引入虚拟地址空间。4GB虚拟地址空间布局如下图所示</p>
<img src="/2021/09/13/Linux%E4%B8%8B4G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83/20181113112843119.png" alt="img" style="zoom:60%;">

<p>用户空间：</p>
<p>1、128M大小的不可访问区域（保留区）不可读、不可写</p>
<pre><code>  我们通常将申请的临时变量指针初始化时置为NULL，可以防止后续无意使用这个指针时出错，NULL=0X00，而保留区的数据不能访问。
</code></pre>
<p>2、.text代码段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">存储代码中的指令。一份代码是由数据和指令构成的，局部变量也属于指令，但是局部变量存储在栈上，代码运行时才在栈中预留好的区域中开辟</span><br></pre></td></tr></table></figure>

<p>3、.data段</p>
<pre><code>这个区域存储代码中的各种数据，包括全局变量，静态局部变量。且必须为已经初始化且初始化不为0的数据
</code></pre>
<p>4、.bss段</p>
<pre><code> 这个区域存储的也是代码中的各种数据，和.data不同的是，存储的是未初始化或者初始化了但为0 的数据（这个段在可执行文件中不占用空间）
</code></pre>
<p>5、堆</p>
<pre><code> 当我们需要申请一块连续且指定大小的内存块的动态内存时，需要在 堆中申请。并且需要手动申请，手动释放。不释放会造成内存泄漏
</code></pre>
<p>6、栈</p>
<pre><code>所有的局部变量存储在这里，函数的运行也需要栈的开辟，释放空间由系统完成
</code></pre>
<p>内核空间：</p>
<p>1、内存直接访问区（ZONE_DMA 大约16M）</p>
<blockquote>
<p>ZONE_DirectMemoryAccess(直接内存访问)可以加快磁盘和内存之间的数据交换，不需要经过CPU的寄存器，这是CPU可以去干别的事，大大增加了效率。</p>
</blockquote>
<p>2、ZONE_NORMAL（大约892M）</p>
<blockquote>
<p>内核中最重要最常用的部分，用于直接映射，PCB就在这里。</p>
</blockquote>
<p>3、ZONE_HIGHMEM(128M)</p>
<blockquote>
<p>高端内存，用于在内核中映射高于1GB的物理内存时使用，64位操作系统没有该段</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gdata1=<span class="number">10</span>;  <span class="comment">//.data</span></span><br><span class="line"><span class="keyword">int</span> gdata2=<span class="number">0</span>;   <span class="comment">//.bss</span></span><br><span class="line"><span class="keyword">int</span>  gdata3;    <span class="comment">//.bss</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata4=<span class="number">20</span>;  <span class="comment">//.data</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata5=<span class="number">0</span>;  <span class="comment">//.bss</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata6;     <span class="comment">//.bss</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ldata1=<span class="number">30</span>;  <span class="comment">//.text(普通的局部变量开始都为指令存在指令区，只有在运行编译时在栈上开辟空间存储)</span></span><br><span class="line">     <span class="keyword">int</span> ldata2=<span class="number">0</span>;   <span class="comment">//.text</span></span><br><span class="line">     <span class="keyword">int</span> ldata3;    <span class="comment">//.text</span></span><br><span class="line">     ststic <span class="keyword">int</span> ldata4=<span class="number">40</span>;  <span class="comment">//.data</span></span><br><span class="line">     <span class="keyword">static</span>  <span class="keyword">int</span>  ldata5=<span class="number">0</span>;  <span class="comment">//.bss</span></span><br><span class="line">     <span class="keyword">static</span>  <span class="keyword">int</span>  ldata6;    <span class="comment">//.bss</span></span><br><span class="line">      <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对sync.Map的理解</title>
    <url>/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="并发报错的map"><a href="#并发报错的map" class="headerlink" title="并发报错的map"></a>并发报错的map</h2><p>举例：一个goroutine一直读，一个goroutine一只写同一个键值，即即使读写的键不相同，而且map也没有”扩容”等操作，代码还是会报错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误信息是： <font color="red"><code>fatal error: concurrent map read and map write</code></font></p>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> 	 ...</span><br><span class="line">	hashWriting  = <span class="number">4</span> <span class="comment">// a goroutine is writing to the map</span></span><br><span class="line">	...</span><br><span class="line">) </span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	...</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// map是检查是否有另外线程修改h.flag来判断，是否有并发问题。</span></span><br><span class="line"><span class="comment">// 在更新map的函数里检查并发写</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">	throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">// 在读map的函数里检查是否有并发写</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">	throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go通过map结构体中的flags字段来管理并发。当程序试图修改map（赋新值、删除value或者清空map），flags字段的某一位会被设置为1：</p>
<p>hashWriting的值是4，并将相应的位设置为1。 ^是一个异或操作，如果两个操作数的位相反，则将对应位设置为1。</p>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/578e8ecd09367196eb5e37da0a608bb4.png" alt="img" style="zoom:67%;">

<p>然而，该标志位将在操作结束时被重置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// if another process is currently writing, throw error</span></span><br><span class="line">   <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// no one is writing, we can set now the flag</span></span><br><span class="line">   h.flags ^= hashWriting   <span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// flag reset</span></span><br><span class="line">   h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>底层结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装的线程安全的map</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// lock</span></span><br><span class="line">	mu Mutex</span><br><span class="line">	<span class="comment">// 实际是readOnly这个结构</span></span><br><span class="line">	<span class="comment">// 一个只读的数据结构，因为只读，所以不会有读写冲突。</span></span><br><span class="line">	<span class="comment">// readOnly包含了map的一部分数据，用于并发安全的访问。(冗余，内存换性能)</span></span><br><span class="line">	<span class="comment">// 访问这一部分不需要锁。</span></span><br><span class="line">	read atomic.Value <span class="comment">// readOnly 原子性</span></span><br><span class="line">	<span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line">	<span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line">	<span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line">	<span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></span><br><span class="line">	misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">	<span class="comment">// 如果Map.dirty有些数据不在m中，这个值为true</span></span><br><span class="line">	amended <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An entry is a slot in the map corresponding to a particular key.</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">	p unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readOnly中<code>amended</code>指明<code>Map.dirty</code>中有<code>readOnly.m</code>未包含的数据，所以如果从<code>Map.read</code>找不到数据的话，还要进一步到<code>Map.dirty</code>中查找。</p>
<p>这里虽然有冗余的两份map数据，但是Map.dirty和readOnly.m的value都是一个指针变量 *entry，所以整体内存占用还好。</p>
<p>sync.Map 的kv都是 interface{} ，entry里面的p实际是一个 *interface{}，也就是entry实际保存的是指向value的指针。</p>
<p>entry中的p有三个值：</p>
<ol>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的value</li>
</ol>
<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>线程安全的加载key对应的value：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.首先从m.read中加载只读的readOnly, 从它的map中查找，无锁。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line">    <span class="comment">// read.amended 指明&#x27;Map.dirty`中有`readOnly.m`未包含的数据，所以如果从`Map.read`找不到数据的话，还要进一步到`Map.dirty`中查找</span></span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		<span class="comment">// double check</span></span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			<span class="comment">// // 从m.dirty查找</span></span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line">			<span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 原子加载 *entry 所保存的value。</span></span><br><span class="line">	<span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.misses++</span><br><span class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">	m.dirty = <span class="literal">nil</span></span><br><span class="line">	m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110724714.png" alt="img" style="zoom:80%;">

<p>首先要强调的是，首先是从readonly里面读，读不到时候才加锁去 map.dirty 里面去读，并且加锁之后首先是进行double check(熟悉Java的都知道double check是什么)。</p>
<p>double check 之后即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>missLocked方法中可能会将m.dirty提升，m,misses会记录从readOnly中获取不到 *entry 的次数，也就是miss的次数，如果达到了 len(m.dirty) 就会原子的替换m.read.m 为 m.dirty。提升后m.dirty、m.misses重置， 并且m.read.amended为false。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 如果m.read存在这个键，并且这个entry没有被标记删除(expunged)，尝试直接存储</span></span><br><span class="line">	<span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. m.read不存在或者已经被标记删除</span></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="comment">// double check</span></span><br><span class="line">	read, _ = m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//标记成未被删除</span></span><br><span class="line">			<span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></span><br><span class="line">			m.dirty[key] = e</span><br><span class="line">		&#125;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">// m.dirty存在这个键，更新</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">//新键值</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//m.dirty中没有比m.readOnly更新的数据，往m.dirty中增加第一个新键</span></span><br><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">			<span class="comment">// 从m.read中复制未删除的数据</span></span><br><span class="line">			<span class="comment">// 并标记m.read已经落后于m.dirty</span></span><br><span class="line">			m.dirtyLocked()</span><br><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将这个entry加入到m.dirty中</span></span><br><span class="line">		m.dirty[key] = newEntry(value)</span><br><span class="line">	&#125;</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tryStore stores a value if the entry has not been expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry is expunged, tryStore returns false and leaves the entry</span></span><br><span class="line"><span class="comment">// unchanged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">			m.dirty[k] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110342685.png" alt="img" style="zoom:40%;">

<p>以上操作都是先从操作m.read开始的，不满足条件再加锁，然后操作m.dirty。</p>
<p>可能会发生两种数据迁移：</p>
<ol>
<li><p>从m.dirty到m.read的迁移，这个迁移过程其实是指针的的修改，所以效率高；</p>
</li>
<li><p>从read map到dirty map的迁移, 这个迁移需要创建一个新的map来复制key-value，所以效率会低一些</p>
<p><font color="red">Store可能会在某种情况下（在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中）从m.read中复制数据到m.dirty，如果这个时候m.read中数据量非常大，可能会影响性能。</font></p>
</li>
</ol>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 如果不存在于 m.read中，而且 m.dirty 和 m.read 数据不一致。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		<span class="comment">// 加锁，double check， 然后删除对应的key。</span></span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		e.<span class="built_in">delete</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112111125713.png" alt="img" style="zoom:80%;">

<p>这里会删除 m.dirty 对应的key-value, 但是m.read中的key-value其实并没有删除，只是设置了删除的标志为expunged。这里的惰性删除避免了重新创建 entry 实体，只用更新指针和value指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>这里sync.Map是对map关键字的封装，肯定无法使用系统提供的 for range 操作。所以这里采用了一个回调的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">		<span class="comment">///提升m.dirty</span></span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">			read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">			m.read.Store(read)</span><br><span class="line">			m.dirty = <span class="literal">nil</span></span><br><span class="line">			m.misses = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历, for range是安全的</span></span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		v, ok := e.load()</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Range方法调用前可能会做一个m.dirty的提升，不过提升m.dirty不是一个耗时的操作。</p>
<h3 id="sync-Map总结"><a href="#sync-Map总结" class="headerlink" title="sync.Map总结"></a>sync.Map总结</h3><p>sync.Map的优化策略简单总结可以理解为：</p>
<ol>
<li>无锁读与读写分离；</li>
</ol>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110232202.png" alt="img" style="zoom:50%;">

<ol start="2">
<li>写加锁与延迟提升；</li>
</ol>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110214618.png" alt="img" style="zoom:50%;">

<ol start="3">
<li>指针与惰性删除，map保存的value都是指针。惰性删除，实际删除是在 Store时候去check 然后删除。</li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>李白的中国诗歌史</title>
    <url>/2021/10/13/%E6%9D%8E%E7%99%BD%E7%9A%84%E4%B8%AD%E5%9B%BD%E8%AF%97%E6%AD%8C%E5%8F%B2/</url>
    <content><![CDATA[<div align="center"><font face="楷体">《古风》</font></div><div align="center"><font face="楷体">大雅久不作，吾衰竟谁陈。</font></div><font face="楷体">    <center>王风委蔓草，战国多荆榛。</center><center>龙虎相啖食，兵戈逮狂秦。</center><center>正声何微茫，哀怨起骚人。</center><center>扬马激颓波，开流荡无垠。</center><center>废兴虽万变，宪章亦已沦。</center><center>自从建安来，绮丽不足珍。</center><center>圣代复元古，垂衣贵清真。</center><center>群才属休明，乘运共跃鳞。</center><center>文质相炳焕，衆星罗秋旻。</center><center>我志在删述，垂辉映千春。</center><center>希圣如有立，绝笔于获麟。</center></font>



















]]></content>
      <categories>
        <category>哲学</category>
        <category>唐诗新思路</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>大学</title>
    <url>/2021/11/06/%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="大學"><a href="#大學" class="headerlink" title="大學"></a>大學</h1><h2 id="大學經綸章：初學入德之門"><a href="#大學經綸章：初學入德之門" class="headerlink" title="大學經綸章：初學入德之門"></a>大學經綸章：初學入德之門</h2><p>​       大學之道，在明明德，在親民，在止於至善。知止而後有定，定而後能靜，靜而後能安，安而後能慮，慮而後能得。物有本末，事有終始，知有先後，則近道矣。古之欲明明德於天下者，先治其國。欲治其國者，先齊其家。欲齊其家者，先修其身。欲修其身者，先正其心。欲正其心者，先誠其意。欲誠其意者，先致其知。致知在格物。格物而後知至。知至而後意誠。意誠而後心正。心正而後身修。身修而後家齊。家齊而後國治。國治而後天下平。自天子以至於庶人，壹是皆以修身為本。其本亂，而未治者，否矣。其所厚者薄，而其所薄者厚，未之有也。此謂知本，此謂知之至也。</p>
<h2 id="康诰盘铭、邦畿章：将美好得品德发扬光大"><a href="#康诰盘铭、邦畿章：将美好得品德发扬光大" class="headerlink" title="康诰盘铭、邦畿章：将美好得品德发扬光大"></a>康诰盘铭、邦畿章：将美好得品德发扬光大</h2><p>​       </p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>大學</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>c++注意点</title>
    <url>/2021/11/06/c-%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<ol>
<li>不可以在函数内部返回局部变量的引用。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// ref = 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;  <span class="comment">// ref = 1479064544  此处会出现错误，避免该错误不要返回局部变量的引用。  因为局部变量保存在栈区，函数结束，内存也就释放了</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">    <span class="comment">// 局部静态变量保存在全局区，不会随着函数结束而内存释放，所以不会出现上述问题。</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;   </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>c++继承方式</li>
</ol>
<img src="/2021/11/06/c-%E6%B3%A8%E6%84%8F%E7%82%B9/image-20211107091913409.png" alt="image-20211107091913409 " style="zoom:50%;"> 



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>goNote01</title>
    <url>/2021/11/20/goNote01/</url>
    <content><![CDATA[<h3 id="gofmt-格式化命令"><a href="#gofmt-格式化命令" class="headerlink" title="gofmt 格式化命令"></a>gofmt 格式化命令</h3><img src="/2021/11/20/goNote01/image-20211120101130947.png" alt="image-20211120101130947" style="zoom:80%;">

<h3 id="Golang-环境变量配置及其作用"><a href="#Golang-环境变量配置及其作用" class="headerlink" title="Golang 环境变量配置及其作用"></a>Golang 环境变量配置及其作用</h3><p>GOROOT: 指定 go sdk 安装目录。<br>Path: 指令 sdk\bin 目录：go.exe godoc.exe gofmt.exe<br>GOPATH: 就是 golang 工作目录：我们的所有项目的源码都这个目录下。</p>
<img src="/2021/11/20/goNote01/image-20211120211125271.png" alt="image-20211120211125271" style="zoom:80%;">

<p>go语言总值类型包括：基本数据类型 int 系列, float 系列, bool, string 、数组和 结构体 struct</p>
<p>引用类型：指针、slice 切片、map、管道 chan、interface 等都是引用类型</p>
<h3 id="值类型和引用类型的使用特点"><a href="#值类型和引用类型的使用特点" class="headerlink" title="值类型和引用类型的使用特点"></a>值类型和引用类型的使用特点</h3><ol>
<li>值类型：变量直接存储值，内存通常在栈中分配<br>示意图：</li>
</ol>
<img src="/2021/11/20/goNote01/image-20211120225507401.png" alt="image-20211120225507401" style="zoom:80%;">

<ol start="2">
<li>引用类型：变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆<br>上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收</li>
</ol>
<img src="/2021/11/20/goNote01/image-20211120225539343.png" alt="image-20211120225539343" style="zoom:80%;">

<p>如果变量名、函数名、常量名首字母大写，则可以被其他的包访问；如果首字母小写，则只能<br>在本包中使用 ( 注：可以简单的理解成， 首字母大写是公开的， 首字母小写是私有的) ,在 golang 没 有<br>public , private 等关键字。</p>
<p>Type Switch：switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际指向的<br>变量类型</p>
<img src="/2021/11/20/goNote01/image-20211121124942312.png" alt="image-20211121124942312" style="zoom:80%;">

<p>如果我们的字符串含有中文，那么传统的遍历字符串方式，就是错误，会出现乱码。原因是传统的<br>对字符串的遍历是按照 字节来遍历，而一个汉字在 utf8 编码是对应 3 个字节。</p>
<p>如何解决 需要要将 str 转成 []rune 切片.=&gt; 体验一把</p>
<img src="/2021/11/20/goNote01/image-20211121131133556.png" alt="image-20211121131133556" style="zoom:80%;">

<p>对应 for-range 遍历方式而言，是按照字符方式遍历。因此如果有字符串有中文，也是 ok</p>
<img src="/2021/11/20/goNote01/image-20211121131146498.png" alt="image-20211121131146498" style="zoom:80%;">

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><img src="/2021/11/20/goNote01/image-20211121212757065.png" alt="image-20211121212757065" style="zoom:80%;">

<h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><p>Go 程序中，也支持自定义错误， 使用 errors.New 和 panic 内置函数。</p>
<ol>
<li>errors.New(“错误说明”) , 会返回一个 error 类型的值，表示一个错误</li>
<li>panic 内置函数 ,接收一个 interface{}类型的值（也就是任何值了）作为参数。可以接收 error 类<br>型的变量， 输出错误信息，</li>
</ol>
<img src="/2021/11/20/goNote01/image-20211121213410011.png" alt="image-20211121213410011" style="zoom:80%;">

<p>如果使用 netstat –an 可以查看本机有哪些端口在监听</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>Go协程泄露</title>
    <url>/2021/12/09/Go%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h2 id="GO协程泄露和修复"><a href="#GO协程泄露和修复" class="headerlink" title="GO协程泄露和修复"></a>GO协程泄露和修复</h2><p><a href="https://blog.csdn.net/wujilei5/article/details/93512768">原文链接</a></p>
<p>golang中goroutine使用原则：<font color="red">在不知道如何停止的情况下，永远不要启动goroutine。</font></p>
<p>泄漏goroutines的情况非常常见，下面举例说明：</p>
<p>构建一个自定义map结构体，map的键配置配置成在持续时间后过期。代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> expiringValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	expiration time.Time</span><br><span class="line">	data       []<span class="keyword">byte</span> <span class="comment">// the actual value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	data <span class="keyword">map</span>[<span class="keyword">string</span>]expiringValue   </span><br><span class="line">	expiration time.Duration   <span class="comment">// map中的键持续时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">removeExpired</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 循环便利 m.data 中的数据，对于每一个expiringValue，对现在的时间进行对比，查看是否超过expiration，判断是否删除。</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m.data&#123;</span><br><span class="line">		now := time.Now()</span><br><span class="line">		<span class="keyword">if</span> now.Sub(v.expiration) &gt; m.expiration&#123;</span><br><span class="line">			<span class="built_in">delete</span>(m.data, k)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">string</span>, val []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	data := expiringValue&#123;</span><br><span class="line">		data: val,</span><br><span class="line">		expiration: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	m.data[key] = data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e, ok := m.data[key]; !ok&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> e.data, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 为了确保键到期能被删除，我们在NewMap函数中启动一个工作协程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(expiration time.Duration)</span> *<span class="title">Map</span></span> &#123;</span><br><span class="line">	m := &amp;Map&#123;</span><br><span class="line">		data:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]expiringValue),</span><br><span class="line">		expiration: expiration,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// start a worker goroutine</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="keyword">range</span> time.Tick(expiration) &#123;</span><br><span class="line">			m.removeExpired()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作协程将根据配置时间，周期性的调用map类型的方法以删除任何过期的键。因此在调用SetKey时需要记录键添加的时间，这就是数据字段包含expiringValue类型的原因，该类型将实际值与到期时间相关联.</p>
<p>乍一看，工作协程的调用似乎很好。如果这不是一个关于协程泄漏的帖子，这段代码也许不会有什么问题。但实际上，我们在构造函数中泄漏了一个协程。是怎么泄漏的呢？</p>
<p>让我们来看看Map的典型生命周期。首先，调用者创建Map的实例。创建实例后，一个工作协程开始运行。接下来，调用者可以对Set和Get进行任意数量的调用。但最终，调用者将完成使用Map实例并释放对它的所有引用。此时，垃圾收集器通常能够收集实例的内存。但是，删除过期key的工作仍在运行，并且还保留了Map实例的引用。由于没有明确的调用来停止工作协程，我们泄漏了一个协程，并泄漏了Map实例的内存。</p>
<p>我们使用运行时包来查看有关内存分配器的统计信息以及在特定时刻运行的Go协程的数量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            runtime.ReadMemStats(&amp;stats)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;HeapAlloc    = %d\n&quot;</span>, stats.HeapAlloc)</span><br><span class="line">            fmt.Printf(<span class="string">&quot;NumGoroutine = %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">            time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        work()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := NewMap(<span class="number">5</span>*time.Minute)</span><br><span class="line">    m.Set(<span class="string">&quot;my-key&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;my-value&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _, ok := m.Get(<span class="string">&quot;my-key&quot;</span>); !ok &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value present&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// m goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很快就可以看到堆分配和Go协程的数量增长很多。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HeapAlloc    = <span class="number">76960</span></span><br><span class="line">NumGoroutine = <span class="number">18</span></span><br><span class="line">HeapAlloc    = <span class="number">2014278208</span></span><br><span class="line">NumGoroutine = <span class="number">1447847</span></span><br><span class="line">HeapAlloc    = <span class="number">3932578560</span></span><br><span class="line">NumGoroutine = <span class="number">2832416</span></span><br><span class="line">HeapAlloc    = <span class="number">5926163224</span></span><br><span class="line">NumGoroutine = <span class="number">432252</span></span><br></pre></td></tr></table></figure>

<p>所以现在很明显我们需要停止那个Go协程。目前，Map API没有办法关闭工作协程。最好避免修改任何API，并在调用者使用完Map实例时能停止工作协程。但只有调用者知道什么时候该停止。</p>
<p>解决此问题的常见模式是实现io.Closer接口。当调用者使用完Map时，他们可以调用Close来告诉Map停止其工作协程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	data <span class="keyword">map</span>[<span class="keyword">string</span>]expiringValue</span><br><span class="line">	expiration time.Duration</span><br><span class="line">	done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(expiration time.Duration)</span> *<span class="title">Map</span></span> &#123;</span><br><span class="line">    m := &amp;Map&#123;</span><br><span class="line">        data:       <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]expiringValue),</span><br><span class="line">        expiration: expiration,</span><br><span class="line">        done:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start a worker goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ticker := time.NewTicker(expiration)</span><br><span class="line">        <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">                    m.removeExpired()</span><br><span class="line">                <span class="keyword">case</span> &lt;-m.done:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			runtime.ReadMemStats(&amp;stats)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;HeapAlloc    = %d\n&quot;</span>, stats.HeapAlloc)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;NumGoroutine = %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">			time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		work()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := NewMap(<span class="number">5</span>*time.Minute)</span><br><span class="line">	m.Set(<span class="string">&quot;my-key&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;my-value&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, ok := m.Get(<span class="string">&quot;my-key&quot;</span>); !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;no value present&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	m.done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="comment">// m goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">HeapAlloc    = <span class="number">72464</span></span><br><span class="line">NumGoroutine = <span class="number">6</span></span><br><span class="line">HeapAlloc    = <span class="number">5175200</span></span><br><span class="line">NumGoroutine = <span class="number">59</span></span><br><span class="line">HeapAlloc    = <span class="number">5495008</span></span><br><span class="line">NumGoroutine = <span class="number">35</span></span><br><span class="line">HeapAlloc    = <span class="number">9171136</span></span><br><span class="line">NumGoroutine = <span class="number">240</span></span><br><span class="line">HeapAlloc    = <span class="number">8347120</span></span><br><span class="line">NumGoroutine = <span class="number">53</span></span><br></pre></td></tr></table></figure>

<p>数字很小，这是因为调用工作协程的循环比较小。但更重要的是，Go协程或堆分配数量没有再大幅增长了。这正是我们想要的结果。</p>
<p>这篇文章展示了一个明显的例子，说明为什么知道何时停止Go协程如此重要。另一方面，也可以说监控应用程序中的Go协程数量一样很重要。如果Go协程泄漏潜入代码库，这样的监控程序可以提供一个警告系统。还值得记住的是，有时Go协程泄漏需要数天甚至数周才能在应用程序中显示，所以拥有更短和更长时间跨度的监视程序很有必要。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>紫薇命盘实例</title>
    <url>/2022/05/18/%E7%B4%AB%E8%96%87%E5%91%BD%E7%9B%98%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>算命时间：2022年5月18日    算命人：家良父亲</p>
<img src="/2022/05/18/%E7%B4%AB%E8%96%87%E5%91%BD%E7%9B%98%E5%AE%9E%E4%BE%8B/1652836320140.png" width="70%">

<p>家良老爸（后用此人代指）：此人天马禄存入命宫，这是奔波劳累做生意发财的命，此人命宫三方四正还会到太阴太阳，太阳落陷，太阴旺，此人母亲以及太太会对其有很大帮助。12-21岁此十年为父母宫擎羊落陷，这十年无大运，同时结合太阳星落陷，此人父亲有灾，会在父亲身上花费很多精力以及钱财。22-31岁进入福德宫化忌在此宫，这十年会要比12-21岁好些，但仍然是诸事不顺。并且福德宫对宫財帛宮巨门星落陷，在22-31这十年，会受到小人口舌是非上的影响，还会有打官司的可能。32-41这十年在田宅宫武曲破军化权，这十年事业会有起色，但是仍然不会挣太多钱，另外在这十年此人有可能会对传统文化或者宗教产生兴趣。42-51岁这十年没什么好说的，一般。52-61岁，62-71岁，72-81岁此人连续三十年大运，很旺，发财。52-81这三十年，总体好的，但是要有警戒之心，在54、55、61、66、67在几个流年不是很好尤其是54和66，没有什么大凶放心。虽说52-81有三十年大运，但是主要是前20年，72-81这十年发财就算了吧，年纪太大了。</p>
<p>身体方面：酉宫、戌宫这两个宫比较凶，此二宫代表的身体部位为：左胸、左肋、肾、心。留意一下就好，这个不是很准。</p>
<p>算命时间：2022年5月18日    算命人：家良母亲</p>
<img src="/2022/05/18/%E7%B4%AB%E8%96%87%E5%91%BD%E7%9B%98%E5%AE%9E%E4%BE%8B/1652839782399.png" width="70%">

<p>家良老妈（后用此人代指）：太阴太阳入命宫，且太阳落陷太阴很旺。太阴入命且旺，此人年轻时候一定很漂亮，性格也是很温柔的。但是命宫还有太阳落陷，此人性格总体而言应该是：平常待人很温柔的，但是遇到事情有时也会很暴躁。此人命宫化科，身宫在官祿宮，凭借专业技术在公家单位吃饭。 14-23岁，父母宫贪狼文昌落陷且化忌，此人父母处于生离的状态，跟随母亲生活，跟妈妈比较亲（你给我说过，属于马后炮），14-23这十年的运不是很好，但是文昌星在此宫，推测这十年学习应该挺好，但是考试不中。24-33，34-43此为人生中最旺的二十年，事事遂心。另外此人福德宫很好，福德宫主人一生的福气，也代表女人的婚姻，同时夫妻宫也很好，因此此人婚姻美满很顺。44-53这十年大运也挺好的，没什么大问题；54-63这十年就一般了，但是也没什么大问题。结合实际情况，你老妈就在家歇着就行了，看看佛经、给你介绍个对象啊或者给你爸爸出谋划策什么的。</p>
<p>同时结合你老爸，52-71这20年很运势旺，且太阴星很亮。对于男人来说阴代表母亲和太太，个人推测应该是：你妈在后面出谋划策，你爸在外做事情，你爸能发笔财。</p>
<p>身体状况：未宫、酉宫比较差，这两个宫对应的身体部位为：左胸、小肠、肾和头。留意一下就好，这个不是很准。</p>
]]></content>
  </entry>
  <entry>
    <title>阅读笔记01</title>
    <url>/2022/05/16/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<p>​        易學中的同性相生，即陽生陽、陰生陰，生力大；異性相生，即陽生陰、陰生陽，生力小。陰陽同性相剋，即陰剋陰、陽剋陽，剋性大，是真剋，無情之剋；陰陽異性相剋，即陰剋陽、陽剋陰，剋性不大，是有情之剋，衹是適度的管制約束而已。</p>
<p>​        旺相休囚死。當令者旺，令生者相，生令者囚，令剋者死，（令是指四季，春季木當令，夏季火當令，秋季金當令，冬季水當令，三、六、九、十二月土當令）。十二長生順序：長生、沐浴、冠帶、臨官、帝旺、衰、病、死、墓、絕、胎、養。金長生在巳，木長生在亥，火長生在寅，水土長生在申。在鬥數中，長生、冠帶、臨官、帝旺屬於旺相；衰、病、死、墓、絕屬於衰相；沐浴屬於破敗；胎、養屬於中間溫養狀態。</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>紫微斗数精成（大德山人编著）</category>
      </categories>
      <tags>
        <tag>哲学</tag>
      </tags>
  </entry>
</search>
