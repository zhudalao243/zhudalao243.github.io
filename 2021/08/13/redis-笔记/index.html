<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhudalao243.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="快照      持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof redis是内存数据库，如果没有持久化，那么数据断电及失！ 123456789101112131415# 在900秒（15分钟）内,如果至少有1个键值发生变化 就进行持久化操作save 900 1# 在300秒内,如果至少有10个键值发生变化 就进行持久化操作save 300 10# 在60秒内,如果">
<meta property="og:type" content="article">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://zhudalao243.github.io/2021/08/13/redis-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:description" content="快照      持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof redis是内存数据库，如果没有持久化，那么数据断电及失！ 123456789101112131415# 在900秒（15分钟）内,如果至少有1个键值发生变化 就进行持久化操作save 900 1# 在300秒内,如果至少有10个键值发生变化 就进行持久化操作save 300 10# 在60秒内,如果">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200909094246510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715170524335.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200909102650337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715185443728.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715190050840.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715192446365.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715211119674.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715211702288.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715211851164.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210715215716925.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716104936457.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716110219529.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716111501043.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716115159822.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716145410767.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716145650494.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716154826614.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716155211203.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716155331081.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716160430302.png">
<meta property="og:image" content="c:/Users/猪哥/AppData/Roaming/Typora/typora-user-images/image-20210716160756712.png">
<meta property="article:published_time" content="2021-08-13T11:50:24.258Z">
<meta property="article:modified_time" content="2021-07-16T08:15:36.952Z">
<meta property="article:author" content="zzy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200909094246510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center">

<link rel="canonical" href="http://zhudalao243.github.io/2021/08/13/redis-%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | 上善若水</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">上善若水</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/13/redis-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-13 19:50:24" itemprop="dateCreated datePublished" datetime="2021-08-13T19:50:24+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-16 16:15:36" itemprop="dateModified" datetime="2021-07-16T16:15:36+08:00">2021-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>快照    </p>
</blockquote>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p>
<p>redis是内存数据库，如果没有持久化，那么数据断电及失！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在900秒（15分钟）内,如果至少有1个键值发生变化 就进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 在300秒内,如果至少有10个键值发生变化 就进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 在60秒内,如果至少有10000个键值发生变化 就进行持久化操作</span></span><br><span class="line">save 60 10000   </span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试！</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes  <span class="comment"># 是否压缩 rdb 文件，需要消耗一些CPU资源</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes  <span class="comment"># 保存 rdb 文件的时候，进行错误的检查校验！</span></span><br><span class="line"></span><br><span class="line">dir ./  <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>REPLICATION 复制</p>
</blockquote>
<blockquote>
<p>SECURITY 安全</p>
</blockquote>
<p>可以在这里设置redis的密码，默认是没有密码！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass   <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span>  <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass   <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456  <span class="comment">#使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass </span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>限制CLIENTS</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000  <span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt;  <span class="comment"># redis 配置最大的内存容量</span></span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  <span class="comment"># 内存到达上限之后的处理策略</span></span><br><span class="line">    1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span><br><span class="line">    2、allkeys-lru ： 删除lru算法的key   </span><br><span class="line">    3、volatile-random：随机删除即将过期key   </span><br><span class="line">    4、allkeys-random：随机删除   </span><br><span class="line">    5、volatile-ttl ： 删除即将过期的   </span><br><span class="line">    6、noeviction ： 永不过期，返回错误</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY 模式  aof配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no   <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大多数的情况下，rdb完全够用！</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>   <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always   # 每次修改都会 sync 消耗性能</span></span><br><span class="line">appendfsync everysec   <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no	  # 不执行 sync，这个时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure>

<p>具体的配置，我们在 Redis持久化中详细介绍</p>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 是内存数据库，如果不将内存中的数据库保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会效时。所有 Redis 提供了持久化功能！</p>
<p><img src="https://img-blog.csdnimg.cn/20200909094246510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存中。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点就是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改整个配置！</p>
<p>有时候在生产环境下，我们会将这个文件进行备份。</p>
<p><strong>rdb保存的文件是dump.rdb</strong> 都是在配置文件中快照中进行配置的！</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li><p>save 的规则满足的情况下，会自动触发 rdb 规则。</p>
</li>
<li><p>执行 flushall 命令，也会触发我们的 rdb 规则。</p>
</li>
<li><p>退出 redis， 也会产生 rdb 文件！</p>
<p>备份就会自动产生一个 dump.rdb文件！</p>
<p><img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715170524335.png" alt="image-20210715170524335"></p>
</li>
</ol>
<blockquote>
<p>如何恢复 rdb 文件！</p>
</blockquote>
<ol>
<li><p>只需要将 rdb 文件放在我们redis启动目录就可以，redis 启动的时候会自动检查dump.rdb恢复其中的数据！</p>
</li>
<li><p>查看需要存在的位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span>  <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>几乎就他自己的默认的配置就够用了，但是我们还是需要去学习！</p>
</blockquote>
</li>
</ol>
<p>优点：</p>
<ol>
<li>适合大规模的数据恢复！</li>
<li>对数据的完整性要不高！</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有了</li>
<li>fork 进程的时候，会占用一定的内存空间！</li>
</ol>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>将我们所有命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍！</p>
<blockquote>
<p>是什么</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200909102650337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZhbmppYW5oYWk=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>以日志的形式来记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录) , 只许追加文件但不可以改写文件, redis启动之初会读取该文件重新构建数据,换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>Aof保存的是appendonly.aof文件</strong></p>
<blockquote>
<p>append</p>
</blockquote>
<p><img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715185443728.png" alt="image-20210715185443728"></p>
<p>默认是不开启的,我们需要手动进行配置!我们只需要将appendonly改为yes就开启了aof !</p>
<p>重启, redis就可以生效了!</p>
<p>如果这个aof文件有错位,这时候redis 是启动不起来的,我们需要修复这个aof文件</p>
<p>redis给我们提供了一-个工具 <code>redis-check-aof --fix</code> </p>
<p><img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715190050840.png" alt="image-20210715190050840"></p>
<p>如果 aof 文件正常，重启就可以恢复数据。</p>
<blockquote>
<p>重写规则说明</p>
</blockquote>
<p>aof 默认就是文件的无限追加，文件会越来越大！</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715192446365.png" alt="image-20210715192446365" style="zoom:70%;" />

<p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>
<blockquote>
<p>优点和缺点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no   <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大多数的情况下，rdb完全够用！</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>   <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always   # 每次修改都会 sync 消耗性能</span></span><br><span class="line">appendfsync everysec   <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no	  # 不执行 sync，这个时候操作系统自己同步数据，速度最快</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>每一次修改都同步,文件的完整会更加好!</li>
<li>每秒同步- -次 ，可能会丢失一秒的数据</li>
<li>从不同步,效率最高的!</li>
</ol>
<p>缺点：</p>
<ol>
<li>相对于数据文件来说, aof远远大于rdb ,修复的速度也比rdb慢!</li>
<li>Aof运行效率也要比rdb慢,所以我们redis默认的配置就是rdb持久化!</li>
</ol>
<p><strong>扩展：</strong></p>
<ol>
<li><p>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
</li>
<li><p>AOF 持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据, AOF命令以追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</p>
</li>
<li><p><strong>只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化</strong></p>
</li>
<li><p>同时开启两种持久化方式</p>
<ul>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?作者建议不要,因为RDB更适合用于备份数据库( AOF在不断变化不好备份) , 快速重启,而且不会有AOF可能潜在的Bug ,留着作为一-个万- -的手段。</li>
</ul>
</li>
<li><p>性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途,建议只在Slave.上持久化RDB文件,而且只要15分钟备份- -次就够了,只保留save 900 1这条规则。</li>
<li>如果Enable AOF ,好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价一是带来了持续的IO ,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少AOF rewrite的频率, AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF ,仅靠Master- Slave Repllcation实现高可用性也可以,能省掉一 大笔IO ,也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个,微博就是这种架构。</li>
</ul>
</li>
</ol>
<h2 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h2><p>Redis发布订阅(pub/sub)是一种__消息通信模式__:发送者(pub)发送消息,订阅者(sub)接收消息。微信、微博、关注系统!</p>
<p>Redis客户端可以订阅任意数量的频道。|</p>
<p>订阅/发布消息图:</p>
<p>第一个：消息发送者，第二个：频道，第三个：消息订阅者</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715211119674.png" alt="image-20210715211119674" style="zoom:80%;" />

<p>下图展示了频道channel1，以及订阅这个频道的三三个客户端- – client2 、client5 和client1之间的关系:</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715211702288.png" alt="image-20210715211702288" style="zoom:50%;" />

<p>当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端:</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715211851164.png" alt="image-20210715211851164" style="zoom:50%;" />

<blockquote>
<p>命令</p>
</blockquote>
<p>这些命令被广泛用于构建即时通信应用,比如网络聊天室(chatroom)和实时广播、实时提醒等。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210715215716925.png" alt="image-20210715215716925" style="zoom:70%;" />

<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的,通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现,籍此加深对Redis的理解。</p>
<p>Redis通过PUBLISH、SUBSCRIBE 和PSUBSCRIBE等命令实现发布和订阅功能。通过SUBSCRIBE命令订阅某频道后, redis-server里维护了一个字典,字典的键就是一一个个 频道! ,而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE 命令的关键,就是将客户端添加到给定channel的订阅链表中。通过PUBLISH命令向订阅者发送消息, redis-server 会使用给定的频道作为键,在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表,遍历这个链表,将消息发布给所有订阅者。</p>
<p>Pub/Sub从字面上理解就是发布( Publish )与订阅( Subscribe ) , 在Redis中,你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后,所有订阅它的客户端都会收到相应的消息。这-功能最明显的用法就是用作实时消息系统,比如普通的即时聊天,群聊等功能。</p>
<p><strong>使用场景</strong></p>
<ol>
<li><p>实时消息系统!</p>
</li>
<li><p>事实聊天! (频道当做聊天室,将信息回显给所有人即可! )</p>
</li>
<li><p>订阅，关注系统都是可以的!</p>
<p>稍微复杂的场景我们就会使用消息中间件MQ .</p>
</li>
</ol>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>主从复制,是指将一台Redis服务器的数据 ,复制到其他的Redis服务器。前者称为主节点(master/leader) ,后者称为从节点(slave/follower) ;数据的复制是单向的，只能由主节点到从节点。Master以写为主 , Slave以读为主。</p>
<p>默认情况下,每台Redis服务器都是主节点;且-个主节点可以有多个从节点(或没有从节点) ,但-一个从节点只能有一-个主节点。</p>
<p><strong>主从复制的作用主要包括:</strong></p>
<ol>
<li>数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</li>
<li>故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复;实际上是一种服务的冗余。</li>
<li>负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点) , 分担服务器负载;尤其是在写少读多的场景下,通过多个从节点分担读负载,可以大大提高Redis服务器的并发量。</li>
<li>高可用(集群)基石:除了.上述作用以外,主从复制还是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础。</li>
</ol>
<p>一般来说 ,要将Redis运用于工程项目中,只使用一台Redis是万万不能的(宕机，- -主二从) ,原因如下:</p>
<ol>
<li>从结构上,单个Redis服务器会发生单点故障,并且一台服务器需要处理所有的请求负载,压力较大;</li>
<li>从容量上,单个Redis服务器内存容量有限,就算一台Redis服务器内存容 量为256G ,也不能将所有内存用作Redis存储内存,一般来说 ,单台Redis最大使用内存不应该超过20G。</li>
</ol>
<p>电商网站上的商品，-般都是一次上传,无数次浏览的,说专业点也就是”多读少写”。</p>
<p>对于这种场景,我们可以使如下这种架构:</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716104936457.png" alt="image-20210716104936457" style="zoom:67%;" />

<p>主从复制，读写分离! 80% 的情况下都是在进行读操作!减缓服务器的压力!架构中经常使用! 一主二从!</p>
<p>只要在公司中,主从复制就是必须要使用的,因为在真实的项目中不可能单机使用Redis !</p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>只配置从库,不用配置主库!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication <span class="comment"># 查看当前库的信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色 master</span></span><br><span class="line">connectjed_ slaves:0 <span class="comment">#没有从机</span></span><br><span class="line">master_ replid : b63c90e6c501143759cb0e7f450bd1eb0c70882a</span><br><span class="line">master_ rep1i d2 :0000000000000000000000000000000000000000</span><br><span class="line">master_ rep1_ _offset:0</span><br><span class="line">second_ rep1_ offset:-1</span><br><span class="line">rep1_ back1og_ active:0 </span><br><span class="line">rep1_ back1og_ size:1048576</span><br><span class="line">rep1_ back7og_ _first_ _byte_ offset:0</span><br><span class="line">rep1_ back1og_ _histlen:0</span><br></pre></td></tr></table></figure>

<p>复制3个配置文件,然后修改对应的信息</p>
<ol>
<li>端口</li>
<li>pid 名字</li>
<li>log文件名字</li>
<li>dump.rdb 名字</li>
</ol>
<p>修改完毕之后,启动我们的3个redis服务器,可以通过进程信息查看!|<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716110219529.png" alt="image-20210716110219529" style="zoom:80%;" /></p>
<h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>__默认情况下，每台Redis服务器都是主节点__，我们一般情况下只用配置从机就好了！</p>
<p>认老大！ 一主（79）二从（80，81）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379 <span class="comment"># SLAVEOF host 6379 找谁当自己的老大!</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication </span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave <span class="comment">#当前角但是从机</span></span><br><span class="line">master_ _host:127.0.0.1  <span class="comment">#可以的看到主机的信息</span></span><br><span class="line">master_ _port:6379  </span><br><span class="line">master_1ink_ status :up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在主机中查看!</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1 <span class="comment"># 多了从机的配置</span></span><br><span class="line">slave0:ip=127.0.0.1, port=6380, state=online, offset=42,1ag=1  <span class="comment">#多了从机的配置</span></span><br><span class="line">master_ rep1id:a81be8dd2 57636b2d3e7a9f595e69d73ff03774e</span><br><span class="line">master_ rep1i d2 : 000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>如果两个都配置好了，就是有两个从机</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716111501043.png" alt="image-20210716111501043" style="zoom:67%;" />

<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以写, 从机不能写，只能读! 主机中的所有信息和数据,都会自动被从机保存!</p>
<p>测试: 主机断开连接,从机依旧连接到主机的,但是没有写操作,这个时候,主机如果回来了,从机依旧可以直接获取到主机写的信息!如果是使用命令行,来配置的主从,这个时候如果重启了从机，从机就会变回主机! 只要重新变为从机,立马就会从主机中获取值!</p>
<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave启动成功连接到master后会发送一个sync同步命令</p>
<p>Master接到命令,启动后台的存盘进程,同时收集所有接收到的用于修改数据集命令,在后台进程执行完毕之后, __master将传送整个数据文件到slave ,并完成-次完全同步__。</p>
<p><strong>全量复制</strong>:而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。</p>
<p><strong>增量复制</strong>: Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master ，一次完全同步(全量复制)将被自动执行! 我们的数据一定可以在从机中看到！</p>
<blockquote>
<p>层层链路</p>
</blockquote>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716115159822.png" alt="image-20210716115159822" style="zoom:50%;" />

<p>这时候也可以完成我们的主从复制！</p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢? 手动!</p>
</blockquote>
<p>如果主机断开了连接,我们可以使用 __(SLAVEOF no one) __ 让自己变成主机! I 其他的节点就可以手动的连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>（自动选举老大的模式）</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是:当主服务器宕机后,需要手动把一台从服务器切换为主服务器,这就需要人工干预,费事费力,还会造成一段时间内服务不可用。 这不是一种推荐的方式 ,更多时候,我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵)架构来解决这个问题。</p>
<p>谋朝篡位的自动版,能够后台监控主机是否故障,如果故障了根据投票数自动将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式,首先Redis提供了哨兵的命令,哨兵是一一个独立的进程,作为进程,它会独立运行。其原理是<strong>哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例</strong>。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716145410767.png" alt="image-20210716145410767" style="zoom:50%;" />

<p>这里的哨兵有两个作用：</p>
<ul>
<li>通过发送命令,让Redis服务器返回监控其运行状态,包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机,会自动将slave切换成master ,然后通过发布订阅模式通知其他的从服务器,修改配置文件,让它们切换主机。</li>
</ul>
<p>然而一-个哨兵进程对Redis服务器进行监控,可能会出现问题,为此,我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控,这样就形成了多哨兵模式。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716145650494.png" alt="image-20210716145650494" style="zoom:50%;" />

<p>假设主服务器宕机,哨兵1先检测到这个结果,系统并不会马.上进行failover过程,仅仅是哨兵1主观的认为主服务器不可用,这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用,并且数量达到一定值时,那么哨兵之间就会进行一-次投票 ,投票的结果由-一个哨兵发起,进行failover[故障转移]操作。切换成功后,就会通过发布订阅模式,让各个哨兵把自己监控的从服务器实现切换主机,这个过程称为客观下线。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>我们目前的状态是一主二从</p>
<ol>
<li>配置哨兵配置文件 sentinel.conf</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p>
<ol start="2">
<li>启动哨兵！</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen bin]<span class="comment"># redis-sentine1 kconfig/sentinel.conf</span></span><br></pre></td></tr></table></figure>

<p>如果Master 节点断开了，这个时候就会从主机中随机选择一个服务器！（这里有一个投票算法！）如果主机此时回来了,只能归并到新的主机下,当做从机,这就是哨兵模式的规则!</p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>优点：</p>
<ol>
<li>哨兵集群,基于主从复制模式,所有的主从配置优点,它全有</li>
<li>主从可以切换,故障可以转移,系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级,手动到自动,更加健壮!</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis 不好啊在线扩容的,集群容量一旦到达上限,在线扩容就十分麻烦!</li>
<li>实现哨兵模式的配置其实是很麻烦的,里面有很多选择!</li>
</ol>
<blockquote>
<p>哨兵模式的全部配置</p>
</blockquote>
<h2 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h2><p>Redis缓存的使用,极大的提升了应用程序的性能和效率,特别是数据查询方面。但同时,它也带来了一-些问题。 其中,最要害的问题,就是数据的一致性问题,从严格意义上讲,这个问题无解。如果对数据的一致性要求很高,那么就不能使用缓存。</p>
<p>另外的一-些典型问题就是,缓存穿透、缓存雪崩和缓存击穿。目前,业界也都有比较流行的解决方案。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716154826614.png" alt="image-20210716154826614" style="zoom:55%;" />

<h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单,用户想要查询一-个数据,发现redis内存数据库没有,也就是缓存没有命中,于是向持久层数据库查询。发现也没有,于是本次查询失败。当用户很多的时候,缓存都没有命中(秒杀! ) ,于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力,这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构,对所有可能查询的参数以hash形式存储,在控制层先进行校验,不符合则丢弃,从而避免了对底层存储系统的查询压力;</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716155211203.png" alt="image-20210716155211203" style="zoom:50%;" />

<p><strong>缓存空对象</strong></p>
<p>当存储层不命中后,即使返回的空对象也将其缓存起来,同时会设置一个过期时间,之后再访问这个数据将会从缓存中获取,保护了后端数据源;</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716155331081.png" alt="image-20210716155331081" style="zoom:50%;" />

<p>但是这种方法会存在两个问题:</p>
<ol>
<li>如果空值能够被缓存起来,这就意味着缓存需要更多的空间存储更多的键,因为这当中可能会有很多的空值的键;</li>
<li>即使对空值设置了过期时间,还是会存在缓存层和存储层的数据会有一-段时间窗口的不- 致,这对于需要保持一致性的业务会有影响。</li>
</ol>
<h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><p>例子：微博服务器宕机</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别,缓存击穿,是指一-个key非常热点 ,在不停的扛着大并发,大并发集中对这一个点进行访问 ,当这个key在失效的瞬间,持续的大并发就穿破缓存,直接请求数据库,就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间,有大量的请求并发访问,这类数据一般是热点数据,由于缓存过期,会同时访问数据库来查询最新数据,并且回写缓存,会导使数据库瞬间压力过大。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题</p>
<p><strong>加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待既可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716160430302.png" alt="image-20210716160430302" style="zoom:33%;" />

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩,是指在某-一个时间段,缓存集中过期失效。Redis 宕机! </p>
<p>产生雪崩的原因之一,比如在写本文的时候,马上就要到双十二零点,很快就会迎来一波抢购,这波商品时间比较集中的放入了缓存,假设缓存一个小时。 那么到了凌晨一点钟的时候,这批商品的缓存就都过期了。而对这批商品的访问查询,都落到了数据库上,对于数据库而言,就会产生周期性的压力波峰。于是所有的请求都会达到存储层,存储层的调用量会暴增,造成存储层也会挂掉的情况。</p>
<img src="C:\Users\猪哥\AppData\Roaming\Typora\typora-user-images\image-20210716160756712.png" alt="image-20210716160756712" style="zoom:50%;" />

<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>redis高可用</strong></p>
<p>这个思想的含义是,既然redis有可能挂掉,那我多增设几台redis ,这样-台挂掉之 后其他的还可以继续工作,其实就是搭建的集群。(异地多活!)</p>
<p><strong>限流降级</strong></p>
<p>这个解决方案的思想是,在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一-遍 ，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key ,设置不同的过期时间,让缓存失效的时间点尽量均匀。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/13/MySQL%E9%94%81%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">Redis 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">1.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">1.2.</span> <span class="nav-text">AOF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="nav-number">2.</span> <span class="nav-text">Redis发布订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">Redis主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.</span> <span class="nav-text">环境配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="nav-number">3.3.</span> <span class="nav-text">一主二从</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">哨兵模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.</span> <span class="nav-text">Redis缓存穿透和雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%88%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">缓存穿透（查不到）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E9%87%8F%E5%A4%AA%E5%A4%A7%EF%BC%8C%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">缓存击穿（量太大，缓存过期）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.3.</span> <span class="nav-text">缓存雪崩</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
