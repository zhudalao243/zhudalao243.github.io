<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhudalao243.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://zhudalao243.github.io/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="zzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zhudalao243.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>上善若水</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">上善若水</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">成为一个有智慧的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zzy"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">zzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/01/%E6%B5%85%E8%B0%88TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/%E6%B5%85%E8%B0%88TCP/" class="post-title-link" itemprop="url">浅谈TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-01 14:12:13 / 修改時間：15:38:05" itemprop="dateCreated datePublished" datetime="2021-09-01T14:12:13+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><ol>
<li><p>TCP是面向连接(虚连接)的传输层协议。</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接 只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。可靠有序，不丢不重</p>
</li>
<li><p>4.TCP提供全双工通信。</p>
<ul>
<li>发送缓存准备发送的数据&amp;已发送但尚未收到确认的数据</li>
<li>接收缓存按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</li>
</ul>
</li>
<li><p>TCP面向字节流口。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
<p>流:流入到进程或从进程流出的字节序列。.</p>
</li>
</ol>
<p>TCP传输数据是随机切割数据的</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/2020063020421472.png" alt="img " style="zoom:70%;">

<h2 id="TCP报文段的首部"><a href="#TCP报文段的首部" class="headerlink" title="TCP报文段的首部"></a>TCP报文段的首部</h2><p>注释：见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号<br>确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据<br>偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630210441410.png" alt="img" style="zoom:80%;"></p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630212601599.png" alt="img" style="zoom:80%;">

<p>窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据<br>紧急指针就是告诉TCP从哪里到哪里是紧急数据</p>
<h3 id="TCP的六个控制位"><a href="#TCP的六个控制位" class="headerlink" title="TCP的六个控制位"></a>TCP的六个控制位</h3><p>紧急位URG: URG=1时， 标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p>
<p>确认位ACK: ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p>
<p>推送位PSH: 就是接收端的URG，将PSH=1的数据尽快接收。注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机</p>
<p>复位RST: RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p>
<p>同步位SYN： A和B主机要建立连接，就A先发一个报文，其中SYN=1；B收到之后也回复一个SYN=1的报文，代表接受连接；表明此报文段是一个连接请求/连接接受报文。</p>
<p>终止位FIN; FIN=1时， 表明此报文段发送方数据己发完，要求释放连接。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>SYN=1：(A)要建立连接了！<br>seq=x（随机）：因为还没有数据，所以写什么都无所谓第<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:二段的意思是<br>SYN=1：我(B)同意你(A)建立连接！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=y（随机）：因为还没有数据，所以写什么都无所谓<br>ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据第三<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:三段的意思是<br>SYN=0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p>
<p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630213814996.png" alt="img" style="zoom:80%;"></p>
<h4 id="TCP三次握手特定导致的SYN洪泛攻击"><a href="#TCP三次握手特定导致的SYN洪泛攻击" class="headerlink" title="TCP三次握手特定导致的SYN洪泛攻击"></a>TCP三次握手特定导致的SYN洪泛攻击</h4><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630214925395.png" alt="img" style="zoom:80%;">

<p><font color="red">SYN洪泛攻击，解决方式通过SYN cookie，//TODO</font></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第二段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第三段的意思是:FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第四段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据<br><font color="red">为什么需要等待计时2MSL？</font><br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630215522825.png" alt="img" style="zoom:80%;">

<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><blockquote>
<p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
</blockquote>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>CP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630220542461.png" alt="img" style="zoom:75%;">

<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221424853.png" alt="img" style="zoom:80%;">

<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中4、5、6丢失，7、8到达，但仍然请求发送的数据序号是4。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221636424.png" alt="img" style="zoom:75%;">

<h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630222205619.png" alt="img" style="zoom:75%;">

<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。<br>接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了<br>接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/202006302226272.png" alt="img" style="zoom:80%;"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。<br>但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象<br>解决方法：使用计时器<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630223616929.png" alt="img" style="zoom:75%;"></p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>流量控制是对单独一个来说的，拥塞控制是一群</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630224242515.png" alt="img" style="zoom:75%;">

<h3 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h3><p>这里虽然是四种算法，但是通常是两两结合进行使用</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232411944.png" alt="img" style="zoom:75%;">

<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。<br>之后一段都是线性增长，每次增加1，直至达到网络拥塞状态<br>瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）<br>重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232910475.png" alt="img" style="zoom:75%;"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。<br>不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630233701386.png" alt="img " style="zoom:75%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">PV操作--经典问题分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-31 19:43:52 / 修改時間：20:10:57" itemprop="dateCreated datePublished" datetime="2021-08-31T19:43:52+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、多生产者-多消费者问题"><a href="#一、多生产者-多消费者问题" class="headerlink" title="一、多生产者 - 多消费者问题"></a>一、多生产者 - 多消费者问题</h1><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><blockquote>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610154557852.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a>2 问题分析</h2><ol>
<li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。<br>多生产者-多消费者问题关系分析如下：</p>
<blockquote>
<p>互斥关系： 对缓冲区（盘子）的访问要互斥地进行<br>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果</li>
</ol>
</blockquote>
</li>
</ol>
<p>注意：“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</p>
<ol start="2">
<li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p>
<blockquote>
<p>由以上的同步、互斥关系分析，将多生产者-多消费者问题描绘出图形：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155007683.png" alt="img" style="zoom:80%;"></blockquote>
</li>
<li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。<br>（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）<br><strong>本问题中信号量设置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">semaphore plate = 1;    //盘子中还可以放多少个水果</span><br></pre></td></tr></table></figure></li>
<li><p>模型实现：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155634180.png" alt="img" style="zoom:80%;"></li>
</ol>
<blockquote>
<p>dad：先准备一个苹果，放苹果之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将苹果放入进去（V一下苹果，数量+1）<br>mom：先准备一个橘子，放橘子之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将橘子放入进去（V一下橘子，数量+1）<br>daughter：拿苹果之前，先判断盘子里有没有苹果（P一下苹果，若没有苹果，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）<br>son：拿橘子之前，先判断盘子里有没有橘子（P一下橘子，若没有橘子，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）</p>
</blockquote>
<blockquote>
<p><strong>以下实现了所有进程之间的同步关系：</strong></p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161040503.png" alt="img" style="zoom:80%;">

<p>还需要实现各个进程对盘子（缓冲区）的互斥访问：<br>就是所有进程对盘子进行PV操作，即加锁和解锁的过程</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161420106.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">  semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">  semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">  semaphore plate = 1;    //盘子中还可以放多少个水果</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dad</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个苹果;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(apple);       //允许女儿进程取苹果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mom</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个橘子;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(orange);        //允许儿子进程取橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">daughter</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(apple);</span><br><span class="line">           P(mutex);</span><br><span class="line">          从盘子中取出苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">son</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(orange);</span><br><span class="line">           P(mutex);</span><br><span class="line">           从盘子中取出橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、吸烟者问题"><a href="#二、吸烟者问题" class="headerlink" title="二、吸烟者问题"></a>二、吸烟者问题</h1><h2 id="1、问题描述-1"><a href="#1、问题描述-1" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉，但是要卷起并抽掉一支烟，需要三种材料：烟草、纸、胶水。三个抽烟者中，每一个第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者无限提供三种材料，供应者每次将两种材料放桌子上，拥有剩下材料的抽烟者卷一支烟并抽掉它，并给供应者一个信号完成了，供应者就会把另外两种材料再放桌子上，这个过程一直重复（三个抽烟者轮流抽烟）<br><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319181813857.png" alt="img" style="zoom:80%;"></p>
<h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><h3 id="1、关系分析。"><a href="#1、关系分析。" class="headerlink" title="1、关系分析。"></a>1、关系分析。</h3><p>供应者与三个抽烟者分别是同步关系。由于抽烟者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）</p>
<h3 id="2、整理思路。"><a href="#2、整理思路。" class="headerlink" title="2、整理思路。"></a>2、整理思路。</h3><p>四个进程，供应者作为生产者向三个抽烟者提供材料</p>
<h3 id="3、信号量设置"><a href="#3、信号量设置" class="headerlink" title="3、信号量设置"></a>3、信号量设置</h3><p>信号量offer1、offer2、offer3分别表示烟草和纸组合，烟草和胶水组合，胶水和纸组合。信号量finish表示抽烟完成信号</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183414832.png" alt="img" style="zoom:80%;">

<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183610850.png" alt="img" style="zoom:80%;">

<h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319185437858.png" alt="img" style="zoom:80%;">

<h1 id="二、读者-写者问题"><a href="#二、读者-写者问题" class="headerlink" title="二、读者-写者问题"></a>二、读者-写者问题</h1><h2 id="1、问题描述-2"><a href="#1、问题描述-2" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程 和其他进程（写进程或读进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者再完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320135112282.png" alt="img" style="zoom:80%;">

<h2 id="2、问题分析-1"><a href="#2、问题分析-1" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182746487.png" alt="img" style="zoom:80%;">

<h2 id="3、实现-1"><a href="#3、实现-1" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182822669.png" alt="img" style="zoom:80%;">

<p>写优先：</p>
<p><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182907776.png" alt="img"></p>
<h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由Dijkstra提出并解决的哲学家进餐问题（The Dinning Philosophers Problems）是典型的同步问题。五个哲学家共用一张圆桌，分别坐在周围的五把椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有当他拿到两只筷子时，才能进餐，进餐完毕，放下筷子，继续思考。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用记录型信号量解决哲学家进餐问题，经分析，筷子是邻接资源，在一段时间内只允许一位哲学家使用，可以用一个互斥型信号量表示一只筷子，由这个五个信号量构成信号量数组。<br>semaphore chopstick[5] = {1, 1, 1, 1, 1};<br>所有信号量初始为1，第i位哲学家的活动可描述为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"> 	p(chopstick[i]);  // 申请左边的一只筷子</span><br><span class="line"> 	p(chopstick[(i+1)%5]];  // 申请右边筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	eat</span><br><span class="line"> 	...</span><br><span class="line"> 	v(chopstick[i]);  // 释放左边的一只筷子</span><br><span class="line"> 	v(chopstick[(i+1)%5];  // 释放右边的筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	think</span><br><span class="line"> 	...</span><br><span class="line">&#125; <span class="keyword">while</span> (True);</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>问题</strong>：<br> 哲学家饥饿时总是先拿起左边的筷子，之后拿起右边的筷子，成功后便可进餐。进餐后又放下左边的筷子，再放下右边的筷子。显然不会有两个相邻的哲学家同时进餐，有可能引起<strong>死锁</strong>：即每一个哲学家都拿起左边的筷子，当他们拿右边筷子，便会无限等待。</font></p>
<p><strong>共有三种解决办法：</strong></p>
<h2 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h2><ul>
<li><p><strong>利用and型信号量机制</strong>：仅当哲学家左右两只筷子均可用时，才允许他拿起筷子进餐。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>另一种方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, mutex = 1; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(mutex);  // 申请临界资源</span><br><span class="line">	p(chopstick[i]);  // 拿左</span><br><span class="line">	p(chopstick[(i+1)%5]);  // 拿右</span><br><span class="line">	v(mutex);  // 释放临界资源</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>至多允许有<strong>四位哲学家</strong>同时去拿左边筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放他的两只筷子，从而使更多的哲学家能够进餐。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, L = 4; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(L);</span><br><span class="line">	p(chopstick[i]);</span><br><span class="line">	p(chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(L);</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
<li><p>规定奇数号哲学家先拿起左边筷子，然后在去拿右边筷子，偶数号相反。按此规定，将是1,2号哲学家竞争1号筷子，3,4竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后才去竞争偶数号筷子，最后总有人获得两只筷子。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (i % 2 == 0):</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">布隆过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-30 20:11:22 / 修改時間：20:43:30" itemprop="dateCreated datePublished" datetime="2021-08-30T20:11:22+08:00">2021-08-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="布隆过滤器的理解"><a href="#布隆过滤器的理解" class="headerlink" title="布隆过滤器的理解"></a>布隆过滤器的理解</h1><h2 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h2><p>黑名单问题：</p>
<p>需求大致为：100亿个url为黑名单，搜索公司想让用户搜索黑名单里的url时，不给用户显示。如果url输入这100亿黑名单则返回True，否则返回False。假设每个url64kb。</p>
<p>如果使用hashset实现该功能的话，需要6400亿字节（640G）的内存。浪费大量空间，不现实。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>算法：</p>
<blockquote>
<p>准备k个相互独立哈希函数，长度为n的比特数组，比特数组的每个比特位初始化为0。</p>
<p>存入流程：</p>
<ol>
<li>使用k个哈希函数，计算某个url的哈希值，使用哈希值对n取模。<strong>idx = hash(url)%n</strong></li>
<li>将相对的比特数组位置描黑。 比特数组【idx】 = 1</li>
</ol>
<p>while k个哈希函数：</p>
<p>​    idx = hash(url) % n</p>
<p>​    比特数组【idx】 = 1</p>
<p>查询流程：</p>
<p>使用k个哈希函数，计算哈希值，对n取模，如果所有位置都为1，则该url属于这100亿黑名单。</p>
</blockquote>
<p>重要公式：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317223869.png" alt="img " style="zoom:150%;">

<p>p为预计的失误率。n为样本个数。m为最优比特位个数。</p>
<p> Hash 函数个数选取最优数目：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317394641.png" alt="img" style="zoom:150%;">

<p>m为比特位个数，n为样本个数，k为哈希函数个数</p>
<p>在确定m和k后计算失误率：</p>
<center>p = (1-e<sup>(-kn/m)</sup>)<sup>k</sup>​</center>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">一致性哈希</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-30 19:38:37 / 修改時間：20:11:52" itemprop="dateCreated datePublished" datetime="2021-08-30T19:38:37+08:00">2021-08-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么，我们应该怎样做呢？</p>
<h3 id="落伍的方式"><a href="#落伍的方式" class="headerlink" title="落伍的方式"></a>落伍的方式</h3><blockquote>
<p>原始的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上。</p>
<p>举例说明，仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的key，假设图片名称是不重复的，那么，我们可以使用如下公式，计算出图片应该存放在哪台服务器上。</p>
<p><strong>hash（图片名称）% N</strong></p>
</blockquote>
<p><font color="red">哈希函数最重要的一个特征：无限的输入经过哈希函数得到的哈希值均匀的分布在有限的输出域上。</font></p>
<p><font color="red">假设某哈希函数输出16位数据，可以截取前八位和后八位作为两个相互独立的哈希函数，假设这两个哈希函数为a和b，则a+1b,a+2b,a+3b….也是相互独立的，我们可以以此方式拼接处无数个相互独立的哈希函数。</font></p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830194520098.png" alt="image-20210830194520098" style="zoom:60%;">

<h3 id="上述方法存在的问题："><a href="#上述方法存在的问题：" class="headerlink" title="上述方法存在的问题："></a>上述方法存在的问题：</h3><blockquote>
<p>如果3台缓存服务器已经不能满足我们的缓存需求，怎么办呢？多增加两台缓存服务器，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。</p>
</blockquote>
<h2 id="一致性哈希算法的基本概念"><a href="#一致性哈希算法的基本概念" class="headerlink" title="一致性哈希算法的基本概念"></a>一致性哈希算法的基本概念</h2><p>一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对2^32取模，什么意思呢？</p>
<p>首先，我们把二的三十二次方想象成一个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195432751.png" alt="image-20210830195432751" style="zoom:80%;">

<p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p>
<p>我们把这个由2的32次方个点组成的圆环称为hash环。</p>
<p>那么，一致性哈希算法与上图中的圆环有什么关系呢？</p>
<blockquote>
<p>仍然以之前描述的场景为例，假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p>
</blockquote>
<blockquote>
<p><strong>hash（服务器A的IP地址） %  2^32</strong></p>
</blockquote>
<p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意:</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/020717_1707_3.png" alt="img " style="zoom:150%;">

<p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中</p>
<p><strong>hash（服务器B的IP地址） %  2^32</strong></p>
<p><strong>hash（服务器C的IP地址） %  2^32</strong></p>
<p>通过上述方法，可以将服务器B与服务器C映射到上图中的hash环上，示意图如下</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195650374.png" alt="image-20210830195650374" style="zoom:40%;">

<p>假设3台服务器映射到hash环上以后如上图所示（当然，这是理想的情况)</p>
<p>好了，到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环上，那么使用同样的方法，我们也可以将需要缓存的对象映射到hash环上。</p>
<p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。</p>
<blockquote>
<p> <strong>hash（图片名称） %  2^32</strong></p>
</blockquote>
<p>映射后的示意图如下，下图中的橘黄色圆形表示图片</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195804698.png" alt="image-20210830195804698" style="zoom:40%;">

<p>好了，现在服务器与图片都被映射到了hash环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的图片将会被缓存到服务器A上，为什么呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器就是A服务器，所以，上图中的图片将会被缓存到服务器A上，如下图所示。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195840410.png" alt="image-20210830195840410" style="zoom:33%;">

<p>一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p>
<p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830195944118.png" alt="image-20210830195944118" style="zoom:33%;">

<p>1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p>
<h2 id="一致性哈希算法的优点"><a href="#一致性哈希算法的优点" class="headerlink" title="一致性哈希算法的优点"></a>一致性哈希算法的优点</h2><p>假设，服务器B出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以后示意图如下。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200147236.png" alt="image-20210830200147236" style="zoom:33%;">

<p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200208142.png" alt="image-20210830200208142" style="zoom:33%;">

<p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点，如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p>
<h2 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h2><p>在介绍一致性哈希的概念时，我们理想化的将3台服务器均匀的映射到了hash环上，如下图所示</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200311037.png" alt="image-20210830200311037" style="zoom:30%;">

<p>在实际的映射中，服务器可能会被映射成如下模样。<font color="red">哈希函数在大数据下保证大致的平均（并不是绝对平均）。</font></p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200339888.png" alt="image-20210830200339888" style="zoom:33%;">

<p>如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上，如下图所示。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200448650.png" alt="image-20210830200448650" style="zoom:33%;">

<p>如上图所示就造成了服务器A负责大量工作，而服务器B和C则很闲。没有达到负载均衡的目的。</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>由于我们只有3台服务器，当我们把服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，当hash环偏斜以后，缓存往往会极度不均衡的分布在各服务器上。</p>
<p>如果想要均衡的将缓存分布到3台服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，但是，真实的服务器资源只有3台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash环如下。</p>
<img src="/2021/08/30/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/image-20210830200726308.png" alt="image-20210830200726308" style="zoom:33%;">

<p>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</p>
<p>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p>
<p><font color="red">保存两个字典：每个服务器对应的多个虚拟节点；每个虚拟节点相对应的服务器。</font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/29/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/29/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">虚拟内存管理、页面置换算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-29 17:06:34" itemprop="dateCreated datePublished" datetime="2021-08-29T17:06:34+08:00">2021-08-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">内存管理的概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-28 23:27:51" itemprop="dateCreated datePublished" datetime="2021-08-28T23:27:51+08:00">2021-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-29 17:02:53" itemprop="dateModified" datetime="2021-08-29T17:02:53+08:00">2021-08-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、内存管理的概念"><a href="#一、内存管理的概念" class="headerlink" title="一、内存管理的概念"></a>一、内存管理的概念</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210828232818560.png" alt="image-20210828232818560" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227131925434.png" alt="img " style="zoom:100%;">

<h2 id="二、覆盖与交换"><a href="#二、覆盖与交换" class="headerlink" title="二、覆盖与交换"></a>二、覆盖与交换</h2><h3 id="1-覆盖技术"><a href="#1-覆盖技术" class="headerlink" title="1. 覆盖技术"></a>1. 覆盖技术</h3><p>将程序分成多个段，常用的段常驻内存的固定区，不常用的段放在内存的覆盖区，在需要的时 候调入内存</p>
<h3 id="2-交换技术"><a href="#2-交换技术" class="headerlink" title="2. 交换技术"></a>2. 交换技术</h3><p>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程 换入内存，使用中级调度来完成</p>
<ul>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？</li>
</ul>
<blockquote>
<p>1.具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的/0速度比文件区的更快。</p>
</blockquote>
<ul>
<li>什么时候应该交换?</li>
</ul>
<blockquote>
<p> 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出–些进程;.如果缺页率明显下降，就可以暂停换出。</p>
</blockquote>
<ul>
<li>应该换出哪些进程?</li>
</ul>
<blockquote>
<p>3.可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p>
</blockquote>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713194229.png" alt="img " style="zoom:150%;">

<h2 id="三、连续分配管理方式"><a href="#三、连续分配管理方式" class="headerlink" title="三、连续分配管理方式"></a>三、连续分配管理方式</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829110339431.png" alt="image-20210829110339431 " style="zoom:80%;">

<p>连续分配指为进程分配的必须是一个连续的内存空间</p>
<p>内部碎片指分配给某进程的内存区域中，有些部分没有用上</p>
<p>外部碎片指内存中的某些空闲分区由于太小而难以利用</p>
<h3 id="1-单一连续分配"><a href="#1-单一连续分配" class="headerlink" title="1. 单一连续分配"></a>1. 单一连续分配</h3><ul>
<li><p>介绍</p>
<p>内存被分为系统区和用户区；系统区用于存放操作系统相关数据，用户区用于存放用户进 程相关数据</p>
</li>
<li><p>图示</p>
</li>
</ul>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713195680.png" alt="img" style="zoom:100%;">

<ul>
<li>特点：内存中只能有一道用户程序，用户程序独占整个用户区</li>
<li>优点：实现简单，无外部碎片</li>
<li>缺点：只能用于单用户、单系统的操作系统中，有内部碎片</li>
</ul>
<h3 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2. 固定分区分配"></a>2. 固定分区分配</h3><p>(1) 介绍</p>
<p>i. 将整个用户区划分成若干个固定大小的分区，在每个分区中只装入一道作业，某个作业 独占一个固定分区</p>
<p>ii. 固定分区分配分为分区大小相等和分区大小不相等</p>
<p>(2) 图示</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132006159.png" alt="img" style="zoom:80%;">

<p>(3) 特点：无外部碎片，有内部碎片</p>
<p>(4) 需要使用分区说明表实现各个分区的分配与回收</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132009447.png" alt="img" style="zoom:80%;">

<h3 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3. 动态分区分配"></a>3. 动态分区分配</h3><p>(1) 介绍</p>
<p>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使 分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的</p>
<p>(2) 系统使用空闲分区表和空闲分区链记录内存的使用情况</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132015603.png" alt="img" style="zoom:80%;">

<p>(3) 当一个作业装入内存时，按照动态分区分配算法，从空闲分区表/链中选出一个分区分配给 该作业</p>
<p>(4) 根据动态分区分配算法算得进程5(4MB)应将分区1分配给该进程</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132020810.png" alt="img" style="zoom:80%;">

<p>(5) 其余几种情况</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132026498.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132028740.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132031463.png" alt="img" style="zoom:80%;">

<p>(6) 特点：无内部碎片，有外部碎片</p>
<p>(7) 拼凑技术：将原本不相邻的空闲分区合并成一个更大的空闲分区，用于解决碎片分区不满 足进程的需求的问题</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132041224.png" alt="img" style="zoom:80%;">

<h2 id="四、动态分区分配算法"><a href="#四、动态分区分配算法" class="headerlink" title="四、动态分区分配算法"></a>四、动态分区分配算法</h2><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132046314.png" alt="img" style="zoom:80%;">

<h3 id="1-首次适应算法"><a href="#1-首次适应算法" class="headerlink" title="1. 首次适应算法"></a>1. 首次适应算法</h3><p>思想：空闲分区以地址递增的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132051978.png" alt="img" style="zoom:80%;">

<p>注意：链表中的结点即使大小发生变化后，结点顺序依旧不变，因为结点只按照地址排序</p>
<h3 id="2-最佳适应算法"><a href="#2-最佳适应算法" class="headerlink" title="2. 最佳适应算法"></a>2. 最佳适应算法</h3><p>思想：空闲分区以容量递增的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132059944.png" alt="img" style="zoom:80%;">

<p>注意：链表中的结点当大小发生变化之后，需要调整结点顺序</p>
<h3 id="3-最坏适应算法"><a href="#3-最坏适应算法" class="headerlink" title="3. 最坏适应算法"></a>3. 最坏适应算法</h3><p>思想：空闲分区以容量递减的次序排列，每次分配内存空间时顺序查找空闲分区表/链，找到大 小能满足要求的第一个空闲分区</p>
<p>缺点：每次都选择最大的分区进行分配，会导致较大的连续空间被迅速用完，当之后有大进程 到达时，无内存空间可分配</p>
<h3 id="4-邻近适应算法"><a href="#4-邻近适应算法" class="headerlink" title="4. 邻近适应算法"></a>4. 邻近适应算法</h3><p>思想：空闲分区以地址递增的次序排列，每次分配内存空间时从上次查找结束的位置开始查找 空闲分区表/链，找到大小能满足要求的第一个空闲分区</p>
<h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132110832.png" alt="img" style="zoom:80%;">

<h2 id="五、基本分页存储管理"><a href="#五、基本分页存储管理" class="headerlink" title="五、基本分页存储管理"></a>五、基本分页存储管理</h2><p>连续分配：为进程分配的是连续的内存空间<br>非连续分配：为进程分配的是分散的内存空间，可以将进程分成几个部分，分散的放入空闲区</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132118893.png" alt="img" style="zoom:80%;">

<h3 id="1-页框"><a href="#1-页框" class="headerlink" title="1. 页框"></a>1. 页框</h3><p>将内存空间分为一个个大小相等的分区，每个分区就是一个页框，<br>每个页框有一个编号，即页框号，页框号从0开始</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132142593.png" alt="img" style="zoom:80%;">

<h3 id="2-页面"><a href="#2-页面" class="headerlink" title="2. 页面"></a>2. 页面</h3><p>将进程的逻辑地址空间分为与页框大小相等的一个个部分，<br>每个部分称为一个页或页面，每个页面都有一个编号，即页号，页号从0开始</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132138965.png" alt="img" style="zoom:80%;">

<h3 id="3-分页存储"><a href="#3-分页存储" class="headerlink" title="3. 分页存储"></a>3. 分页存储</h3><p>(1) 操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中， 即进程的页面与内存的页框有一一对应的关系</p>
<p>(2) 各个页面无需连续存放，可以放到不相邻的各个页框中</p>
<p>(3) 页框不能太大，否则可能会产生过大的内部碎片造成浪费</p>
<h3 id="4-页表"><a href="#4-页表" class="headerlink" title="4. 页表"></a>4. 页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，需要为每个进程建立一张页表<br>(页表通常存在于进程控制块PCB中)</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132147655.png" alt="img" style="zoom:80%;">

<p>(1) 页表项连续存放，因此页号可以是隐藏的，不占用存储空间 (类比数组)</p>
<p>(2) 页表记录的只是内存块号，而不是内存块的物理起始地址</p>
<p>n号内存块的物理起始地址 = n * 内存块大小</p>
<h3 id="5-页号、页内偏移量的计算"><a href="#5-页号、页内偏移量的计算" class="headerlink" title="5. 页号、页内偏移量的计算"></a>5. 页号、页内偏移量的计算</h3><p>(1) 问题描述：在某计算机系统中，页面大小是50B；某进程逻辑地址空间大小为200B，则逻 辑地址110对应的页号、页内偏移量是多少？</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132158205.png" alt="img" style="zoom:80%;">

<p>(2) 计算方法：</p>
<p>页号 = 逻辑地址 / 页面长度</p>
<p>页内偏移量 = 逻辑地址 % 页面长度</p>
<p>物理地址 = 页号对应页框的起始地址 + 页内偏移量</p>
<p>页号对应页框的起始地址 = 根据页号查页表得到的页框号 * 页框大小</p>
<p>(3) 计算结果：</p>
<p>页号 = 110 / 50 = 2</p>
<p>页内偏移量 = 110 % 50 = 10</p>
<h3 id="6-逻辑地址结构"><a href="#6-逻辑地址结构" class="headerlink" title="6. 逻辑地址结构"></a>6. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132204229.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132218741.png" alt="img" style="zoom:80%;">

<h3 id="基本地址变换机构"><a href="#基本地址变换机构" class="headerlink" title="基本地址变换机构"></a>基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器(PTR) ，存放页表在内存中的起始地址F和页表长度M。</p>
<p>进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:页面大小是2的整数幂</p>
<p>例子：</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829150011013.png" alt="image-20210829150011013" style="zoom:80%;">

<h3 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829150345182.png" alt="image-20210829150345182" style="zoom:80%;">

<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。( 因为程序中存在大量的循环)</p>
<p>空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。( 因为很多数据在内存中都是连续存放的)</p>
<p>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p>
<h4 id="什么是快表？"><a href="#什么是快表？" class="headerlink" title="什么是快表？"></a>什么是快表？</h4><p>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829151013541.png" alt="image-20210829151013541" style="zoom:80%;">

<p>小结：</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/image-20210829151227125.png" alt="image-20210829151227125" style="zoom:80%;">

<h2 id="六、基本分段存储管理"><a href="#六、基本分段存储管理" class="headerlink" title="六、基本分段存储管理"></a>六、基本分段存储管理</h2><p>与分页最大的区别：进程所划分的基本单位不同 (各段的大小可以不同)</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>(1) 进程按照自身的逻辑关系划分为若干个段，每段都有一个段名，每段从0开始编址</p>
<p>(2) 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>
<h3 id="2-逻辑地址结构"><a href="#2-逻辑地址结构" class="headerlink" title="2. 逻辑地址结构"></a>2. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/2020122713222756.png" alt="img" style="zoom:80%;">

<h3 id="3-段表"><a href="#3-段表" class="headerlink" title="3. 段表"></a>3. 段表</h3><p>记录各个逻辑段与实际的物理位置存放地址的对应关系</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132249865.png" alt="img" style="zoom:80%;">

<h3 id="4-知识回顾-1"><a href="#4-知识回顾-1" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132253814.png" alt="img" style="zoom:150%;">

<h2 id="七、段页式管理方式"><a href="#七、段页式管理方式" class="headerlink" title="七、段页式管理方式"></a>七、段页式管理方式</h2><p>段页式管理 = 分段 + 分页</p>
<h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>(1) 将进程按照逻辑模块分段，再将各段分页 (如每个页面4KB)</p>
<p>(2) 将内存空间按照4KB划分成多个页框</p>
<p>(3) 将进程的各页面分别装入对应的页框中</p>
<img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132308534.png" alt="img" style="zoom:80%;">

<h3 id="2-段表、页表"><a href="#2-段表、页表" class="headerlink" title="2. 段表、页表"></a>2. 段表、页表</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132314153.png" alt="img" style="zoom:80%;">

<h3 id="3-逻辑地址结构"><a href="#3-逻辑地址结构" class="headerlink" title="3. 逻辑地址结构"></a>3. 逻辑地址结构</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132322294.png" alt="img" style="zoom:80%;">

<h3 id="4-知识回顾-2"><a href="#4-知识回顾-2" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/20201227132328319.png" alt="img" style="zoom:80%;">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/28/%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">死锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-28 22:12:37 / 修改時間：23:06:19" itemprop="dateCreated datePublished" datetime="2021-08-28T22:12:37+08:00">2021-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、死锁的概念"><a href="#一、死锁的概念" class="headerlink" title="一、死锁的概念"></a>一、死锁的概念</h2><h3 id="1-死锁、饥饿、死循环的区别"><a href="#1-死锁、饥饿、死循环的区别" class="headerlink" title="1. 死锁、饥饿、死循环的区别"></a>1. 死锁、饥饿、死循环的区别</h3><p>(1) 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进<br>(2) 饥饿：长期得不到想要的资源，某进程无法向前推进<br>(3) 死循环：某进程执行过程中一直跳不出某个循环</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103625525.png" alt="img" style="zoom:150%;">

<h3 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2. 死锁产生的必要条件"></a>2. 死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，若有一个不满足，死锁就不会发生</p>
<p>(1) 互斥条件：对互斥使用的资源的争夺才会导致死锁<br>(2) 不剥夺条件：进程获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放<br>(3) 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又 被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放<br>(4) 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被 下一个进程所请求</p>
<p>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁</p>
<h3 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3.死锁的处理策略"></a>3.死锁的处理策略</h3><p>(1) 预防死锁：破坏死锁产生的四个必要条件中的一个或几个<br>(2) 避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁<br>(3) 死锁的检测和解除：允许死锁的发生，操作系统检测出死锁后，会采取措施解除死锁</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103641570.png" alt="img" style="zoom:150%;">

<h2 id="二、死锁的处理策略-—-预防死锁"><a href="#二、死锁的处理策略-—-预防死锁" class="headerlink" title="二、死锁的处理策略 — 预防死锁"></a>二、死锁的处理策略 — 预防死锁</h2><img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828221812000.png" alt="image-20210828221812000" style="zoom:67%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828221834071.png" alt="image-20210828221834071" style="zoom:70%;">

<p><strong>破坏互斥条件</strong></p>
<p>只有对必须互斥使用的资源的争夺才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。<font color="red">比如:SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如用SPOOLing技术将打印机改造为共享设备….</font></p>
<p>该策略的缺点：并不是所有的资源都可以改造成可以共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103647730.png" alt="img" style="zoom:150%;">

<h2 id="三、死锁的处理策略-—-避免死锁"><a href="#三、死锁的处理策略-—-避免死锁" class="headerlink" title="三、死锁的处理策略 — 避免死锁"></a>三、死锁的处理策略 — 避免死锁</h2><h3 id="1-安全序列的介绍"><a href="#1-安全序列的介绍" class="headerlink" title="1. 安全序列的介绍"></a>1. 安全序列的介绍</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找 出一个安全序列，系统就是安全状态 (安全序列可能有多个)</p>
<p>如果分配了资源以后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味 着之后可能所有进程都无法顺利的执行下去</p>
<p>注意：</p>
<p>(1) 如果系统处于安全状态，就一定不会发生死锁<br>(2) 如果系统进入不安全状态，就可能发生死锁<br>(3) 处于不安全状态未必会发生死锁，但发生死锁时一定处于不安全状态</p>
<h3 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h3><p>思想：在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，由此决定是否答应 资源分配请求</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103704759.png" alt="img" style="zoom:80%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/202012271037089.png" alt="img" style="zoom:90%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828225137636.png" alt="image-20210828225137636" style="zoom:80%;">

<img src="/2021/08/28/%E6%AD%BB%E9%94%81/image-20210828225049182.png" alt="image-20210828225049182" style="zoom:80%;">

<p>注：如果银行家算法是安全性算法，说明此时系统处于安全状态，不会发生死锁</p>
<h2 id="四、死锁的处理策略-—-死锁的检测与解除"><a href="#四、死锁的处理策略-—-死锁的检测与解除" class="headerlink" title="四、死锁的处理策略 — 死锁的检测与解除"></a>四、死锁的处理策略 — 死锁的检测与解除</h2><h3 id="1-死锁的检测"><a href="#1-死锁的检测" class="headerlink" title="1. 死锁的检测"></a>1. 死锁的检测</h3><p>为了能对系统是否发生了死锁进行检测，必须：</p>
<p>(1) 用资源分配图保存资源的请求和分配信息<br>(2) 提供一种算法，利用上述信息检测系统是否进入死锁状态</p>
<img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103722593.png" alt="img" style="zoom:150%;">

<p>P2进程请求1个资源，但R1的3个资源都已经分配出去，无法执行；P1进程请求1个资 源，R2剩余1个资源，P1执行；P1执行完毕之后，释放自身的所有资源，P1的三条边全 部消除；R1剩余的资源可满足P2进程；P2进程执行，P2的三条边全部消除</p>
<p>注意：</p>
<p>(1) 如果按照上述过程可以消除所有的边，表示此图可完全简化，不会发生死锁<br>(2) 如果不能消除所有的边，说明发生了死锁<br>(3) 最终还连着边的那些进程就是死锁进程</p>
<h3 id="2-死锁的解除"><a href="#2-死锁的解除" class="headerlink" title="2. 死锁的解除"></a>2. 死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁，解除死锁的方法有：</p>
<p>(1) 资源剥夺法</p>
<p>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程；但是应防止被 挂起的进程长时间得不到资源而饥饿</p>
<p>(2) 撤销进程法</p>
<p>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源</p>
<p>(3) 进程回退法</p>
<p>让死锁进程回退到足以避免死锁的地步 (这就要求系统记录历史信息、设置还原点)</p>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/08/28/%E6%AD%BB%E9%94%81/20201227103747269.png" alt="img" style="zoom:150%;">


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/" class="post-title-link" itemprop="url">进程管理03</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-28 19:15:52 / 修改時間：20:41:18" itemprop="dateCreated datePublished" datetime="2021-08-28T19:15:52+08:00">2021-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、进程同步、互斥"><a href="#一、进程同步、互斥" class="headerlink" title="一、进程同步、互斥"></a>一、进程同步、互斥</h2><h3 id="1-进程同步的概念"><a href="#1-进程同步的概念" class="headerlink" title="1. 进程同步的概念"></a>1. 进程同步的概念</h3><blockquote>
<p>进程同步指的是协调多个并发执行进程的工作先后次序</p>
</blockquote>
<h3 id="2-进程互斥的概念"><a href="#2-进程互斥的概念" class="headerlink" title="2. 进程互斥的概念"></a>2. 进程互斥的概念</h3><blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源</p>
<p>进程互斥指的是当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待， 当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源</p>
</blockquote>
<h3 id="3-访问临界资源"><a href="#3-访问临界资源" class="headerlink" title="3. 访问临界资源"></a>3. 访问临界资源</h3><p>对临界资源的互斥访问，可在逻辑上分为如下四个部分：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102144475.png" alt="img" style="zoom:150%;">

<h3 id="4-访问临界资源需要遵循的原则"><a href="#4-访问临界资源需要遵循的原则" class="headerlink" title="4. 访问临界资源需要遵循的原则"></a>4. 访问临界资源需要遵循的原则</h3><ol>
<li>空闲让进  <ul>
<li>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
</ul>
</li>
<li>忙则等待 <ul>
<li> 当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
</ul>
</li>
<li>有限等待  <ul>
<li>对请求访问的进程，应保证能在有限时间内进入临界区 (保证不会饥饿)</li>
</ul>
</li>
<li>让权等待 <ul>
<li>当进程不能进入临界区，应当立即释放处理机，防止进程忙等待 (不应该让他占用处理机 一直执行循环无法前进，应当得知无法进入临界区时不执行循环，直接切换进程)</li>
</ul>
</li>
</ol>
<h3 id="5-知识回顾"><a href="#5-知识回顾" class="headerlink" title="5. 知识回顾"></a>5. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102207229.png" alt="img" style="zoom:80%;">

<h2 id="二、进程互斥的软件实现方法"><a href="#二、进程互斥的软件实现方法" class="headerlink" title="二、进程互斥的软件实现方法"></a>二、进程互斥的软件实现方法</h2><h3 id="1-单标志法"><a href="#1-单标志法" class="headerlink" title="1. 单标志法"></a>1. 单标志法</h3><p>思想：一个进程访问完临界区后会把使用临界区的权限交给另一个进程，即每个进程进入临界 区的权限只能被另一个进程赋予</p>
<p>过程：<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102234925.png" alt="img" style="zoom:150%;"></p>
<p>若P0要访问临界区，turn变为0，P1会一直在⑤循环，无法向下进行，P0访问完，将 turn改为1，P1跳出循环，P1可访问临界区</p>
<p>注意：<br>(1) 该算法可以实现同一时刻最多只允许一个进程访问临界区<br>(2) 如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么此时虽然临界区 空闲，但一直不允许P1访问，因此，单标志法存在的问题是：违背空闲让进原则</p>
<h3 id="2-双标志先检查法"><a href="#2-双标志先检查法" class="headerlink" title="2. 双标志先检查法"></a>2. 双标志先检查法</h3><p>思想：设置一个布尔数组flag[]，数组中各元素标记各进程是否想进入临界区，true表示想进入， false表示不想进入；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界 区，如果没有，把自身对应的标志flag[i]改为true，之后开始访问临界区</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102253393.png" alt="img " style="zoom:150%;">

<p>存在的问题：P0进程进入之后，在修改P0为true之前，切换到P1，P1检查无别的进程 想进入临界区，故会将P1改为true，导致两个进程都为true，会同时访问</p>
<p>注意：<br>(1) 双标志先检查法存在的问题是：违背忙则等待原则<br>(2) 出现的原因：进入区的检查和上锁不是一气呵成的</p>
<h3 id="3-双标志后检查法"><a href="#3-双标志后检查法" class="headerlink" title="3. 双标志后检查法"></a>3. 双标志后检查法</h3><p>思想：双标志先检查法的改版，先上锁后检查，谁想进谁直接将自身改为true，不关心其他进 程，改为true之后，再检查有没有其他进程想访问</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102304319.png" alt="img" style="zoom:150%;">

<blockquote>
<p>存在的问题：P0想进入，P0改为true，在检查之前切换到P1，P1想进入，改为true，                      </p>
<p>导致两个进程都为true，谁都无法访问临界区，产生饥饿现象</p>
</blockquote>
<p>注意：<br>(1) 双标志后检查法解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则<br>(2) 出现的原因：进入区的检查和上锁不是一气呵成的</p>
<h3 id="4-Peterson算法"><a href="#4-Peterson算法" class="headerlink" title="4. Peterson算法"></a>4. Peterson算法</h3><p>思想：双标志后检查法的改版，若两个进程都想进入临界区，可以主动让对方优先访问临界区</p>
<p>过程：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102354672.png" alt="img" style="zoom:120%;">

<p>进入区做了三件事：1. 主动争取 2. 主动谦让 3. 检查对方</p>
<p>注意：<br>Peterson算法解决了空闲让进，忙则等待，有限等待三个原则，但违背了让权等待原则</p>
<h3 id="5-知识回顾-1"><a href="#5-知识回顾-1" class="headerlink" title="5. 知识回顾"></a>5. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102412523.png" alt="img" style="zoom:150%;">

<h2 id="三、进程互斥的硬件实现方法"><a href="#三、进程互斥的硬件实现方法" class="headerlink" title="三、进程互斥的硬件实现方法"></a>三、进程互斥的硬件实现方法</h2><h3 id="1-中断屏蔽方法"><a href="#1-中断屏蔽方法" class="headerlink" title="1. 中断屏蔽方法"></a>1. 中断屏蔽方法</h3><p>利用开/关中断指令实现，与原语思想相同，即在某进程开始访问临界区到结束访问为止都不允 许被中断，也就不能发生进程切换，因此也不可能出现两个进程同时访问临界区的情况</p>
<p>优点：简单、高效</p>
<p>缺点：不适用于多处理机；只适用于内核进程，不适用于用户进程</p>
<h3 id="2-TestAndSet指令-TS指令"><a href="#2-TestAndSet指令-TS指令" class="headerlink" title="2. TestAndSet指令(TS指令)"></a>2. TestAndSet指令(TS指令)</h3><p>又称为TestAndSetLock指令(TSL指令)</p>
<p>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102423874.png" alt="img" style="zoom:150%;">

<p>若刚开始lock是false(没有进程访问临界区)，则TSL返回值是false，不会卡在while循环，此 进程可以访问临界区；若刚开始是true(有进程在访问临界区)，TSL返回值是true，会卡在while 循环，直到正在访问临界区的进程访问结束，将lock值改为false，此进程才可进入临界区</p>
<p>优点：实现简单，适用于多处理机环境</p>
<p>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从 而导致忙等</p>
<h3 id="3-Swap指令"><a href="#3-Swap指令" class="headerlink" title="3.Swap指令"></a>3.Swap指令</h3><p>又称为Exchange指令(XCHG指令)</p>
<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102445294.png" alt="img" style="zoom:150%;">

<p>当lock为false(无进程访问临界区时)才可以跳出循环，访问临界区</p>
<p>优点：实现简单，适用于多处理机环境</p>
<p>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令， 从而导致忙等</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102454314.png" alt="img" style="zoom:150%;">

<h2 id="四、信号量机制"><a href="#四、信号量机制" class="headerlink" title="四、信号量机制"></a>四、信号量机制</h2><h3 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1. 产生原因"></a>1. 产生原因</h3><p>进程互斥的四种软件实现方法、三种硬件实现方法都无法实现让权等待，也就是进程无法进入 临界区时，会占用处理机一直循环(因为并没有必要一直循环，可以直接切换进程)</p>
<h3 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h3><ol>
<li>信号量就是一个变量，表示系统中某种资源的数量</li>
<li>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作</li>
<li> 一对原语是：wait(S)原语和signal(S)原语，S是信号量 (将此对原语理解为函数)</li>
<li> 通常将wait(S)称为P操作，写为P(S)；通常将signal(S)称为V操作，写为V(S)</li>
</ol>
<h3 id="3-整型信号量"><a href="#3-整型信号量" class="headerlink" title="3. 整型信号量"></a>3. 整型信号量</h3><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量，如下：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102523953.png" alt="img" style="zoom:150%;">

<h3 id="4-记录型信号量"><a href="#4-记录型信号量" class="headerlink" title="4. 记录型信号量"></a>4. 记录型信号量</h3><p>在整型信号量(不满足让权等待)的基础上进行改进，使用记录型数据结构表示信号量，如下：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102528780.png" alt="img" style="zoom:150%;">

<p>举个例子：<br>计算机有两台打印机，需要分配给不同的进程使用，value初始值为2，等待队列为空：</p>
<ol>
<li>P0进程使用打印机，执行wait，value–，value值成为1</li>
<li>P1进程使用打印机，执行wait，value–，value值成为0 (无打印机可用)</li>
<li>P2进程使用打印机，执行wait，value–，value值成为-1，value &lt; 0，执行block，成为等 待队列的队首 (无法使用时，不会占用处理机执行循环，未出现忙等现象)</li>
<li>P3进程使用打印机，执行wait，value–，value值成为-2，value &lt; 0，执行block，成为等 待队列的第二个进程</li>
<li>切换到P0，P0使用完打印机，执行signal，value++，value值成为-1，value &lt;= 0，执行 wakeup，唤醒等待队列的队首进程(P2进程)，P2移出等待队列，P2使用打印机</li>
<li>切换到P2，P2使用完打印机，执行signal，value++，value值成为-1，value &lt;= 0，执行 wakeup，唤醒等待队列的队首进程(P3进程)，P3移出等待队列，P3使用打印机</li>
</ol>
<h3 id="5-知识回顾-2"><a href="#5-知识回顾-2" class="headerlink" title="5.知识回顾"></a>5.知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102545233.png" alt="img" style="zoom:150%;">

<h2 id="五、用信号量实现进程互斥、同步、前驱关系"><a href="#五、用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="五、用信号量实现进程互斥、同步、前驱关系"></a>五、用信号量实现进程互斥、同步、前驱关系</h2><h3 id="1-信号量机制实现进程互斥"><a href="#1-信号量机制实现进程互斥" class="headerlink" title="1. 信号量机制实现进程互斥"></a>1. 信号量机制实现进程互斥</h3><p>设置互斥信号量mutex，初值为1，如图：</p>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102555237.png" alt="img" style="zoom:150%;">

<p>注意：<br>(1) 对不同的临界资源需要设置不同的互斥信号量<br>(2) P、V操作必须成对出现，缺少P无法保证互斥访问，缺少V无法唤醒等待进程</p>
<h3 id="2-信号量机制实现进程同步"><a href="#2-信号量机制实现进程同步" class="headerlink" title="2. 信号量机制实现进程同步"></a>2. 信号量机制实现进程同步</h3><p>实现进程同步，必须保证进程的执行是有先后次序的，即一前一后</p>
<ol>
<li>设置同步信号量S，初值为0 (理解为刚开始没有资源，P1进程想使用必须通过P2产生资源)</li>
<li>在前进程之后执行V(S)</li>
<li>在后进程之前执行P(S)</li>
</ol>
<img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102614435.png" alt="img" style="zoom:150%;">

<h3 id="3-信号量机制实现前驱关系"><a href="#3-信号量机制实现前驱关系" class="headerlink" title="3. 信号量机制实现前驱关系"></a>3. 信号量机制实现前驱关系</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102623827.png" alt="img" style="zoom:150%;">

<h3 id="4-知识回顾-1"><a href="#4-知识回顾-1" class="headerlink" title="4. 知识回顾"></a>4. 知识回顾</h3><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102635850.png" alt="img" style="zoom:150%;">

<h2 id="六、生产者-消费者问题"><a href="#六、生产者-消费者问题" class="headerlink" title="六、生产者 - 消费者问题"></a>六、生产者 - 消费者问题</h2><p>问题分析<br>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费 者进程每次从缓冲区中取出一个产品并使用，生产者、消费者共享一个初始为空、大小为n的 缓冲区<br>2. 关系分析</p>
<p>(1) 同步关系</p>
<p>i. 缓冲区满时，生产者需要等消费者取走产品<br>ii. 缓冲区空时，消费者需要等生产者放入产品</p>
<p>(2) 互斥关系</p>
<p>i. 生产者与消费者要互斥访问缓冲区 (缓冲区是临界资源)<br>ii. 生产者与生产者要互斥访问缓冲区 (两个生产者可能会覆盖数据)<br>iii. 消费者与消费者要互斥访问缓冲区 (两个消费者可能有一个读的是空数据)</p>
<p>实现<br><img src="/2021/08/28/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8603/20201227102656876.png" alt="img" style="zoom:150%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/" class="post-title-link" itemprop="url">进程管理02</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-27 20:51:21" itemprop="dateCreated datePublished" datetime="2021-08-27T20:51:21+08:00">2021-08-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-28 19:14:33" itemprop="dateModified" datetime="2021-08-28T19:14:33+08:00">2021-08-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）开销很大</p>
<p>引入线程后，线程是CPU调度的基本单位</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/202105061455388.png" alt="img" style="zoom:80%;">

<h2 id="线程的优点和特性"><a href="#线程的优点和特性" class="headerlink" title="线程的优点和特性"></a>线程的优点和特性</h2><ul>
<li>进程间并发，开销很大<ol>
<li>当切换进程时，需要保存 / 恢复进程运行环境，还需要切换内存地址空间（更新快表、更新缓存）</li>
</ol>
</li>
<li>线程间并发，开销更小<ol>
<li>同一进程内的各个线程间并发，不需要切换进程运行环境和内存地址空间，省时省力</li>
</ol>
</li>
</ul>
<p>引入线程机制后，并发带来的系统开销降低，系统并发性提升</p>
<blockquote>
<p><font color="red">注意：从属于不同进程的线程间通信，也必须请求操作系统服务！</font></p>
</blockquote>
<p>引入线程前，进程既是资源分配的基本单位，也是调度的基本单位。</p>
<p>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。线程也有运行态、就绪态、阻塞态</p>
<p>在多CPU环境下，各个线程也可以分派到不同的CPU上并行地执行。</p>
<p>线程几乎不拥有资源，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145558176.png" alt="img" style="zoom:80%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210827205628248.png" alt="image-20210827205628248" style="zoom:80%;">

<h1 id="线程的实现方式多线程模型"><a href="#线程的实现方式多线程模型" class="headerlink" title="线程的实现方式多线程模型"></a>线程的实现方式多线程模型</h1><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145612404.png" alt="img" style="zoom:67%;">

<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h3><p>历史背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145625241.png" alt="img" style="zoom:80%;">

<ol>
<li><p>线程的管理工作由谁来完成？</p>
<blockquote>
<p>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</p>
</blockquote>
</li>
<li><p>线程切换是否需要CPU？</p>
<blockquote>
<p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
</blockquote>
</li>
<li><p>操作系统是否能意识到用户级线程的存在？</p>
<blockquote>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</p>
</blockquote>
</li>
<li><p>这种线程的实现方式有什么优点和缺点？</p>
</li>
</ol>
<blockquote>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统<br>开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p>
</blockquote>
<h3 id="内核级"><a href="#内核级" class="headerlink" title="内核级"></a>内核级</h3><p>内核级线程（Kernel-Level Thread, KLT, 又称“内核支持的线程”） 由操作系统支持的线程</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145742221.png" alt="img" style="zoom:80%;">

<blockquote>
<p>现代操作系统都实现了内核级线程，如Windows、Linux</p>
</blockquote>
<ol>
<li><p>线程的管理工作由谁来完成？</p>
<blockquote>
<p>内核级线程的管理工作由操作系统内核完成。</p>
</blockquote>
</li>
<li><p>线程切换是否需要CPU？</p>
<blockquote>
<p>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</p>
</blockquote>
</li>
<li><p>操作系统是否能意识到内核级线程的存在？</p>
<blockquote>
<p>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</p>
</blockquote>
</li>
<li><p>这种线程的实现方式有什么优点和缺点？</p>
<blockquote>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
</blockquote>
</li>
</ol>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145758880.png" alt="img" style="zoom:80%;">

<blockquote>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
</blockquote>
<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145815581.png" alt="img " style="zoom:80%;">

<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<blockquote>
<p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</p>
</blockquote>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多模型：n 用户及线程映射到m 个内核级线程（n &gt;= m）。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145838455.png" alt="img" style="zoom:80%;">

<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145853642.png" alt="在这里插入图片描述" style="zoom:80%;">

<h1 id="处理机的调度"><a href="#处理机的调度" class="headerlink" title="处理机的调度"></a>处理机的调度</h1><h2 id="处理机调度概念、层次"><a href="#处理机调度概念、层次" class="headerlink" title="处理机调度概念、层次"></a>处理机调度概念、层次</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145931264.png" alt="在这里插入图片描述" style="zoom:80%;">

<h3 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145942297.png" alt="img" style="zoom:67%;">

<p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p>
<p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行</p>
<h3 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506145957668.png" alt="img" style="zoom:80%;">

<blockquote>
<p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
<p>高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p>
<p>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
</blockquote>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150011732.png" alt="img" style="zoom:67%;">

<blockquote>
<p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p>
<p>这么做的目的是为了<font color="red">提高内存利用率和系统吞吐量</font>。</p>
<p>暂时调到外存等待的进程状态为<font color="red">挂起状态</font>。值得注意的是，<font color="red">PCB并不会一起调到外存，而是会常驻内存</font>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<font color="red">被挂起的进程PCB会被放到的挂起队列中</font>。</p>
<p><font color="red">中级调度（内存调度</font>），就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>一个进程可能会被多次调出、调入内存，因此<font color="red">中级调度发生的频率要比高级调度更高</font>。</p>
</blockquote>
<h5 id="补充知识：进程的挂起态与七状态模型"><a href="#补充知识：进程的挂起态与七状态模型" class="headerlink" title="补充知识：进程的挂起态与七状态模型"></a>补充知识：进程的挂起态与七状态模型</h5><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend） 挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态<br>五状态模型 —–&gt; 七状态模型</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615002451.png" alt="img" style="zoom:80%;">

<p>注意“挂起”和“阻塞”的区别，两种就绪挂起 状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为阻塞挂起 多个队列。</p>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150036446.png" alt="img" style="zoom:80%;">

<p>低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150053987.png" alt="img" style="zoom:80%;">

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150104532.png" alt="img" style="zoom:80%;">

<h2 id="进程调度的时机切换与过程调度方式"><a href="#进程调度的时机切换与过程调度方式" class="headerlink" title="进程调度的时机切换与过程调度方式"></a>进程调度的时机切换与过程调度方式</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150114745.png" alt="img" style="zoom:80%;">

<h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615013284.png" alt="img" style="zoom:80%;">

<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br>临界区：访问临界资源的那段代码。</p>
<p><font color="red">内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</font></p>
<blockquote>
<p>有的系统中，只允许进程主动放弃处理机有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
</blockquote>
<p>进程在普通临界区中是可以进行调度、切换的。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828152941229.png" alt="image-20210828152941229" style="zoom:80%;">

<blockquote>
<p>正在运行的进程如果正在访问就绪队列，会对其进行上锁，如果还没有退出临界区（解锁），就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行调度。</p>
<p><font color="red">内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</font></p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828153416754.png" alt="image-20210828153416754" style="zoom:80%;">

<blockquote>
<p>进程使用打印机时，会对打印机这一临界资源进行上锁，进程一直处于临界区内，临界资源不会解锁。但是打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。</p>
<p><font color="red">普通临界区访问的临界资源不会直接影响操作心痛内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</font></p>
</blockquote>
<h3 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h3><p><font color="red">剥夺调度方式，又称非抢占方式</font>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<blockquote>
<p># 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
</blockquote>
<p><font color="red">剥夺调度方式，又称抢占方式</font>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<blockquote>
<p># 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
</blockquote>
<h3 id="进程切换的过程主要完成了："><a href="#进程切换的过程主要完成了：" class="headerlink" title="进程切换的过程主要完成了："></a>进程切换的过程主要完成了：</h3><p>对原来运行进程各种数据的保存</p>
<p>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p>
<p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150219719.png" alt="img" style="zoom:80%;">

<h3 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h3><p>CPU利用率：指CPU “忙碌”的时间占总时间的比例。</p>
<blockquote>
<p>利 用 率 = 忙 碌 的 时 间 / 总 时 间</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150229620.png" alt="img" style="zoom:70%;">

<h3 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h3><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</p>
<p>系统吞吐量：单位时间内完成作业的数量</p>
<blockquote>
<p>系统吞吐量=总共完成了多少道作业/总共花了多少时间</p>
</blockquote>
<p>Eg：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？ 10/100 = 0.1 道 / 秒</p>
<h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
<p>它包括四个部分：</p>
<ul>
<li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间、</li>
<li>进程在CPU上执行的时间、</li>
<li>进程等待I/O操作完成的时间。</li>
</ul>
<p>后三项在一个作业的整个处理过程中，可能发生多次。对于用户来说，更关心自己的单个作业的周转时间</p>
<blockquote>
<p>(作业）周转时间=作业完成时间–作业提交时间</p>
</blockquote>
<p>对于操作系统来说，更关心系统的整体表现， 因此更关心所有作业周转时间的平均值</p>
<blockquote>
<p>平均周转时间=各作业周转时间之和/作业数</p>
</blockquote>
<h3 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h3><p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间，指进程 / 作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150322912.png" alt="img" style="zoom:80%;">

<blockquote>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p>
</blockquote>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150344160.png" alt="img" style="zoom:100%;">

<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20210506150354868.png" alt="img " style="zoom:80%;">

<blockquote>
<p>Tips：各种调度算法的学习思路</p>
<ol>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度？</li>
<li>抢占式？非抢占式？</li>
<li>优点和缺点</li>
<li>是否会导致饥饿</li>
</ol>
<p>饥饿:某进程 / 作业长期得不到服务.</p>
</blockquote>
<h3 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h3><p>按照作业 / 进程到达的先后顺序进行服务</p>
<p>用于作业 / 进程调度: 用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。</p>
<p>非抢占式的算法</p>
<p>优点：公平、算法实现简单<br>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利（Eg ：排队买奶茶…）</p>
<p>不会产生饥饿现象</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2021050615041251.png" alt="img" style="zoom:80%;">

<h3 id="短作业优先（SJF-Shortest-Job-First）"><a href="#短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="短作业优先（SJF, Shortest Job First）"></a>短作业优先（SJF, Shortest Job First）</h3><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p>
<p>算法规则： 最短的作业 / 进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p>
<p>即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先（SPF, Shortest Process First）算法”</p>
<p><font color="red">SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）</font></p>
<p>优缺点：</p>
<blockquote>
<p>优点：“最短的”平均等待时间、平均周转时间</p>
<p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>
</blockquote>
<p>是否会产生饥饿？</p>
<blockquote>
<p>会。如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。</p>
</blockquote>
<p>非抢占式：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828161614275.png" alt="image-20210828161614275" style="zoom:80%;">

<p>抢占式：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828161853587.png" alt="image-20210828161853587 " style="zoom:80%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828162029637.png" alt="image-20210828162029637" style="zoom:80%;">

<p>先来先服务（FCFS） 和 短作业优先（SJF） 的思考？</p>
<blockquote>
<p><font color="red">FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此对短作业不友好。</font></p>
<p><font color="red">SJF算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑哥哥作业的等待时间，因此导致对长作业不友好的问题，甚至会产生饥饿问题</font></p>
</blockquote>
<p>设计一个算法，既考虑各个作业的等待时间，也能兼顾运行时间？ </p>
<h3 id="高响应比优先（HRRN，Highest-Response-Ratio-Next）"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next）" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next）"></a>高响应比优先（HRRN，Highest Response Ratio Next）</h3><p>算法思想：综合考虑作业/进程的等待时间和要求服务的时间。</p>
<p>算法规则： 在每次调度时先计算各个作业/进程的响应比，选择相应比最高的作业/进程为其服务。</p>
<blockquote>
<p>响应比=（等待时间+要求服务时间）/ 要求服务时间</p>
</blockquote>
<p>是否可抢占？</p>
<blockquote>
<p>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
</blockquote>
<p>优缺点：</p>
<blockquote>
<p>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先。要求服务时间相同时，等待时间长的优先。对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饿死的问题。</p>
</blockquote>
<p>不会导致饥饿。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828163921731.png" alt="image-20210828163921731" style="zoom:80%;">





<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/image-20210828164332921.png" alt="image-20210828164332921" style="zoom:80%;">

<h3 id="时间片轮转-RR"><a href="#时间片轮转-RR" class="headerlink" title="时间片轮转(RR)"></a>时间片轮转(RR)</h3><p>轮流让就绪队列中的进程依次执行一个时间片 (当前的进程会被抢占)</p>
<p>注意：<br>(1) 每次选择的上处理机的进程都是排在就绪队列队头的进程<br>(2) 一个进程执行完会移动到就绪队列的尾部<br>(3) 一个进程时间片到，刚下处理机要移至就绪队列的尾部的同时有一个新进程到达就绪队 列，则新进程先到达就绪队列的尾部<br>时间片轮转算法过程详解(假设时间片大小为2)，如图：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094355454.png" alt="img " style="zoom:80%;">

<blockquote>
<p>(1) 0时刻，只有P1，P1运行2时间片<br>(2) 2时刻，P1下处理机(P1剩3)，同时P2到达，P2先进入就绪队列(P2 → P1)，P2运行2时间片<br>(3) 4时刻，P2下处理机(P2剩2)，同时P3到达，P3比P2先到达就绪队列(P1 → P3 → P2)，P1运行2时间片<br>(4) 5时刻，P4到达，此时的就绪队列(P1 → P3 → P2 → P4)<br>(5) 6时刻，P1下处理机(P1剩1)，P3运行1时间片，此时的就绪队列(P3 → P2 → P4 → P1)<br>(6) 7时刻，P3下处理机(P3运行结束)，P2运行2时间片<br>(7) 9时刻，P2下处理机(P2运行结束)，P4运行2时间片，就绪队列(P4 → P1)<br>(8) 11时刻，P4下处理机(P4剩4)，P1运行1时间片<br>(9) 12时刻，P1下处理机(P1运行结束)，此后一直运行P4，16时刻所有进程结束</p>
</blockquote>
<p>注意：<br>(1) 若时间片太大，使得每个进程都可以在一个时间片完成，此算法会退化为先来先服务算 法，因此时间片不能太大<br>(2) 若时间片太小，进程切换过于频繁，因此时间片不能太小</p>
<p>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094404849.png" alt="img" style="zoom:80%;">

<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>(1) 非抢占式的优先级调度算法<br>每次调度时选择当前已到达且优先级最高的进程 (执行完当前的进程才会执行下一个进 程，不会被抢占)，如图：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094424713.png" alt="img" style="zoom:80%;">

<p> P2与P4优先级相同，先到达的先执行</p>
<p>(2) 抢占式的优先级调度算法<br>每次调度时选择当前已到达且优先级最高的进程，当前进程主动放弃处理机时会发生调度， 就绪队列发生改变时会发生抢占 (当前的进程会被抢占)，如图</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094434296.png" alt="img" style="zoom:80%;">

<p><font color="red">应当适当提升I/O型进程的优先级</font></p>
<p>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094448494.png" alt="img" style="zoom:80%;">

<h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h3><p>(1) 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br>(2) 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程 还未结束，则进程进入下一级队列队尾，如果此时已经在最下级的队列，则重新放回最下级 队列的队尾<br>(3) 只有第K级队列为空时，才会为第K + 1级队列队头的进程分配时间片<br>(4) 被抢占处理机的进程重新放回原队列队尾<br>执行过程详解，如图</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/20200927094521559.png" alt="img" style="zoom:80%;">

<p>P1运行1个时间片(P1剩7)，P1进入第二级队列，P2到达第一级队列，P2运行1个时间片(P2剩3)，P2进入第二级队列，第一级队列为空，执行第二级队列的P1，P1运行2时间片(P1剩5)，P1进入第三级队列，执行第二级队列的P2，P2运行1个时间片(P2被抢占，P2剩2)，P3到达第一级队列，执行P3，P3运行1个时间片(P3运行结束)，执行第二级队列的P2，P2运行2个时间片(P2运行结束)，剩余时间执行P1直至结束<br>总结如下：</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8602/2020092709452942.png" alt="img" style="zoom:80%;">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/" class="post-title-link" itemprop="url">进程管理01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-27 18:16:50 / 修改時間：20:50:39" itemprop="dateCreated datePublished" datetime="2021-08-27T18:16:50+08:00">2021-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>程序:就是一个指令序列。</p>
<p>程序段、数据段、PCB三部分组成了<code>进程实体</code>(进程映像)。一般情况下，我们把进程实体就简称为进程。例如，所谓创建进程，实质上是创建进程实体中的PCB;而撤销进程，实质上是撤销进程实体中的PCB。</p>
<blockquote>
<p>PCB是进程存在的唯一标志 !</p>
</blockquote>
<p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有:<br>1.进程是程序的一次执行过程。<br>2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p><font size="4" color="#D2691E">进程(进程实体)</font>由程序段、数据段、PCB三 部分组成。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221509898.png" alt="img " style="zoom:80%;">

<blockquote>
<p>进程的管理者(操作系统)所需的数据都在PCB中。</p>
<p>程序本身的运行所需的数据存放在程序段和数据段中。</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221519928.png" alt="img" style="zoom:80%;">

<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/202105052215334.png" alt="img" style="zoom:80%;">

<h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>
<p>注:进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221547119.png" alt="img" style="zoom:80%;">

<h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221601693.png" alt="在这里插入图片描述" style="zoom:80%;">

<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/202105052216120.png" alt="img" style="zoom:80%;">

<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/image-20210827182825094.png" alt="image-20210827182825094" style="zoom:40%;">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210505221638460.png" alt="img" style="zoom:80%;">

<h2 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h2><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/2021050614465518.png" alt="img" style="zoom:80%;">

<blockquote>
<p><font size="4" color="#D2691E">注意:单核处理机环境下，每时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)</font></p>
<p><font size="4" color="#D2691E">进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即:万事俱备，只欠CPU</font></p>
<p><font size="4" color="#D2691E">如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</font></p>
</blockquote>
<h3 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a>另外两种状态</h3><blockquote>
<p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB (如:为进程分配PID)</p>
</blockquote>
<blockquote>
<p>进程运行结束(或者由于bug导致进程无法继续执行下去，比如数组越界错误)，需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144707756.png" alt="img" style="zoom:80%;">

<h3 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144726154.png" alt="img" style="zoom:67%;">

<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144737635.png" alt="img" style="zoom:67%;">

<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144753359.png" alt="img" style="zoom:90%;">

<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<br>简化理解：反正进程控制就是要实现进程状态转换</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144809684.png" alt="img" style="zoom:80%;">

<h3 id="如何实现进程控制？"><a href="#如何实现进程控制？" class="headerlink" title="如何实现进程控制？"></a>如何实现进程控制？</h3><blockquote>
<p>用<font size="4" color="#D2691E">原语</font>实现</p>
<p>原语是一种特殊的程序，它的执行具有<font size="4" color="#D2691E">原子性</font>。也就是说，这段程序的运行必须一气呵成，不可中断</p>
</blockquote>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144822199.png" alt="img" style="zoom:67%;">

<blockquote>
<p>思考：<font size="4" color="red">为何进程控制（状态转换）的过程要“一气呵成”？</font></p>
<p>如果不能“一气呵成”，就有可能导致操作系\统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。</p>
</blockquote>
<p>Eg：假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态…</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144839638.png" alt="img" style="zoom:100%;">

<p>假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：</p>
<ol>
<li>将PCB2的 state 设为1</li>
<li>将PCB2从阻塞队列放到就绪队列</li>
</ol>
<p>完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里</p>
<h3 id="如何实现原语的“原子性”？"><a href="#如何实现原语的“原子性”？" class="headerlink" title="如何实现原语的“原子性”？"></a>如何实现原语的“原子性”？</h3><p>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。<br>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144853436.png" alt="img " style="zoom:80%;">

<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</p>
<p><font size="4" color="red">CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</font></p>
<h3 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h3><h4 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144909647.png" alt="img" style="zoom:80%;">

<h4 id="撤消原语"><a href="#撤消原语" class="headerlink" title="撤消原语"></a>撤消原语</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144920651.png" alt="img" style="zoom:80%;">

<h4 id="阻塞-唤醒"><a href="#阻塞-唤醒" class="headerlink" title="阻塞 唤醒"></a>阻塞 唤醒</h4><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144935442.png" alt="img" style="zoom:80%;"> 

<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506144955489.png" alt="img" style="zoom:80%;"></h4><h3 id="进程控制相关的原语-1"><a href="#进程控制相关的原语-1" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h3><ol>
<li>更新PCB中的信息<br>a. 所有的进程控制原语一定都会修改进程状态标志<br>b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境<br>c. 某进程开始运行前必然要恢复期运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配 / 回收资源</li>
</ol>
<h3 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145204110.png" alt="img" style="zoom:80%;">

<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145251732.png" alt="在这里插入图片描述" style="zoom:80%;">

<p>顾名思义，进程通信就是指进程之间的信息交换。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145310313.png" alt="img" style="zoom:80%;">

<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p>
<h3 id="进程通信——共享存储"><a href="#进程通信——共享存储" class="headerlink" title="进程通信——共享存储"></a>进程通信——共享存储</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/image-20210827202122804.png" alt="image-20210827202122804" style="zoom:80%;">

<p><font size="4" color="red">基础数据结构</font>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p>
<p><font size="4" color="red">基于存储区</font>的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种<font size="4" color="red">高级通信</font>方式。</p>
<h3 id="进程通信——管道通信"><a href="#进程通信——管道通信" class="headerlink" title="进程通信——管道通信"></a>进程通信——管道通信</h3><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145344648.png" alt="img" style="zoom:80%;">

<ol>
<li>管道只能采用<font size="4" color="red">半双工通信</font>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li>
<li>各进程要<font size="4" color="red">互斥</font>地访问管道。</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read() 系统调用将被阻塞。（缓冲区的特性）</li>
<li>如果没写满，就不允许读。如果没读空，就不允许写。<strong>（缓冲区的特性）</strong></li>
<li><font size="4" color="red">数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</font></li>
</ol>
<h3 id="进程通信——消息传递"><a href="#进程通信——消息传递" class="headerlink" title="进程通信——消息传递"></a>进程通信——消息传递</h3><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息 / 接收消息”<font size="4" color="red">原语</font>进行数据交换。</p>
<img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145406491.png" alt="img" style="zoom:80%;">

<ul>
<li>直接消息传递：消息直接挂到接收进程的消息缓冲队列上</li>
<li>间接消息传递：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg：计网中的电子邮件系统</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><img src="/2021/08/27/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%8601/20210506145419455.png" alt="img" style="zoom:80%;">
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
