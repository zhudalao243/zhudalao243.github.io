<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhudalao243.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://zhudalao243.github.io/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="zzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zhudalao243.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>上善若水</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">上善若水</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">成为一个有智慧的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zzy"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">zzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/Go%E8%AF%AD%E8%A8%80sync-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/Go%E8%AF%AD%E8%A8%80sync-Map/" class="post-title-link" itemprop="url">Go语言sync.Map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 20:10:29 / 修改時間：20:20:16" itemprop="dateCreated datePublished" datetime="2021-08-18T20:10:29+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p>
<p>样例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">	fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现有这样的报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent map <span class="built_in">read</span> and map write</span><br></pre></td></tr></table></figure>

<p>根本原因就是：并发的去读写map结构的数据了。</p>
<p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p>
<p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<p>sync.Map 有以下特性：</p>
<ul>
<li>无须初始化，直接声明即可。</li>
<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
<li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li>
</ul>
<p>并发安全的 sync.Map 演示代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> scene sync.Map</span><br><span class="line">	<span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">	scene.Store(<span class="string">&quot;greece&quot;</span>, <span class="number">97</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;london&quot;</span>, <span class="number">100</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;egypt&quot;</span>, <span class="number">200</span>)</span><br><span class="line">	<span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">	fmt.Println(scene.Load(<span class="string">&quot;london&quot;</span>))</span><br><span class="line">	<span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">	scene.Delete(<span class="string">&quot;london&quot;</span>)</span><br><span class="line">	<span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">	scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line">		<span class="comment">//return false   返回false立即停止遍历</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/" class="post-title-link" itemprop="url">Golang中map的基本使用和底层理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 16:44:00 / 修改時間：19:53:38" itemprop="dateCreated datePublished" datetime="2021-08-18T16:44:00+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="map的基本使用"><a href="#map的基本使用" class="headerlink" title="map的基本使用"></a>map的基本使用</h1><h2 id="key与value的限制"><a href="#key与value的限制" class="headerlink" title="key与value的限制"></a>key与value的限制</h2><p>key一定要是<strong>可比较</strong>的类型（可以理解为支持==的操作）：</p>
<table>
<thead>
<tr>
<th align="center">可比教类型</th>
<th align="center">不可比较类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">slice</td>
</tr>
<tr>
<td align="center">numeric</td>
<td align="center">map</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">func</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">array和struct</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果是非法的key类型，会报错：invalid map key type xxx</p>
<blockquote>
<p>golang为uint32、uint64、string提供了fast access，使用这些类型作为key可以提高map访问速度。[runtime/hashmap_fast.go]</p>
</blockquote>
<p>value可以是<strong>任意类型</strong>。</p>
<h2 id="新增-amp-删除-amp-更新-amp-查询"><a href="#新增-amp-删除-amp-更新-amp-查询" class="headerlink" title="新增 &amp; 删除 &amp; 更新 &amp; 查询"></a>新增 &amp; 删除 &amp; 更新 &amp; 查询</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，key不存在则啥也不干</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询，key不存在返回value类型的零值</span></span><br><span class="line">i := m[<span class="string">&quot;name&quot;</span>] <span class="comment">// 三种查询方式，</span></span><br><span class="line">i, ok := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">_, ok := m[<span class="string">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>需要强调的是map本身是<strong>无序的</strong>，在遍历的时候并不会按照你传入的顺序，进行传出</p>
<p>正常遍历:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; </span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有序遍历:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 把key单独抽取出来，放在数组中</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行数组的排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">// 遍历数组就是有序的了</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">    fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>Golang中是没有引用传递的，均为值传递。这意味着传递的是数据的拷贝。<br>那么map本身是<strong>引用类型</strong>，作为形参或返回参数的时候，传递的是<strong>值的拷贝，而值是地址</strong>，<strong>扩容</strong>时也<strong>不会改变</strong>这个地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeM</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 函数开始时地址是： %p\n&quot;</span>, m)</span><br><span class="line">	<span class="keyword">var</span> max = <span class="number">5</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;max; i++&#123;</span><br><span class="line">		m[<span class="keyword">int64</span>(i)] = <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 在函数返回前地址是：%p\n&quot;</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>, <span class="number">1</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 的原始地址：%p\n&quot;</span>, m)</span><br><span class="line">	changeM(m)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 改变后地址：%p\n&quot;</span>, m)</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 长度是：&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 参数是：&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m 的原始地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 函数开始时地址是： <span class="number">0xc00006a360</span></span><br><span class="line">m 在函数返回前地址是：<span class="number">0xc00006a360</span></span><br><span class="line">m 改变后地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 长度是： <span class="number">5</span></span><br><span class="line">m 参数是： <span class="keyword">map</span>[<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2</span> <span class="number">3</span>:<span class="number">2</span> <span class="number">4</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="map的深入理解"><a href="#map的深入理解" class="headerlink" title="map的深入理解"></a>map的深入理解</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p>
<p>map数据结构由<code>runtime/map.go:hmap</code>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示一个拥有4个bucket的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt="img " style="zoom:80%;">

<p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p>
<p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket</p>
<h2 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h2><p>bucket数据结构由<code>runtime/map.go:bmap</code>定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个bucket可以存储8个键值对。</p>
<ul>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li>
<li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li>
</ul>
<p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p>
<p>下图展示bucket存放8个key-value对：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_7f0ba5a124641b1413279892581513c4_r.png" alt="img" style="zoom:80%;">

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p>
<p>下图展示产生冲突后的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_a8b9e5919d9951a71c1c36445dd68521_r.png" alt="img" style="zoom:80%;">

<p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍</p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量/bucket数量</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p>
<p>哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：</p>
<ul>
<li>哈希因子过小，说明空间利用率低</li>
<li>哈希因子过大，说明冲突严重，存取效率低</li>
</ul>
<p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p>
<h2 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h2><h3 id="扩容的前提条件"><a href="#扩容的前提条件" class="headerlink" title="扩容的前提条件"></a>扩容的前提条件</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p>
<ol>
<li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li>
</ol>
<h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png" alt="img" style="zoom:100%;">

<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p>
<p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2f0122f26e5d66ca91e6820ace6b379b_r.png" alt="img" style="zoom:100%;">

<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p>
<p>搬迁完成后的示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png" alt="img" style="zoom:80%;">

<p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。</p>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，而是把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_f3a5989c90204df9304d5ae246f3db72_r.png" alt="img" style="zoom:80%;">

<p>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p>
<h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>取哈希值高位在tophash数组中查询</li>
<li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li>
<li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li>
<li>如果当前处于搬迁过程，则优先从oldbuckets查找</li>
</ol>
<p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p>
<h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>查找该key是否已经存在，如果存在则直接更新值</li>
<li>如果没找到将key，将key插入</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">单向散列函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 15:00:02 / 修改時間：15:17:22" itemprop="dateCreated datePublished" datetime="2021-08-18T15:00:02+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是单向散列函数"><a href="#什么是单向散列函数" class="headerlink" title="什么是单向散列函数"></a>什么是单向散列函数</h2><blockquote>
<p>单向散列函数（one-wayftnction）有一个输人和一个输出，其中输人称为消息（message），输出称为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。</p>
<p>散列值的长度和消息的长度无关。无论消息是1比特，还是100MB，甚至是IOOGB，单向散列函数都会计算出固定长度的散列值。以SHA-I单向散列函数为例，它所计算出的散列值的长度永远是160比特（20字节）</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150209003.png" alt="image-20210818150209003" style="zoom:67%;">

<h2 id="单向散列函数的性质"><a href="#单向散列函数的性质" class="headerlink" title="单向散列函数的性质"></a>单向散列函数的性质</h2><ul>
<li><p>根据任意长度的消息计算出固定长度的散列值</p>
</li>
<li><p>能够快速计算出散列值</p>
</li>
<li><p>消息不同散列值也不同</p>
<blockquote>
<p>为了能够确认完整性，消息中哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值。</p>
<p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。<strong>两个不同的消息产生同一个散列值的情况称为碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。</p>
</blockquote>
</li>
<li><p><strong>具备单向性</strong></p>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150357989.png" alt="image-20210818150357989" style="zoom:67%;"></li>
</ul>
<h2 id="单向散列函数的实际应用"><a href="#单向散列函数的实际应用" class="headerlink" title="单向散列函数的实际应用"></a>单向散列函数的实际应用</h2><ul>
<li>检测软件是否被篡改</li>
</ul>
<blockquote>
<p>我们可以使用单向散列函数来确认自己下载的软件是否被篡改。</p>
<p>很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。</p>
<p>这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150530259.png" alt="image-20210818150530259" style="zoom:67%;">

<ul>
<li><p>消息认证码</p>
<blockquote>
<p>使用单向散列函数可以构造消息认证码。</p>
<p>消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</p>
<p>消息认证码在SSL/TLS中也得到了运用，关于SSL/TLS我们将后边章节中介绍。</p>
</blockquote>
</li>
<li><p>数字签名</p>
<blockquote>
<p>在进行数字签名时也会使用单向散列函数。</p>
<p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
</li>
<li><p>伪随机数生成器</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li><p>一次性口令</p>
<blockquote>
<p>使用单向散列函数可以构造一次性口令（one-time password）。</p>
<p>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p>
</blockquote>
</li>
</ul>
<h2 id="常用的单向散列函数"><a href="#常用的单向散列函数" class="headerlink" title="常用的单向散列函数"></a>常用的单向散列函数</h2><h3 id="MD4、MD5"><a href="#MD4、MD5" class="headerlink" title="MD4、MD5"></a>MD4、MD5</h3><blockquote>
<p>MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。</p>
<p>MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。</p>
</blockquote>
<p>Go中使用MD5</p>
<ul>
<li><p>需要导入的包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>计算Md5的方式1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_1</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的md5</span></span><br><span class="line">	result := md5.Sum(str)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, result)</span><br><span class="line">	<span class="comment">// 2. 数据格式化为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result[:])</span><br><span class="line">	fmt.Println(<span class="string">&quot;res: &quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span>  res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>返回数据data的MD5校验和</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span></span><br><span class="line">    - 参数 data: 原始数据</span><br><span class="line">    - 返回值: 经过md5计算之后得到的数据, 长度为 <span class="number">16</span>字节(<span class="keyword">byte</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>将字符串编码为16进制格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToString</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span></span><br><span class="line">    - 参数 src: 要转换的数据</span><br><span class="line">    - 返回值: 转换之后得到的<span class="number">16</span>进制格式字符串</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>计算Md5的方式2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_2</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用MD5校验的Hash对象`</span></span><br><span class="line">	myHash := md5.New()</span><br><span class="line">	<span class="comment">// 2. 通过io操作将数据写入hash对象中</span></span><br><span class="line">	io.WriteString(myHash, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="comment">//io.WriteString(myHash, &quot;, world&quot;)</span></span><br><span class="line">	myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;, world&quot;</span>))</span><br><span class="line">	<span class="comment">// 3. 计算结果</span></span><br><span class="line">	result := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	<span class="comment">// 4. 将结果转换为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>创建一个新的使用MD5校验的hash.Hash接口 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span></span><br></pre></td></tr></table></figure>

<p>Hash是一个被所有hash函数实现的公共接口。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误</span></span><br><span class="line">    io.Writer</span><br><span class="line">    <span class="comment">// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 重设hash为无数据输入的状态</span></span><br><span class="line">    Reset()</span><br><span class="line">    <span class="comment">// 返回Sum会返回的切片的长度</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回hash底层的块大小；Write方法可以接受任何大小的数据，</span></span><br><span class="line">    <span class="comment">// 但提供的数据是块大小的倍数时效率更高</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;io&quot;</span> 包中 Writer 接口用于包装基本的写入方法。</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过io操作将数据写入hash对象中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 第一种方式</span><br><span class="line">函数所属的包: <span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    - 参数 w: 实现了/包含Writer接口的对象</span><br><span class="line">    - 参数 s: 要添加到IO对象中的数据</span><br><span class="line">    - 返回值 n: 数据长度</span><br><span class="line">    - 返回值 err: 错误信息</span><br><span class="line"># 第二种方式</span><br><span class="line">使用md5包中的New()方法得到的hash.Hash接口(假设名为: myHash)添加数据</span><br><span class="line">myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;测试数据&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>使用hash.Hash接口中的Sum方法计算结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sum(b []byte) []byte</span><br><span class="line">    - 参数 b: 将b中的数据进行哈希计算, 结果添加到原始数据的前面, </span><br><span class="line">      		 一般情况下该参数指定为空, 即: nil</span><br><span class="line">    - 返回值: 进行哈希运算之后得到的结果 </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"><a href="#SHA-1、SHA-224、SHA-256、SHA-384、SHA-512" class="headerlink" title="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"></a>SHA-1、SHA-224、SHA-256、SHA-384、SHA-512</h2><blockquote>
<p>SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。</p>
<p>SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没有问题。</p>
<p>SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">比特数</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td>MD4</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>MD5</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>SHA-1</td>
<td align="center">160bit</td>
<td align="center">20byte</td>
</tr>
<tr>
<td>SHA-224</td>
<td align="center">224bit</td>
<td align="center">28byte</td>
</tr>
<tr>
<td>SHA-256</td>
<td align="center">256bit</td>
<td align="center">32byte</td>
</tr>
<tr>
<td>SHA-384</td>
<td align="center">384bit</td>
<td align="center">48byte</td>
</tr>
<tr>
<td>SHA-512</td>
<td align="center">512bit</td>
<td align="center">64byte</td>
</tr>
</tbody></table>
<h3 id="Go中对SHA-1、SHA-2的使用"><a href="#Go中对SHA-1、SHA-2的使用" class="headerlink" title="Go中对SHA-1、SHA-2的使用"></a>Go中对SHA-1、SHA-2的使用</h3><ul>
<li>需要导入的包</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用sha1计算文件指纹</li>
</ul>
<blockquote>
<p>上一小节介绍了如何使用go提供的API计算数据的md5指纹, sha1的计算方式和md5的套路是一样的, 需要将md5包, 替换为sh1, 下面给大家介绍一下如何使用sha1计算文件的指纹(md5亦如此) </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSha1</span><span class="params">(src <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	fp, err := os.Open(src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;文件打开失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建基于sha1算法的Hash对象</span></span><br><span class="line">	myHash := sha1.New()</span><br><span class="line">	<span class="comment">// 3. 将文件数据拷贝给哈希对象</span></span><br><span class="line">	num, err := io.Copy(myHash, fp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;拷贝文件失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件大小: &quot;</span>, num)</span><br><span class="line">	<span class="comment">// 4. 计算文件的哈希值</span></span><br><span class="line">	tmp1 := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 5. 数据格式转换</span></span><br><span class="line">    result := hex.EncodeToString(tmp1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sha1: &quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">非对称加密</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 14:15:44 / 修改時間：15:17:52" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:44+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;非对称加密也叫公钥密码: 使用公钥加密, 使用私钥解密&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对称加密的弊端"><a href="#对称加密的弊端" class="headerlink" title="对称加密的弊端"></a>对称加密的弊端</h2><ul>
<li><p>秘钥分发困难</p>
</li>
<li><p>可以通过非对称加密完成秘钥的分发</p>
<blockquote>
<p>https</p>
<p>Alice 和 Bob通信, Alice给bob发送数据, 使用对称加密的方式</p>
<ol>
<li>生成一个非对称的秘钥对, bob生成</li>
<li>bob将公钥发送给alice</li>
<li>alice生成一个用于对称加密的秘钥</li>
<li>alice使用bob的公钥就对称加密的秘钥进行加密, 并且发送给bob</li>
<li>bob使用私钥就数据解密, 得到对称加密的秘钥</li>
<li>通信的双方使用写好的秘钥进行对称加密数据加密</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="非对称加密的秘钥"><a href="#非对称加密的秘钥" class="headerlink" title="非对称加密的秘钥"></a>非对称加密的秘钥</h2><ul>
<li>不存在秘钥分发困难的问题</li>
</ul>
<h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>数据对谁更重要, 谁就拿私钥</p>
<ul>
<li>直观上看: 私钥比公钥长</li>
<li>使用第三方工具生成密钥对: 公钥文件xxx.pub xxx </li>
</ul>
<blockquote>
<ol>
<li><p>通信流程, 信息加密  （A写数据, 发送给B, 信息只允许B读）</p>
<p>A: 公钥</p>
<p>B: 私钥</p>
</li>
<li><p>登录认证 （客户端要登录, 连接服务器, 向服务器请求个人数据）</p>
<p>客户端:  私钥</p>
<p>服务器:  公钥</p>
</li>
<li><p>数字签名（表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面）</p>
<ul>
<li>发送信息的人:   私钥</li>
<li>收到信息的人:   公钥</li>
</ul>
</li>
<li><p>网银U盾</p>
<ul>
<li>个人: 私钥</li>
<li>银行拿公钥</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><blockquote>
<p>非对称加密的代表—RSA。在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，如下:                                                                                    </p>
</blockquote>
<p>$$<br>密文=明文 ^ E  mod     N（RSA加密）<br>$$</p>
<blockquote>
<p>也就是说，RSA的密文是对代表明文的数字的E次方求modN的结果。换句话说，就是将明文自己做E次乘法，然后将其结果除以N求余数，这个余数就是密文。</p>
<p>加密公式中出现的两个数一一一E和N，到底都是什么数呢？RSA的加密是求明文的E次方modN，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，E和N是RSA加密的密钥，也就是说，<strong>E和N的组合就是公钥</strong>。</p>
<p>不过，E和N并不是随便什么数都可以的，它们是经过严密计算得出的。顺便说一句，<strong>E是加密（Encryption）的首字母，N是数字（Number)的首字母</strong>。</p>
<p>有一个很容易引起误解的地方需要大家注意一一E和N这两个数并不是密钥对（公钥和私钥的密钥对）。E和N两个数才组成了一个公钥，因此我们一般会写成 “公钥是(E，N)” 或者 “公钥是{E, N}” 这样的形式，将E和N用括号括起来。</p>
<p>现在大家应该已经知道，==<strong>RSA的加密就是 “求E次方的modN”</strong>==，接下来我们来看看RSA的解密。</p>
</blockquote>
<h3 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h3><blockquote>
<p>RSA的解密和加密一样简单，可以用下面的公式来表达：</p>
</blockquote>
<p>$$<br>明文=密文^DmodN（RSA解密）<br>$$</p>
<blockquote>
<p>也就是说，对表示密文的数字的D次方求modN就可以得到明文。换句话说，将密文自己做D次乘法，再对其结果除以N求余数，就可以得到明文。</p>
<p>这里所使用的数字N和加密时使用的数字N是相同的。<strong>数D和数N组合起来就是RSA的解密密钥，因此D和N的组合就是私钥</strong>。只有知道D和N两个数的人才能够完成解密的运算。</p>
<p>大家应该已经注意到，<strong>在RSA中，加密和解密的形式是相同的。加密是求 “E次方的mod N”，而解密则是求 “D次方的modN”</strong>，这真是太美妙了。</p>
<p>当然，D也并不是随便什么数都可以的，作为解密密钥的D，和数字E有着相当紧密的联系。否则，用E加密的结果可以用D来解密这样的机制是无法实现的。</p>
<p>顺便说一句，<strong>D是解密〈Decryption）的首字母，N是数字（Number）的首字母</strong>。</p>
<p>我们将上面讲过的内容整理一下，如下表所示。</p>
</blockquote>
<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143403596.png" alt="image-20210818143403596" style="zoom:67%;">

<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143417941.png" alt="image-20210818143417941" style="zoom:67%;">

<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol>
<li>x509证书规范、pem、base64<ul>
<li>pem编码规范 - 数据加密</li>
<li>base64 - 对数据编码, 可逆<ul>
<li>不管原始数据是什么, 将原始数据使用64个字符来替代<ul>
<li>a-z  A-Z 0-9 + /</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ASN.1抽象语法标记</li>
<li>PKCS1标准</li>
</ol>
<h2 id="Go中生成公钥和私钥"><a href="#Go中生成公钥和私钥" class="headerlink" title="Go中生成公钥和私钥"></a>Go中生成公钥和私钥</h2><p>需要引入的包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>生成私钥操作流程概述:</p>
<blockquote>
<ol>
<li>使用rsa中的GenerateKey方法生成私钥</li>
<li>通过x509标准将得到的ras私钥序列化为ASN.1 的 DER编码字符串</li>
<li>将私钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件中</li>
</ol>
</blockquote>
<p>生成公钥操作流程:</p>
<blockquote>
<ol>
<li>从得到的私钥对象中将公钥信息取出</li>
<li>通过x509标准将得到 的rsa公钥序列化为字符串</li>
<li>将公钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件</li>
</ol>
</blockquote>
<p>生成公钥和私钥的源代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数bits: 指定生成的秘钥的长度, 单位: bit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaGenKey</span><span class="params">(bits <span class="keyword">int</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 生成私钥件</span></span><br><span class="line">	<span class="comment">// GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥</span></span><br><span class="line">	<span class="comment">// 参数1: Reader是一个全局、共享的密码用强随机数生成器</span></span><br><span class="line">	<span class="comment">// 参数2: 秘钥的位数 - bit</span></span><br><span class="line">	privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. MarshalPKCS1PrivateKey将rsa私钥序列化为ASN.1 PKCS#1 DER编码</span></span><br><span class="line">	derStream := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line">	<span class="comment">// 3. Block代表PEM编码的结构, 对其进行设置</span></span><br><span class="line">	block := pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>,<span class="comment">//&quot;RSA PRIVATE KEY&quot;,</span></span><br><span class="line">		Bytes: derStream,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4. 创建文件</span></span><br><span class="line">	privFile, err := os.Create(<span class="string">&quot;private.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 使用pem编码, 并将数据写入文件中</span></span><br><span class="line">	err = pem.Encode(privFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 最后的时候关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> privFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 生成公钥文件</span></span><br><span class="line">	publicKey := privateKey.PublicKey</span><br><span class="line">	derPkix, err := x509.MarshalPKIXPublicKey(&amp;publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	block = pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PUBLIC KEY&quot;</span>,<span class="comment">//&quot;PUBLIC KEY&quot;,</span></span><br><span class="line">		Bytes: derPkix,</span><br><span class="line">	&#125;</span><br><span class="line">	pubFile, err := os.Create(<span class="string">&quot;public.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 8. 编码公钥, 写入文件</span></span><br><span class="line">	err = pem.Encode(pubFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> pubFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数介绍:</p>
<ol>
<li><p>GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/rsa&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(random io.Reader, bits <span class="keyword">int</span>)</span> <span class="params">(priv *PrivateKey, err error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: io.Reader: 赋值为: rand.Reader</span><br><span class="line">        -- rand包实现了用于加解密的更安全的随机数生成器。</span><br><span class="line">        -- <span class="keyword">var</span> Reader io.Reader (rand包中的变量)</span><br><span class="line">    - 参数<span class="number">2</span>: bits: 秘钥长度</span><br><span class="line">    - 返回值<span class="number">1</span>: 代表一个RSA私钥。</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>通过x509 将rsa私钥序列化为ASN.1 PKCS#1 DER编码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数 (x509包解析X<span class="number">.509</span>编码的证书和密钥)。</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKCS1PrivateKey</span><span class="params">(key *rsa.PrivateKey)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过rsa.GenerateKey得到的私钥</span><br><span class="line">    - 返回值: 将私钥通过ASN<span class="number">.1</span>序列化之后得到的私钥编码数据</span><br></pre></td></tr></table></figure></li>
<li><p>设置Pem编码结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Block代表PEM编码的结构。</span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span>            <span class="comment">// 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">    Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 可选的头项，Headers是可为空的多行键值对。</span></span><br><span class="line">    Bytes   []<span class="keyword">byte</span>            <span class="comment">// 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将得到的Pem格式私钥通过文件指针写入磁盘中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, b *Block)</span> <span class="title">error</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 可进行写操作的IO对象, 此处需要指定一个文件指针</span><br><span class="line">    - 参数<span class="number">2</span>: 初始化完成的Pem块对象, 即Block对象</span><br></pre></td></tr></table></figure></li>
<li><p>通过RSA私钥得到公钥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥</span></span><br><span class="line">    D         *big.Int   <span class="comment">// 私有的指数</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// N的素因子，至少有两个</span></span><br><span class="line">    <span class="comment">// 包含预先计算好的值，可在某些情况下加速私钥的操作</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    N   *big.Int <span class="comment">// 模</span></span><br><span class="line">    E   <span class="keyword">int</span>      <span class="comment">// 公开的指数</span></span><br><span class="line">&#125;</span><br><span class="line">通过私钥获取公钥</span><br><span class="line">publicKey := privateKey.PublicKey <span class="comment">// privateKey为私钥对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过x509将公钥序列化为PKIX格式DER编码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKIXPublicKey</span><span class="params">(pub <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过私钥对象得到的公钥</span><br><span class="line">    - 返回值<span class="number">1</span>：将公钥通过ASN<span class="number">.1</span>序列化之后得到的编码数据</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>将公钥编码之后的数据格式化为Pem结构, 参考私钥的操作</p>
</li>
<li><p>将得到的Pem格式公钥通过文件指针写入磁盘中</p>
</li>
<li><p>生成的私钥和公钥文件数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 私钥文件数据</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXgIBAAKBgQC5bm0DCEV+EFeiLUqSshziqhSB30jXy5BWbPV5SlMq4aWiEknM</span><br><span class="line">i+Mw1aXic4bEsM3YyT73eWsifqZNSc/4fRaV4qz5OL8IIe9AZoGDSLX/Ar9AQMJf</span><br><span class="line">OHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3DVEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">AoGARGdn72ZtvENrEHiEufjajwMO7Zng1TpS1I79PvEcHQWAhHkaoEo6VRl7SD41</span><br><span class="line">yPkv9njGsaQo0WDHGFvSTGhYm/EWGrBWRPc5xXbSBg7ty9Iza9B1ekAj8VfWryen</span><br><span class="line">Wje3xDOCVCDUiCcYdaSfPiJPYuWMSnNMNa+0cR921zBQg0ECQQDpCMljuH7LrpbC</span><br><span class="line">NDF5q+LbUWMAE2KLDPX4WmDSdZdIO3mPux3MdwOUEfrcvSBGZNB7gyaEG7goZL8G</span><br><span class="line">BqL22MJHAkEAy7SqbVPoPbMPHuLI52VQ2FDp6xxSWLhjmv1ePCHGo28MDCaHeVzZ</span><br><span class="line">QaxyuIbnY8A6NHfu/QGwz/eB941IjYNBMwJBAI9XEEl+mr++zIz4fdZRnGE7VqId</span><br><span class="line">SmgtuL7jGNtb6YpMyyFV/6ZdLp5N0PkmfEvQh0zyBycLxeNS1Q1n16Xu/tECQQCZ</span><br><span class="line">dF42wdDgOfWYFMu31VETw9CTtuApya3vYhMNRXx4Pf1bYeMIf/OCT8CUVbwWHwc5</span><br><span class="line">42d73TwvTorvy9TuFgSVAkEA6F69THlTn5oIP8IWHcHuqS01fIR/vGfEwQ4cFZGR</span><br><span class="line">ketfieyeeF8rjn4qzwT/ugwRNjkhfKmoILnIC8UhEEJdjA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公钥文件数据</span></span><br><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5bm0DCEV+EFeiLUqSshziqhSB</span><br><span class="line"><span class="number">30</span>jXy5BWbPV5SlMq4aWiEknMi+Mw1aXic4bEsM3YyT73eWsifqZNSc/<span class="number">4</span>fRaV4qz5</span><br><span class="line">OL8IIe9AZoGDSLX/Ar9AQMJfOHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3D</span><br><span class="line">VEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中使用RSA加解密"><a href="#Go中使用RSA加解密" class="headerlink" title="Go中使用RSA加解密"></a>Go中使用RSA加解密</h2><ol>
<li><p>操作步骤</p>
<ul>
<li><p>公钥加密</p>
<blockquote>
<ol>
<li>将公钥文件中的公钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的公钥解析出来</li>
<li>使用得到的公钥通过rsa进行数据加密</li>
</ol>
</blockquote>
</li>
<li><p>私钥解密</p>
<blockquote>
<ol>
<li>将私钥文件中的私钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的私钥解析出来</li>
<li>使用得到的私钥通过rsa进行数据解密</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li>RSA公钥加密</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSAEncrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">    file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 读文件</span></span><br><span class="line">    info, _ := file.Stat()</span><br><span class="line">    allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">    file.Read(allText)</span><br><span class="line">    <span class="comment">// 3. 关闭文件</span></span><br><span class="line">    file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">    block, _ := pem.Decode(allText)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 解析一个DER编码的公钥</span></span><br><span class="line">    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 公钥加密</span></span><br><span class="line">    result, _ := rsa.EncryptPKCS1v15(rand.Reader, pubKey, src)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RSA私钥解密</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSADecrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">  file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 读文件</span></span><br><span class="line">  info, _ := file.Stat()</span><br><span class="line">  allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">  file.Read(allText)</span><br><span class="line">  <span class="comment">// 3. 关闭文件</span></span><br><span class="line">  file.Close()</span><br><span class="line">  <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">  block, _ := pem.Decode(allText)</span><br><span class="line">  <span class="comment">// 5. 解析一个pem格式的私钥</span></span><br><span class="line">  privateKey , err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">  <span class="comment">// 6. 私钥解密</span></span><br><span class="line">  result, _ := rsa.DecryptPKCS1v15(rand.Reader, privateKey, src)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重要的函数介绍</li>
</ul>
<ol>
<li>将得到的Pem格式私钥通过文件指针写入磁盘中</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(p *Block, rest []<span class="keyword">byte</span>)</span></span></span><br><span class="line">    - 参数 data: 需要解析的数据块</span><br><span class="line">    - 返回值<span class="number">1</span>: 从参数中解析出的PEM格式的块</span><br><span class="line">    - 返回值<span class="number">2</span>: 参数data剩余的未被解码的数据</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解析一个DER编码的公钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKIXPublicKey</span><span class="params">(derBytes []<span class="keyword">byte</span>)</span> <span class="params">(pub <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br><span class="line">    - 参数 derBytes: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 pub: 接口对象, 实际是公钥数据</span><br><span class="line">    - 参数 err:   错误信息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解析一个DER编码的私钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKCS1PrivateKey</span><span class="params">(der []<span class="keyword">byte</span>)</span> <span class="params">(key *rsa.PrivateKey, err error)</span></span></span><br><span class="line">    - 参数 der: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 key: 解析出的私钥</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将接口转换为公钥</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line">    - pubInterface: ParsePKIXPublicKey函数返回的 <span class="keyword">interface</span>&#123;&#125; 对象</span><br><span class="line">    - pubInterface.(*rsa.PublicKey): 将pubInterface转换为公钥类型 rsa.PublicKey</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用公钥加密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPKCS1v15</span><span class="params">(rand io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 pub:  非对称加密加密使用的公钥</span><br><span class="line">    - 参数 msg:  要使用公钥加密的原始数据</span><br><span class="line">    - 返回值 out: 加密之后的数据</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用私钥解密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 priv: 非对称加密解密使用的私钥</span><br><span class="line">    - 参数 ciphertext: 需要使用私钥解密的数据</span><br><span class="line">    - 返回值 out: 解密之后得到的数据</span><br><span class="line">    - 返回值 err: 错误信</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ECC椭圆曲线"><a href="#ECC椭圆曲线" class="headerlink" title="ECC椭圆曲线"></a>ECC椭圆曲线</h2><blockquote>
<ol>
<li>概念</li>
</ol>
<p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。</p>
<p>ECC 164位的密钥产生的一个安全级相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国<code>居民二代身份证</code>正在使用 256 位的椭圆曲线密码，虚拟货币<code>比特币</code>也选择ECC作为加密算法。</p>
<p>具体算法详解参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/taifei/article/details/73277247">https://blog.csdn.net/taifei/article/details/73277247</a></li>
</ul>
<ol start="2">
<li>数学原理</li>
</ol>
<p>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。</p>
<p>椭圆曲线依赖的数学难题是:</p>
<p><code>k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知Q和P，很难计算出k</code></p>
</blockquote>
<h2 id="非对称加密解惑"><a href="#非对称加密解惑" class="headerlink" title="非对称加密解惑"></a>非对称加密解惑</h2><ul>
<li>非对称加密比对称加密机密性更高吗?</li>
</ul>
<blockquote>
<p>这个问题无法回答, 以为机密性高低是根据秘钥长度而变化的</p>
</blockquote>
<ul>
<li><strong>采用1024bit 秘钥长度的非对称加密, 和采用128bit秘钥长度的对称加密中, 是秘钥更长的非对称加密更安全吗?</strong></li>
</ul>
<blockquote>
<p>不是。</p>
<p>非对称加密的密钥长度不能与对称加密的密钥长度进行直接比较。下表是一张密钥长度的比较表（本表摘自《应用密码学》），根据这张表我们可以看出，1024比特的公钥密码与128比特的对称密码相比，反而是128比特的对称密码抵御暴力破解的能力更强。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">对称加密秘钥长度</th>
<th align="center">非对称加密秘钥长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">128 比特</td>
<td align="center">2304 比特</td>
</tr>
<tr>
<td align="center">112 比特</td>
<td align="center">1792 比特</td>
</tr>
<tr>
<td align="center">80 比特</td>
<td align="center">768 比特</td>
</tr>
<tr>
<td align="center">64 比特</td>
<td align="center">512 比特</td>
</tr>
<tr>
<td align="center">56 比特</td>
<td align="center">384 比特</td>
</tr>
</tbody></table>
<ul>
<li><strong>有了非对称加密， 以后对称加密会被替代吗？</strong></li>
</ul>
<blockquote>
<p>不会</p>
<p>一般来说，在采用具备同等机密性的密钥长度的情况下，非对称加密的处理速度只有对称加密的几百分之一。因此，非对称加密并不适合用来对很长的消息内容进行加密。根据目的的不同，还可能会配合使用对称加密和非对称加密，如，混合密码系统就是将这两种密码组合而成的。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/" class="post-title-link" itemprop="url">周易基础及其应用02</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-17 23:24:40" itemprop="dateCreated datePublished" datetime="2021-08-17T23:24:40+08:00">2021-08-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-18 00:07:21" itemprop="dateModified" datetime="2021-08-18T00:07:21+08:00">2021-08-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">哲学</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">周易基础及其应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="地支"><a href="#地支" class="headerlink" title="地支"></a>地支</h2><blockquote>
<p>子        十一                辰            三月                申            七月</p>
<p>丑        十二                巳            四月                酉            八月</p>
<p>寅        正月                午            五月                戌            九月</p>
<p>卯        二月                未            六月                亥            十月</p>
</blockquote>
<h2 id="地支对应阴阳"><a href="#地支对应阴阳" class="headerlink" title="地支对应阴阳"></a>地支对应阴阳</h2><p>子丑寅卯辰巳午未申酉戌亥           单数为阳，奇数为阴</p>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817233329429.png" alt="image-20210817233329429" style="zoom:30%;">

<h2 id="地支对应方位"><a href="#地支对应方位" class="headerlink" title="地支对应方位"></a>地支对应方位</h2><table>
<thead>
<tr>
<th align="center">方位</th>
<th align="center">对应地支</th>
<th align="center">五行</th>
<th align="center">月份</th>
</tr>
</thead>
<tbody><tr>
<td align="center">东</td>
<td align="center">寅 卯</td>
<td align="center">木</td>
<td align="center">正月 二月</td>
</tr>
<tr>
<td align="center">南</td>
<td align="center">巳 午</td>
<td align="center">火</td>
<td align="center">四月 五月</td>
</tr>
<tr>
<td align="center">西</td>
<td align="center">申 酉</td>
<td align="center">金</td>
<td align="center">七月 八月</td>
</tr>
<tr>
<td align="center">北</td>
<td align="center">亥 子</td>
<td align="center">水</td>
<td align="center">十月 十一月</td>
</tr>
<tr>
<td align="center">中</td>
<td align="center">辰戌丑未</td>
<td align="center">土</td>
<td align="center">三月 九月 六月 十二月</td>
</tr>
</tbody></table>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817234729721.png" alt="image-20210817234729721" style="zoom:50%;">

<h2 id="地支相生相克"><a href="#地支相生相克" class="headerlink" title="地支相生相克"></a>地支相生相克</h2><table>
<thead>
<tr>
<th align="center">相生</th>
<th align="center">相克</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寅卯木   生    巳午火</td>
<td align="center">寅卯木    克     辰戌丑未土</td>
</tr>
<tr>
<td align="center">巳午火    生    辰戌丑未土</td>
<td align="center">辰戌丑未土    克    亥子水</td>
</tr>
<tr>
<td align="center">辰戌丑未土    生    申酉金</td>
<td align="center">亥子水    克     巳午火</td>
</tr>
<tr>
<td align="center">申酉金    生    亥子水</td>
<td align="center">巳午火     克    申酉金</td>
</tr>
<tr>
<td align="center">亥子水    生    寅卯木</td>
<td align="center">申酉金   克     寅卯木</td>
</tr>
</tbody></table>
<center><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817235421581.png" alt="image-20210817235421581" style="zoom:50%;"><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210817235937674.png" alt="image-20210817235937674" style="zoom:50%;"></center>

<h2 id="地支六冲六合"><a href="#地支六冲六合" class="headerlink" title="地支六冲六合"></a>地支六冲六合</h2><h3 id="六冲"><a href="#六冲" class="headerlink" title="六冲"></a>六冲</h3><blockquote>
<p>子丑寅卯辰巳</p>
<p>午未申酉戌亥  </p>
</blockquote>
<img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210818000234540.png" alt="image-20210818000234540" style="zoom:33%;">

<h3 id="六合"><a href="#六合" class="headerlink" title="六合"></a>六合</h3><img src="/2021/08/17/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A802/image-20210818000444347.png" alt="image-20210818000444347" style="zoom:40%;">

<p>P9</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/17/Go%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/Go%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%A7%B0%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Go实现对称算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-17 11:40:00 / 修改時間：15:23:22" itemprop="dateCreated datePublished" datetime="2021-08-17T11:40:00+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Go中对DES的操作"><a href="#Go中对DES的操作" class="headerlink" title="Go中对DES的操作"></a>Go中对DES的操作</h2><p>最后一个分组添加填充数据和移除添加数据代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充函数，如果最后一个分组字节数不够, 填充</span></span><br><span class="line"><span class="comment">// 使用pks5的方式填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算最后一个分组缺多少个字节</span></span><br><span class="line">	padding := blockSize - (<span class="built_in">len</span>(ciphertext)%blockSize)</span><br><span class="line">	<span class="comment">// 2. 创建一个大小为padding的切片, 每个字节的值为padding</span></span><br><span class="line">	padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="comment">// 3. 将padText添加到原始数据的后边, 将最后一个分组缺少的字节数补齐</span></span><br><span class="line">	newText := <span class="built_in">append</span>(ciphertext, padText...)</span><br><span class="line">	<span class="keyword">return</span> newText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除pks5填充的尾部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的总长度</span></span><br><span class="line">	length := <span class="built_in">len</span>(origData)</span><br><span class="line">	<span class="comment">// 2. 根据填充的字节值得到填充的次数</span></span><br><span class="line">	number := <span class="keyword">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">	<span class="comment">// 3. 将尾部填充的number个字节去掉</span></span><br><span class="line">	<span class="keyword">return</span> origData[:(length-number)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="加解密实现思路"><a href="#加解密实现思路" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit, 即 64/8 = 8字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><p>解密：</p>
<blockquote>
<ol>
<li>创建并返回一个使用DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="加解密的代码实现"><a href="#加解密的代码实现" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>在Go中使用DES需要导入的包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/des&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要加密的明文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesEncrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 对最后一个明文分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 4. 创建一个密码分组为链接模式的, 底层使用DES加密的BlockMode接口</span></span><br><span class="line">	<span class="comment">//    参数iv的长度, 必须等于b的块尺寸</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blackMode := cipher.NewCBCEncrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 5. 加密连续的数据块</span></span><br><span class="line">	dst := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(src))</span><br><span class="line">	blackMode.CryptBlocks(dst, src)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;加密之后的数据: &quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 将加密数据返回</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src -&gt; 要解密的密文</span></span><br><span class="line"><span class="comment">// key -&gt; 秘钥, 和加密秘钥相同, 大小为: 8byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DesDecrypt_CBC</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	<span class="comment">// 2. 判断是否创建成功</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式的, 底层使用DES解密的BlockMode接口</span></span><br><span class="line">	tmp := []<span class="keyword">byte</span>(<span class="string">&quot;helloAAA&quot;</span>)</span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, tmp)</span><br><span class="line">	<span class="comment">// 4. 解密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(src, dst)</span><br><span class="line">	<span class="comment">// 5. 去掉最后一组填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6. 返回结果</span></span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DESText</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加密</span></span><br><span class="line">	key := []<span class="keyword">byte</span>(<span class="string">&quot;11111111&quot;</span>)</span><br><span class="line">	result := DesEncrypt_CBC([]<span class="keyword">byte</span>(<span class="string">&quot;床前明月光, 疑是地上霜. 举头望明月, 低头思故乡.&quot;</span>), key)</span><br><span class="line">	fmt.Println(base64.StdEncoding.EncodeToString(result))</span><br><span class="line">	<span class="comment">// 解密</span></span><br><span class="line">	result = DesDecrypt_CBC(result, key)</span><br><span class="line">	fmt.Println(<span class="string">&quot;解密之后的数据: &quot;</span>, <span class="keyword">string</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用DES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: des对称加密使用的密码, 密码长度为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>自定义函数介绍</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对称加密加密需要对数据进行分组, 保证每个分组的数据长度相等, 如果最后一个分组长度不够, 需要进行填充</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数 ciphertext: 需要加密的原始数据</span><br><span class="line">    - 参数 blockSize: 每个分组的长度, 跟使用的加密算法有关系</span><br><span class="line">		* des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* <span class="number">3</span>des：<span class="number">64</span>bit， <span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">		* aes： <span class="number">128</span>bit， <span class="number">16</span><span class="keyword">byte</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对3DES的操作"><a href="#Go中对3DES的操作" class="headerlink" title="Go中对3DES的操作"></a>Go中对3DES的操作</h2><h3 id="加解密实现思路-1"><a href="#加解密实现思路-1" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><p><strong>加密 - CBC分组模式</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为64bit*3=192bit, 即 192/8 = 24字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>3DES是以64比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够64bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<p><strong>解密</strong></p>
<blockquote>
<ol>
<li>创建并返回一个使用3DES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用3DES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-1"><a href="#加解密的代码实现-1" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>3DES加密代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3DES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建并返回一个使用3DES算法的cipher.Block接口</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 对最后一组明文进行填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个密码分组为链接模式, 底层使用3DES加密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 4. 加密数据</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3DES解密代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3DES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TripleDESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建3DES算法的Block接口对象</span></span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建密码分组为链接模式, 底层使用3DES解密的BlockMode模型</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的数据</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li> 生成一个底层使用3DES加/解密的Block接口对象</li>
</ol>
   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/des&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTripleDESCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: <span class="number">3</span>des对称加密使用的密码, 密码长度为(<span class="number">64</span>*<span class="number">3</span>)bit, 即(<span class="number">8</span>*<span class="number">3</span>)<span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用DES加/解密的Block接口对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewTripleDESCipher 函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中对AES的使用"><a href="#Go中对AES的使用" class="headerlink" title="Go中对AES的使用"></a>Go中对AES的使用</h2><h3 id="加解密实现思路-2"><a href="#加解密实现思路-2" class="headerlink" title="加解密实现思路"></a>加解密实现思路</h3><ul>
<li><strong>加密 - CBC分组模式</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口<ul>
<li><strong>秘钥长度为128bit, 即 128/8 = 16字节(byte)</strong></li>
</ul>
</li>
<li>对最后一个明文分组进行数据填充<ul>
<li>AES是以128比特的明文（比特序列）为一个单位来进行加密的</li>
<li>最后一组不够128bit, 则需要进行数据填充</li>
</ul>
</li>
<li>创建一个密码分组为链接模式的, 底层使用AES加密的BlockMode接口</li>
<li>加密连续的数据块</li>
</ol>
</blockquote>
<ul>
<li><strong>解密</strong></li>
</ul>
<blockquote>
<ol>
<li>创建并返回一个使用AES算法的cipher.Block接口</li>
<li>创建一个密码分组为链接模式的, 底层使用AES解密的BlockMode接口</li>
<li>数据块解密</li>
<li>去掉最后一组的填充数据</li>
</ol>
</blockquote>
<h3 id="加解密的代码实现-2"><a href="#加解密的代码实现-2" class="headerlink" title="加解密的代码实现"></a>加解密的代码实现</h3><p>AES加密代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AES加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESEncrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES加密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 最后一个分组进行数据填充</span></span><br><span class="line">	src = PKCS5Padding(src, block.BlockSize())</span><br><span class="line">	<span class="comment">// 3. 创建一个分组为链接模式, 底层使用AES加密的块模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 4. 加密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AES解密:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AESDecrypt</span><span class="params">(src, key []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用AES解密的块对象</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建分组为链接模式, 底层使用AES的解密模型对象</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:block.BlockSize()])</span><br><span class="line">	<span class="comment">// 3. 解密</span></span><br><span class="line">	dst := src</span><br><span class="line">	blockMode.CryptBlocks(dst, src)</span><br><span class="line">	<span class="comment">// 4. 去掉尾部填充的字</span></span><br><span class="line">	dst = PKCS5UnPadding(dst)</span><br><span class="line">	<span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数说明:</p>
<ol>
<li><p>生成一个底层使用AES加/解密的Block接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span></span><br><span class="line">	- 参数 key: aes对称加密使用的密码, 密码长度为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span></span><br><span class="line">	- 返回值 cipher.Block: 创建出的使用AES加/解密的Block接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b加密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用aes.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">64</span>bit, 即<span class="number">8</span><span class="keyword">byte</span></span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure></li>
<li><p>使用cipher包的BlockMode接口对象对数据进行加/解密</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">接口对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回加密字节块的大小</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 加密或解密连续的数据块，src的尺寸必须是块大小的整数倍，src和dst可指向同一内存地址</span></span><br><span class="line">    CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line">接口中的 CryptBlocks(dst, src []<span class="keyword">byte</span>) 方法:</span><br><span class="line">    - 参数 dst: 传出参数, 存储加密或解密运算之后的结果 </span><br><span class="line">    - 参数 src: 传入参数, 需要进行加密或解密的数据切片(字符串)</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个密码分组为CBC模式, 底层使用b解密的BlockMode接口对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数对应的包: <span class="keyword">import</span> <span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span></span><br><span class="line">    - 参数 b: 使用des.NewCipher函数创建出的Block接口对象</span><br><span class="line">    - 参数 iv: 事先准备好的一个长度为一个分组长度的比特序列, 每个分组为<span class="number">128</span>bit, 即<span class="number">16</span><span class="keyword">byte</span>, </span><br><span class="line">               该序列的值需要和NewCBCEncrypter函数的第二个参数iv值相同</span><br><span class="line">    - 返回值: 得到的BlockMode接口对象</span><br></pre></td></tr></table></figure>

<h2 id="应选择哪种对称加密"><a href="#应选择哪种对称加密" class="headerlink" title="应选择哪种对称加密"></a>应选择哪种对称加密</h2><blockquote>
<p>前面我们介绍了DES、三重DES和AES等对称密码，那么我们到底应该使用哪一种对称密码算法呢？</p>
<ol>
<li><strong>今后最好不要将DES用于新的用途，因为随着计算机技术的进步，现在用暴力破解法已经能够在现实的时间内完成对DES的破译。但是，在某些情况下也需要保持与旧版本软件的兼容性。</strong></li>
<li><strong>出于兼容性的因素三重DES在今后还会使用一段时间，但会逐渐被AES所取代。</strong></li>
<li><strong>今后大家应该使用的算法是AES（Rijndael），因为它安全、快速，而且能够在各种平台上工作。此外，由于全世界的密码学家都在对AES进行不断的验证，因此即便万一发现它有什么缺陷，也会立刻告知全世界并修复这些缺陷。</strong></li>
</ol>
<p>一般来说，我们不应该使用任何自制的密码算法，而是应该使用AES。因为AES在其选定过程中，经过了全世界密码学家所进行的高品质的验证工作，而对于自制的密码算法则很难进行这样的验证。 </p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">分组密码的模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-17 10:45:08 / 修改時間：11:38:12" itemprop="dateCreated datePublished" datetime="2021-08-17T10:45:08+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;分组密码的模式 -- 分组密码是如何迭代的&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>DES和AES都属于分组密码，只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。</p>
<p>分组密码有很多种模式，如果模式的选择不恰当，就无法保证机密性。例如，如果使用ECB模式，明文中的一些规律就可以通过密文被识别出来。</p>
<p>分组密码的主要模式（ECB、CBC、CFB、OFB、CTR）</p>
</blockquote>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><blockquote>
<p><strong>分组密码（blockcipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的一块”就称为分组（block）。此外，一个分组的比特数就称为分组长度（blocklength）。</p>
<p>例如，<strong>DES和三重DES的分组长度都是64比特</strong>。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。</p>
<p><strong>AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。</strong></p>
</blockquote>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><blockquote>
<p><strong>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）</strong>。</p>
</blockquote>
<blockquote>
<p>模式有很多种类，分组密码的主要模式有以下5种：</p>
<ul>
<li><strong>ECB模式</strong>：Electronic Code Book mode（电子密码本模式）</li>
<li><strong>CBC模式</strong>：Cipher Block Chaining mode（密码分组链接模式）</li>
<li><strong>CFB模式</strong>：Cipher FeedBack mode（密文反馈模式）</li>
<li><strong>OFB模式</strong>：Output FeedBack mode（输出反馈模式）</li>
<li><strong>CTR模式</strong>：CounTeR mode（计数器模式）</li>
</ul>
</blockquote>
<h3 id="明文分组和密文分组"><a href="#明文分组和密文分组" class="headerlink" title="明文分组和密文分组"></a>明文分组和密文分组</h3><blockquote>
<p>**明文分组: **是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p>**密文分组: **是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105748588.png" alt="image-20210817105748588" style="zoom:67%;">

<h2 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h2><p>ECB(Electronic Code Book, 电子密码本)模式是最简单的加密模式，<font color="red">明文消息被分成固定大小的块（分组），并且每个块被单独加密。</font>  每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<font color="red">安全性比较差。  适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</font></p>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817105913728.png" alt="image-20210817105913728 " style="zoom:67%;">

<blockquote>
<p>使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组–&gt;密文分组”的对应表，因此ECB模式也称为电子密码本模式<strong>当最后一个明文分组的内容小于分组长度时，需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度</strong>。</p>
<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>
</blockquote>
<h2 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h2><h3 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h3><blockquote>
<p>异或操作： </p>
<p>1$\bigoplus$0=1  </p>
<p>0$\bigoplus$1=1</p>
<p>1$\bigoplus$1=0 </p>
<p>0$\bigoplus$0=0</p>
</blockquote>
<center><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110350744.png" alt="image-20210817110350744" style="zoom:80%;"><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110416665.png" alt="image-20210817110416665" style="zoom:80%;"></center>

<blockquote>
<p>可能大家已经发现了，上面的计算和加密、解密的步骤非常相似。</p>
<ul>
<li><p>将明文A用密钥B进行加密，得到密文A⊕B</p>
</li>
<li><p>将密文A⊕B用密钥B进行解密，得到明文A</p>
</li>
</ul>
<p>实际上，只要选择一个合适的B，仅仅使用XOR就可以实现一个高强度的密码。</p>
<p>对同一个比特序列进行两次XOR之后就会回到最初的状态。</p>
</blockquote>
<h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><blockquote>
<p>CBC(Cipher Block Chaining, 密码块链)<font color="red">模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密</font>。  这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，<font color="red">第一个数据块进行加密之前需要用初始化向量IV进行异或操作</font>。  <font color="red">CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。</font></p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110639241.png" alt="image-20210817110639241" style="zoom:67%;">

<blockquote>
<p> 如果将一个分组的加密过程分离出来，我们就可以很容易地比较出ECB模式和CBC模式的区别 。ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817110715286.png" alt="image-20210817110715286" style="zoom:50%;">

<h3 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><strong>当加密第一个明文分组时，由于不存在“前一个密文分组”，因此<font color="red">需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组</font>“，这个比特序列称为初始化向量（initialization vector）</strong> 通常缩写为 IV </p>
</blockquote>
<h2 id="CFB-模式"><a href="#CFB-模式" class="headerlink" title="CFB 模式"></a>CFB 模式</h2><blockquote>
<p>CFB模式的全称是Cipher FeedBack模式（密文反馈模式）。在CFB模式中，<font color="red">前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</font>。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111048158.png" alt="image-20210817111048158" style="zoom:67%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111109864.png" alt="image-20210817111109864" style="zoom:67%;">

<blockquote>
<p>在ECB模式和CBC模式中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组并没有通过密码算法来直接进行加密。</p>
<p>从上图可以看出，明文分组和密文分组之间并没有经过”加密”这一步骤。在CFB模式中，明文分和密文分组之间只有一个XOR。</p>
<p>我们将CBC模式与CFB模式对比一下，就可以看出其中的差异了（如下图）。在CBC模式中，明文分组和密文分组之间有XOR和密码算法两个步骤，而在CFB模式中，明文分组和密文分组之间则只有XOR。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111235512.png" alt="image-20210817111235512" style="zoom:50%;">

<h3 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p><font color="red">在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量（IV）来代替</font>，这一点和CBC模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。</p>
</blockquote>
<h3 id="CFB模式与流密码"><a href="#CFB模式与流密码" class="headerlink" title="CFB模式与流密码"></a>CFB模式与流密码</h3><blockquote>
<p>CFB模式是通过将“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”的。</p>
<p>在CFB模式中，密码算法的输出相当于一个随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此CFB模式不可能具各理论上不可破译的性质。</p>
<p><font color="red">CFB模式中由加密算法所生成的比特序列称为密钥流（key stream）</font>。在CFB模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的“种子“。</p>
<p>在CFB模式中，<font color="red">明文数据可以被逐比特加密</font>，因此我们<font color="red">可以将CFB模式看做是一种使用分组密码来实现流密码的方式</font>。</p>
</blockquote>
<h2 id="OFB-模式"><a href="#OFB-模式" class="headerlink" title="OFB 模式"></a>OFB 模式</h2><blockquote>
<p>OFB模式并不是通过密码算法对明文直接进行加密的，而是通过将 “明文分组” 和 “密码算法的输出” 进行XOR来产生 “密文分组” 的，在这一点上OFB模式和CFB模式非常相似。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817111629522.png" alt="image-20210817111629522" style="zoom:67%;">

<h3 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h3><blockquote>
<p>和CBC模式、CFB模式一样，OFB模式中也需要使用初始化向量（IV）。</p>
</blockquote>
<h3 id="CFB模式和OFB模式对比"><a href="#CFB模式和OFB模式对比" class="headerlink" title="CFB模式和OFB模式对比"></a>CFB模式和OFB模式对比</h3><blockquote>
<p>OFB模式和CFB模式的区别仅仅在于密码算法的输入。</p>
<p>CFB式中，密码算法的输人是前一个密文分组，也就是将密文分组反馈到密算法中，因此就有了“密文反馈模式”这个名字。</p>
<p>相对地，OFB模式中，密码算法的输入则是密码算法的前一个输出，也就是将输出反馈给密码算法，因此就有了“输出反馈模式”这个名字。</p>
<p>如果将一个分组抽出来对CFB模式和OFB模式进行一个对比．就可以很容易看出它们之间的差异（下图）。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112004499.png" alt="image-20210817112004499" style="zoom:67%;">

<blockquote>
<p>由于CFB模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组1而先对明文分组2进行加密。</p>
<p>相对地，在OFB模式中，XOR所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了。只要将明文与密钥流进行XOR就可以了。和AES等密码算法相比，XOR运算的速度是非常快的。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度来看，生成密钥流的操作和进行XOR运算的操作是可以并行的。</p>
</blockquote>
<h2 id="CTR-模式"><a href="#CTR-模式" class="headerlink" title="CTR 模式"></a>CTR 模式</h2><blockquote>
<p>CTR模式的全称是CounTeR模式（计数器模式）。<font color="red">CTR摸式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码</font>（下图）。</p>
<p>CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112246534.png" alt="image-20210817112246534" style="zoom:50%;">

<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112306254.png" alt="image-20210817112306254" style="zoom:50%;">

<h3 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h3><blockquote>
<p>每次加密时都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器的初始值可能是像下面这样的形式。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112459058.png" alt="image-20210817112459058" style="zoom:80%;">

<blockquote>
<p>其中前8个字节为nonce（随机数），这个值在每次加密时必须都是不同的，后8个字节为分组序号，这个部分是会逐次累加的。在加密的过程中，计数器的值会产生如下变化：</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112557257.png" alt="image-20210817112557257" style="zoom:80%;">

<blockquote>
<p>按照上述生成方法，可以保证计数器的值每次都不同。由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p>
</blockquote>
<h3 id="OFB模式与CTR模式对比"><a href="#OFB模式与CTR模式对比" class="headerlink" title="OFB模式与CTR模式对比"></a>OFB模式与CTR模式对比</h3><blockquote>
<p>CTR模式和OFB模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么OFB模式和CTR模式之间的差异还是很容易理解的（下图）。OFB模式是将加密的输出反愦到输入，而CTR模式则是将计数器的值用作输入。</p>
</blockquote>
<img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112653539.png" alt="image-20210817112653539" style="zoom:67%;">

<h3 id="CTR模式的特点"><a href="#CTR模式的特点" class="headerlink" title="CTR模式的特点"></a>CTR模式的特点</h3><blockquote>
<p>CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。</p>
<p>此外，CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。</p>
<p>能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2021/08/17/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/image-20210817112810129.png" alt="image-20210817112810129 " style="zoom:80%;">

<ol>
<li><p>ECB - Electronic Code Book, 电子密码本模式</p>
<ul>
<li>特点: 简单, 效率高, 密文有规律, 容易被破解</li>
<li>最后一个明文分组必须要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>不需要初始化向量</li>
</ul>
</li>
<li><p>CBC - Cipher Block Chaining, 密码块链模式</p>
<ul>
<li>特点: 密文没有规律, 经常使用的加密方式</li>
<li>最后一个明文分组需要填充<ul>
<li>des/3des -&gt; 最后一个分组填充满8字节</li>
<li>aes -&gt; 最后一个分组填充满16字节</li>
</ul>
</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
</ul>
</li>
<li><p>CFB - Cipher FeedBack, 密文反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>OFB - Output-Feedback, 输出反馈模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>需要一个初始化向量 - 一个数组<ul>
<li>数组的长度: 与明文分组相等</li>
<li>数据来源: 负责加密的人的提供的</li>
<li>加解密使用的初始化向量值必须相同</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
<li><p>CTR - CounTeR, 计数器模式</p>
<ul>
<li>特点: 密文没有规律,  明文分组是和一个数据流进行的按位异或操作, 最终生成了密文</li>
<li>不需要初始化向量<ul>
<li>go接口中的iv可以理解为随机数种子, iv的长度 == 明文分组的长度</li>
</ul>
</li>
<li>不需要填充</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">对称加密</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-16 22:33:06" itemprop="dateCreated datePublished" datetime="2021-08-16T22:33:06+08:00">2021-08-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-17 10:50:01" itemprop="dateModified" datetime="2021-08-17T10:50:01+08:00">2021-08-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><p>常用的两种加密方式 </p>
<p>对称加密</p>
<ul>
<li>秘钥: 加密解密使用的是同一个秘钥, 秘钥有一个</li>
<li>特点<ul>
<li>双方向保证机密性</li>
<li>加密效率高, 适合加密大数据, 大文件</li>
<li>加密强度不高, 相对于非对称加密</li>
</ul>
</li>
</ul>
<p>非对称加密</p>
<ul>
<li>秘钥: 加密解密使用的不同的秘钥, 秘钥有两个, 需要使用秘钥生成算法, 得到密钥对<ul>
<li>公钥 - 可以公开的秘钥<ul>
<li>公钥加密数据, 解密需要使用私钥</li>
</ul>
</li>
<li>私钥 - 需要妥善保管的秘钥, 知道的人越少越好<ul>
<li>私钥加密, 公钥解密</li>
</ul>
</li>
</ul>
</li>
<li>特点:<ul>
<li>数据的机密性只能单方向保证</li>
<li>加密效率低, 适合加密少量数据</li>
<li>加密强度高, 相对于对称加密</li>
</ul>
</li>
</ul>
</li>
<li><p>密码信息安全常识 </p>
<ul>
<li><p>不要使用保密的密码算法（普通公司和个人）</p>
</li>
<li><p>使用低强度的密码比不进行任何加密更危险</p>
</li>
<li><p>任何密码总有一天都会被破解</p>
</li>
<li><p>密码只是信息安全的一部分                </p>
</li>
</ul>
</li>
<li><p>密码信息威胁 </p>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816230646529.png" alt="image-20210816230646529" style="zoom:70%;"></li>
</ol>
<h2 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h2><blockquote>
<p>“对称加密: 也称为对称密码, 是指在加密和解码时使用同一秘钥的加密方式”</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231137633.png" alt="image-20210816231137633" style="zoom:50%;">

<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote>
<p>现代的密码都是建立在计算机的基础之上的，这是因为现代的密码所处理的数据量非常大，而且密码算法也非常复杂，不借助计算机的力量就无法完成加密和解密的操作。</p>
<p>计算机的操作对象并不是文字，而是由0和1排列而成的<strong>比特序列</strong>。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>
<p>将现实世界中的东西映射为比特序列的操作称为<strong>编码（encoding）</strong>。例如midnight（深夜）这个词，我们可以对其中的每个字母逐一进行编码，这种编码规则叫作<strong>ASCII</strong>。</p>
</blockquote>
<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231349119.png" alt="image-20210816231349119" style="zoom:67%;">

<blockquote>
<p>注意这里的m –&gt; 01101101这一转换并不是加密而是编码。尽管在人类看来0和1的序列跟密码没什么两样，但计算机却可以“看懂”这些比特序列，并很快地反应出其所对应的字符 <strong>midnight</strong></p>
</blockquote>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><h4 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>DES是一种将64比特的明文加密成64比特的密文的对称密码算法，==它的密钥长度是56比特==。尽管<font color="red">从规格上来说，DES的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上其密钥长度是56比特</font>。</p>
<p><font color="red">DES是以64比特的明文（比特序列）为一个单位来进行加密的</font>，<strong>这个64比特的单位称为分组</strong>。一般来说，以分组为单位进行处理的密码算法称为<strong>分组密码（blockcipher）</strong>，DES就是分组密码的一种。</p>
<p>DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。</p>
<p>大B -&gt; bit</p>
<p>小b -&gt; byte</p>
<p>秘钥长度(56bit + 8bit)/8 = 8byte   12345678</p>
</blockquote>
<h4 id="DES的加密与解密-图例"><a href="#DES的加密与解密-图例" class="headerlink" title="DES的加密与解密 - 图例"></a>DES的加密与解密 - 图例</h4><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210816231818006.png" alt="image-20210816231818006" style="zoom:80%;">

<h4 id="DES小结"><a href="#DES小结" class="headerlink" title="DES小结"></a>DES小结</h4><ul>
<li>现在使用DES方式加密，数据还安全吗？<ul>
<li>不安全, 已经被破解了  </li>
</ul>
</li>
<li>是不是分组密码？<ul>
<li>是, 先对数据进行分组, 然后在加密或解密</li>
</ul>
</li>
<li>DES的分组长度?<ul>
<li>8byte == 64bit</li>
</ul>
</li>
<li>DES的秘钥长度?<ul>
<li>56bit秘钥长度+8bit错误检测标志位 = 64bit == 8byte</li>
</ul>
</li>
</ul>
<h3 id="3DES-–-Triple-DES"><a href="#3DES-–-Triple-DES" class="headerlink" title="3DES  –   Triple-DES"></a>3DES  –   Triple-DES</h3><blockquote>
<p>现在DES已经可以在现实的时间内被暴力破解，因此我们需要一种用来替代DES的分组密码，三重DES就是出于这个目的被开发出来的。</p>
<p><strong>三重DES（triple-DES）是为了增加DES的强度，==将DES重复3次所得到的一种密码算法==，通常缩写为3DES</strong>。</p>
</blockquote>
<h4 id="加密和解密-1"><a href="#加密和解密-1" class="headerlink" title="加密和解密"></a>加密和解密</h4><blockquote>
<p>三重DES的加解密机制如图所示：</p>
<p>加-&gt;解-&gt;加 -&gt; 目的是为了兼容des</p>
<p>3des秘钥长度24字节 = 1234567a 1234567b 1234567a</p>
</blockquote>
<center><img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102851239.png" alt="image-20210817102851239" style="zoom:50%;">!<img src="/2021/08/16/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210817102916694.png" alt="image-20210817102916694 " style="zoom:50%;"></center>

<blockquote>
<p>明文经过三次DES处理才能变成最后的密文，由于<strong>DES密钥的长度实质上是56比特</strong>，因此<font color="red">三重DES的密钥长度就是56×3=168比特, 加上用于错误检测的标志位8x3, 共192bit</font>。</p>
<p>从上图我们可以发现，三重DES并不是进行三次DES加密（加密–&gt;加密–&gt;加密），而是<font color="red"><strong>加密–&gt;解密–&gt;加密</strong></font>的过程。在加密算法中加人解密操作让人感觉很不可思议，实际上这个方法是IBM公司设计出来的，目的是为了让三重DES能够兼容普通的DES。</p>
<p><font color="red">当三重DES中所有的密钥都相同时，三重DES也就等同于普通的DES了</font>。这是因为在前两步加密–&gt;解密之后，得到的就是最初的明文。因此，以前用DES加密的密文，就可以通过这种方式用三重DES来进行解密。也就是说，三重DES对DES具备向下兼容性。</p>
<p>如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个DES密钥），这种三重DES就称为DES-EDE2。EDE表示的是加密（Encryption) –&gt;解密（Decryption)–&gt;加密（Encryption）这个流程。</p>
<p>密钥1、密钥2、密钥3全部使用不同的比特序列的三重DES称为DES-EDE3。</p>
<p>尽管三重DES目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题。</p>
</blockquote>
<h4 id="3DES小结"><a href="#3DES小结" class="headerlink" title="3DES小结"></a>3DES小结</h4><ul>
<li>3DES安全吗?<ul>
<li>安全, 但是效率低</li>
</ul>
</li>
<li>算法描述?<ul>
<li>进行了3次des加密</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>3DES分组长度?<ul>
<li>8字节</li>
</ul>
</li>
<li>3DES秘钥长度?<ul>
<li>24字节, 在算法内部会被平均分成3份</li>
</ul>
</li>
<li>3DES加密过程?<ul>
<li>秘钥1 -&gt; 加密, 秘钥2 -&gt; 解密, 秘钥3 -&gt; 加密</li>
</ul>
</li>
<li>3DES解密过程?<ul>
<li>秘钥1 -&gt; 解密, 秘钥2 -&gt; 加密, 秘钥3 -&gt; 解密</li>
</ul>
</li>
</ul>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><blockquote>
<p>AES（Advanced Encryption Standard）是取代其前任标准（DES）而成为新标准的一种对称密码算法。全世界的企业和密码学家提交了多个对称密码算法作为AES的候选，最终在2000年从这些候选算法中选出了一种名为==<strong>Rijndael</strong>==的对称密码算法，并将其确定为了AES。</p>
</blockquote>
<blockquote>
<p>**==Rijndael的分组长度为128比特==**，密钥长度可以以32比特为单位在128比特到256比特的范围内进行选择（不过==<strong>在AES的规格中，密钥长度只有128、192和256比特三种</strong>==）。</p>
<p>128bit = 16字节</p>
<p>192bit = 24字节</p>
<p>256bit = 32字节</p>
<p>在go提供的接口中秘钥长度只能是16字节</p>
</blockquote>
<h4 id="AES小结"><a href="#AES小结" class="headerlink" title="AES小结"></a>AES小结</h4><ul>
<li>AES安全吗?<ul>
<li>安全, 效率高, 推荐使用的</li>
</ul>
</li>
<li>是不是分组密码?<ul>
<li>是</li>
</ul>
</li>
<li>AES分组长度?<ul>
<li>128bit = 16字节</li>
</ul>
</li>
<li>AES秘钥长度?<ul>
<li>128bit = 16字节</li>
<li>192bit = 24字节</li>
<li>256bit = 32字节</li>
<li>go中的秘钥长度只能是16字节</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Golang中的GC垃圾回收机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-15 20:14:56" itemprop="dateCreated datePublished" datetime="2021-08-15T20:14:56+08:00">2021-08-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-16 17:15:15" itemprop="dateModified" datetime="2021-08-16T17:15:15+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Golang中的GC垃圾回收机制"><a href="#Golang中的GC垃圾回收机制" class="headerlink" title="Golang中的GC垃圾回收机制"></a>Golang中的GC垃圾回收机制</h1><h2 id="Go-1-3-标记清除-mark-and-sweep"><a href="#Go-1-3-标记清除-mark-and-sweep" class="headerlink" title="Go 1.3 标记清除(mark and sweep)"></a>Go 1.3 标记清除(mark and sweep)</h2><blockquote>
<p>流程：</p>
<ol>
<li>暂停程序业务逻辑, 找出不不可达的对象，和可达对象。</li>
<li>开始标记，程序找出它所有可达的对象，并做上标记。</li>
<li>标记完了了之后，然后开始清除未标记的对象.</li>
<li>停⽌止暂停，让程序继续跑。然后循环重复这个过程，直到process程序⽣生命周期结束。</li>
</ol>
<p>缺点：</p>
<ol>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。将第四步和第三步换位置， 缩短STW的范围</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产⽣生heap碎⽚。</li>
</ol>
</blockquote>
<h2 id="Go-1-5-三色标记法"><a href="#Go-1-5-三色标记法" class="headerlink" title="Go 1.5 三色标记法"></a>Go 1.5 三色标记法</h2><p>流程：</p>
<ol>
<li>只要是新创建的对象,默认的颜⾊色都是标记为“⽩白⾊色”.</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202056508.png" alt="image-20210815202056508" style="zoom:40%;">

<ol start="2">
<li><p>每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202153446.png" alt="image-20210815202153446" style="zoom:40%;"></li>
<li><p>遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202305099.png" alt="image-20210815202305099" style="zoom:40%;">

<ol start="4">
<li><p>重复第三步, 直到灰⾊色中⽆无任何对象.</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202348203.png" alt="image-20210815202348203" style="zoom:30%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202439107.png" alt="image-20210815202439107" style="zoom:30%;"></center></li>
<li><p>回收所有的白色标记表的对象. 也就是回收垃圾.</p>
</li>
</ol>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815202557320.png" alt="image-20210815202557320" style="zoom:40%;">

<h2 id="如果三色标记法不被STW保护"><a href="#如果三色标记法不被STW保护" class="headerlink" title="如果三色标记法不被STW保护"></a>如果三色标记法不被STW保护</h2><p><em>条件1: ⼀一个白色对象被⿊黑色对象引用(白色被挂在黑色下).</em></p>
<p><em>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)</em></p>
<p><em>两个条件同时满⾜足，那么就会出现对象丢失的现象</em></p>
<p>样例：</p>
<p>如果不开启STW：</p>
<center><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203317889.png" alt="image-20210815203317889" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203356122.png" alt="image-20210815203356122" style="zoom:25%;"><img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815203423861.png" alt="image-20210815203423861" style="zoom:25%;"></center>



<h2 id="强弱三色不变式"><a href="#强弱三色不变式" class="headerlink" title="强弱三色不变式"></a>强弱三色不变式</h2><h3 id="强三⾊色不不变式"><a href="#强三⾊色不不变式" class="headerlink" title="强三⾊色不不变式"></a>强三⾊色不不变式</h3><p>破坏条件1</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213638805.png" alt="image-20210815213638805" style="zoom:33%;">

<h3 id="弱三⾊色不不变式"><a href="#弱三⾊色不不变式" class="headerlink" title="弱三⾊色不不变式"></a>弱三⾊色不不变式</h3><p>破坏条件2</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213703432.png" alt="image-20210815213703432" style="zoom:40%;">

<p>如果三色标记满足强弱不变式之一，即可保证不丢失对象.</p>
<h2 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h2><p>屏障？程序运行过程中额外添加的判断机制。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815213927896.png" alt="image-20210815213927896" style="zoom:50%;">

<h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>插入屏障： 对象被引用时，触发的机制。</p>
<p>具体操作： 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p>满足: 强三色不不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	标记灰⾊色(新下游对象ptr)</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.添加下游对象(B, nil)  //A对象，删除B对象的引⽤用。 B被A删除，被标记为灰(如果B之前为⽩)</span><br><span class="line">A.添加下游对象(B, C) //A对象，更更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩)</span><br></pre></td></tr></table></figure>

<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214828157.png" alt="image-20210815214828157" style="zoom:50%;">

<p>插入写屏障只在堆上触发，在栈上不触发。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815214950520.png" alt="image-20210815214950520" style="zoom:26%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215043176.png" alt="image-20210815215043176" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215126841.png" alt="image-20210815215126841" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215308921.png" alt="image-20210815215308921" style="zoom:33%;">

<p>由于栈上不触发插入写屏障，所以在准备回收白色前，需要加STW暂停保护重新扫描一遍栈空间。</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815215334937.png" alt="image-20210815215334937" style="zoom:33%;">

<p>不足：结束时需要STW来重新扫描栈，⼤大约需要10~100ms</p>
<h3 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h3><p>删除屏障：对象被删除时 触发的机制。</p>
<p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">	//1</span><br><span class="line">	<span class="keyword">if</span> (当前下游对象slot是灰⾊色 || 当前下游对象slot是⽩白⾊色) &#123;</span><br><span class="line">		标记灰⾊色(当前下游对象slot) //slot为被删除对象， 标记为灰⾊色</span><br><span class="line">	&#125;</span><br><span class="line">	//2</span><br><span class="line">	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<p>​    A.添加下游对象(B, nil) //A对象，删除B对象的引⽤用。 B被A删除，被标记为灰(如果B之前为⽩白)<br>​    A.添加下游对象(B, C) //A对象，更更换下游B变成C。 B被A删除，被标记为灰(如果B之前为⽩白)</p>
<p>样例：</p>
<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220252392.png" alt="image-20210815220252392" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220332343.png" alt="image-20210815220332343" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220413361.png" alt="image-20210815220413361" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220435567.png" alt="image-20210815220435567" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220500445.png" alt="image-20210815220500445" style="zoom:40%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220533566.png" alt="image-20210815220533566" style="zoom:30%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815220552303.png" alt="image-20210815220552303" style="zoom:40%;">

<p>不足： 回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理理掉。</p>
<h2 id="Go-1-8-混合写屏障机制"><a href="#Go-1-8-混合写屏障机制" class="headerlink" title="Go 1.8 混合写屏障机制"></a>Go 1.8 混合写屏障机制</h2><blockquote>
<p>具体操作:</p>
<ol>
<li>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)</li>
<li>GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>被删除的对象标记为灰色。</li>
<li>被添加的对象标记为灰色。</li>
</ol>
<p>满足: 变形的弱三色不变式. (结合了插入、删除写屏障两者的优点)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//伪码</span><br><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">    //1</span><br><span class="line">    标记灰⾊色(当前下游对象slot) //只要当前下游对象被移⾛走，就标记灰⾊色</span><br><span class="line">    //2</span><br><span class="line">    标记灰⾊色(新下游对象ptr)</span><br><span class="line">    //3</span><br><span class="line">    当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221417608.png" alt="image-20210815221417608" style="zoom:25%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815221437818.png" alt="image-20210815221437818" style="zoom:50%;">

<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>对象被一个堆对象删除引用，成为栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪码</span><br><span class="line">//前提：堆对象4-&gt;对象7 = 对象7； //对象7 被 对象4引⽤用</span><br><span class="line">栈对象1-&gt;对象7 = 堆对象7； //将堆对象7 挂在 栈对象1 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222017066.png" alt="image-20210815222017066" style="zoom:33%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222032431.png" alt="image-20210815222032431" style="zoom:33%;">

<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>对象被一个栈对象删除引用，成为另一个栈对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 栈对象9；</span><br><span class="line">对象9-&gt;对象3 = 对象3； //将栈对象3 挂在 栈对象9 下游</span><br><span class="line">对象2-&gt;对象3 = null； //对象2 删除引⽤用 对象3</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222315895-1629105238588.png" alt="image-20210815222315895" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222346906-1629105238588.png" alt="image-20210815222346906" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222407645-1629105238589.png" alt="image-20210815222407645" style="zoom:50%;">

<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>对象被一个堆对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆对象10-&gt;对象7 = 堆对象7； //将堆对象7 挂在 堆对象10 下游</span><br><span class="line">堆对象4-&gt;对象7 = null； //对象4 删除引⽤用 对象7</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222602561-1629105297759.png" alt="image-20210815222602561" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222619017-1629105297759.png" alt="image-20210815222619017" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222633300-1629105297758.png" alt="image-20210815222633300" style="zoom:50%;">

<h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>对象从一个栈对象删除引用，成为另一个堆对象的下游。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">栈对象1-&gt;对象2 = null； //对象1 删除引⽤用 对象2</span><br><span class="line">堆对象4-&gt;对象7 = null; //对象4 删除引⽤用 对象7</span><br><span class="line">堆对象4-&gt;对象2 = 栈对象2； //对象4 添加 下游 栈对象2</span><br></pre></td></tr></table></figure>

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222835930.png" alt="image-20210815222835930" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222852740.png" alt="image-20210815222852740" style="zoom:50%;">

<img src="/2021/08/15/Golang%E4%B8%AD%E7%9A%84GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/image-20210815222910678.png" alt="image-20210815222910678" style="zoom:50%;">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go V1.3 普通的标记清除法， 整体过程需要STW，效率极低</p>
<p>Go V1.5 三⾊色标记法， 堆空间启动写屏障，栈空间不启动， 全部扫描之后，需要重新扫描⼀一次栈(需要STW)， 效率普通</p>
<p>Go V1.8 三⾊色标记法，混合写屏障机制， 栈空间不不启动，堆空间启动， 整体过程⼏几乎不不需要STW， 效率较高</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/" class="post-title-link" itemprop="url">周易基础及其应用01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-08-15 14:59:26" itemprop="dateCreated datePublished" datetime="2021-08-15T14:59:26+08:00">2021-08-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-08-18 00:08:52" itemprop="dateModified" datetime="2021-08-18T00:08:52+08:00">2021-08-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">哲学</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">周易基础及其应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="周易基础及应用"><a href="#周易基础及应用" class="headerlink" title="周易基础及应用"></a>周易基础及应用</h1><p>千古奇书《周易》</p>
<p>人更三圣：伏羲    周文王    孔夫子</p>
<p>事历三古：远古    中古         近古</p>
<p>《易经》它是以八卦为核心，以卦的形式来说明问题，以阴爻和阳爻来说明问题，以阴爻和阳爻的相互配合，以文字系统与符号系统相结合说明万事万物的根本规律。</p>
<p>《易经》为群经之首。</p>
<p>系词： <strong>夫《易》何为者也，开物成务斯如此也。</strong>  开物成务：开物是认识事物的本质，成务是怎么去解决这个问题。</p>
<p><strong>不善易者，不得为将相。</strong>   </p>
<p><strong>不知易不足以言大医。   ————孙思邈</strong></p>
<p>易道广大，无所不包。</p>
<p>《易》与天地准，故能弥纶天地之道。</p>
<p>百姓日用而不知。</p>
<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815150334560.png" alt="image-20210815150334560" style="zoom:33%;">

<h2 id="阴阳学说"><a href="#阴阳学说" class="headerlink" title="阴阳学说"></a>阴阳学说</h2><p>易以道阴阳。 ——庄子</p>
<p>天地间无往而非阴阳，一动一静一语一默，皆是阴阳之理。 ———朱熹</p>
<p>阳：天    上    昼    男    君    贵    福 ….</p>
<p>阴：地    下    夜    女    臣    贱    祸 ….</p>
<p><strong>一阴一阳之谓道。</strong></p>
<p>主要内容：</p>
<ul>
<li>阴阳对立</li>
<li>阴阳依存（互根）。有无相生，难易相成，长短相盈，高低相形，音声相合，前后相随，恒也。</li>
<li>阴阳消长。阴阳动态变化，动态平衡。阴盛则阳病，阳盛则阴病。</li>
<li>阴阳转换。消长属于量变，转化属于质变。</li>
</ul>
<p>中国哲学三大问题：天人、群己、身心</p>
<p>重视对立，追求平衡。</p>
<h2 id="五行学说"><a href="#五行学说" class="headerlink" title="五行学说"></a>五行学说</h2><p>世界上的万事万物的运动和发生发展都是”金木水火土“这五种状态，相互作用、相互运动的结果。  ——&gt;系统观</p>
<h3 id="五行特点"><a href="#五行特点" class="headerlink" title="五行特点"></a>五行特点</h3><blockquote>
<p>五行顺序              特性        方位    五德            季节</p>
<p>一曰水    润下    润下寒冷    北方    智               冬季</p>
<p>二曰火    炎上    炎热向上    南方    礼               夏季</p>
<p>三曰木    曲直    生发条达    东方    仁               春季</p>
<p>四曰金    从草    清凉萧杀    西方    义                秋季</p>
<p>五曰土    稼穑    长养化育    中央    信      农历（三、六、九、十二月）</p>
</blockquote>
<h3 id="五行生克"><a href="#五行生克" class="headerlink" title="五行生克"></a>五行生克</h3><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210815160518695.png" alt="image-20210815160518695" style="zoom:33%;">

<h3 id="五行的旺、相、休、囚、死"><a href="#五行的旺、相、休、囚、死" class="headerlink" title="五行的旺、相、休、囚、死"></a>五行的旺、相、休、囚、死</h3><p>生克制化之理</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">旺</th>
<th align="center">相</th>
<th align="center">死</th>
<th align="center">囚</th>
<th align="center">休</th>
</tr>
</thead>
<tbody><tr>
<td align="center">春</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
</tr>
<tr>
<td align="center">夏</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
</tr>
<tr>
<td align="center">秋</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
</tr>
<tr>
<td align="center">冬</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
<td align="center">土</td>
<td align="center">金</td>
</tr>
<tr>
<td align="center">四季</td>
<td align="center">土</td>
<td align="center">金</td>
<td align="center">水</td>
<td align="center">木</td>
<td align="center">火</td>
</tr>
</tbody></table>
<h2 id="天干地支"><a href="#天干地支" class="headerlink" title="天干地支"></a>天干地支</h2><h3 id="十天干"><a href="#十天干" class="headerlink" title="十天干"></a>十天干</h3><blockquote>
<p>甲        乙        丙        丁        戊        己        庚        辛        壬        癸</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">甲乙同属木</td>
<td>东方</td>
<td>甲阳木</td>
<td>乙阴木</td>
</tr>
<tr>
<td align="center">丙丁同属火</td>
<td>南方</td>
<td>丙阳火</td>
<td>丁阴火</td>
</tr>
<tr>
<td align="center">戊己同属土</td>
<td>中央</td>
<td>戊阳土</td>
<td>己阴土</td>
</tr>
<tr>
<td align="center">庚辛同属金</td>
<td>西方</td>
<td>庚阳金</td>
<td>辛阴金</td>
</tr>
<tr>
<td align="center">壬癸同属水</td>
<td>北方</td>
<td>壬阳水</td>
<td>癸阴水</td>
</tr>
</tbody></table>
<h4 id="天干相和"><a href="#天干相和" class="headerlink" title="天干相和"></a>天干相和</h4><blockquote>
<p>甲己合土</p>
<p>乙庚合金</p>
<p>丙辛合水</p>
<p>丁壬合木</p>
<p>戊癸合火</p>
</blockquote>
<h4 id="十天干的相生相克"><a href="#十天干的相生相克" class="headerlink" title="十天干的相生相克"></a>十天干的相生相克</h4><img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165629369.png" alt="image-20210815160518695">

<img src="/2021/08/15/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A801/image-20210816165743365.png" alt="image-20210815160518695">




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
