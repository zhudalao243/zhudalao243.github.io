<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhudalao243.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://zhudalao243.github.io/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="zzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zhudalao243.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>上善若水</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">上善若水</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">成为一个有智慧的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zzy"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">zzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对sync.Map的理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-15 08:21:42 / 修改時間：09:58:44" itemprop="dateCreated datePublished" datetime="2021-09-15T08:21:42+08:00">2021-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="并发报错的map"><a href="#并发报错的map" class="headerlink" title="并发报错的map"></a>并发报错的map</h2><p>举例：一个goroutine一直读，一个goroutine一只写同一个键值，即即使读写的键不相同，而且map也没有”扩容”等操作，代码还是会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误信息是： <font color="red"><code>fatal error: concurrent map read and map write</code></font></p>
<p>源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> 	 ...</span><br><span class="line">	hashWriting  = <span class="number">4</span> <span class="comment">// a goroutine is writing to the map</span></span><br><span class="line">	...</span><br><span class="line">) </span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	...</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// map是检查是否有另外线程修改h.flag来判断，是否有并发问题。</span></span><br><span class="line"><span class="comment">// 在更新map的函数里检查并发写</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">	throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">// 在读map的函数里检查是否有并发写</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">	throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go通过map结构体中的flags字段来管理并发。当程序试图修改map（赋新值、删除value或者清空map），flags字段的某一位会被设置为1：</p>
<p>hashWriting的值是4，并将相应的位设置为1。 ^是一个异或操作，如果两个操作数的位相反，则将对应位设置为1。</p>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/578e8ecd09367196eb5e37da0a608bb4.png" alt="img" style="zoom:67%;">

<p>然而，该标志位将在操作结束时被重置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// if another process is currently writing, throw error</span></span><br><span class="line">   <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// no one is writing, we can set now the flag</span></span><br><span class="line">   h.flags ^= hashWriting   <span class="comment">// 0 0 0 1 0 0</span></span><br><span class="line">   [...]</span><br><span class="line">   <span class="comment">// flag reset</span></span><br><span class="line">   h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>底层结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装的线程安全的map</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// lock</span></span><br><span class="line">	mu Mutex</span><br><span class="line">	<span class="comment">// 实际是readOnly这个结构</span></span><br><span class="line">	<span class="comment">// 一个只读的数据结构，因为只读，所以不会有读写冲突。</span></span><br><span class="line">	<span class="comment">// readOnly包含了map的一部分数据，用于并发安全的访问。(冗余，内存换性能)</span></span><br><span class="line">	<span class="comment">// 访问这一部分不需要锁。</span></span><br><span class="line">	read atomic.Value <span class="comment">// readOnly 原子性</span></span><br><span class="line">	<span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line">	<span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line">	<span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line">	<span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></span><br><span class="line">	misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">	<span class="comment">// 如果Map.dirty有些数据不在m中，这个值为true</span></span><br><span class="line">	amended <span class="keyword">bool</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An entry is a slot in the map corresponding to a particular key.</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">	p unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readOnly中<code>amended</code>指明<code>Map.dirty</code>中有<code>readOnly.m</code>未包含的数据，所以如果从<code>Map.read</code>找不到数据的话，还要进一步到<code>Map.dirty</code>中查找。</p>
<p>这里虽然有冗余的两份map数据，但是Map.dirty和readOnly.m的value都是一个指针变量 *entry，所以整体内存占用还好。</p>
<p>sync.Map 的kv都是 interface{} ，entry里面的p实际是一个 *interface{}，也就是entry实际保存的是指向value的指针。</p>
<p>entry中的p有三个值：</p>
<ol>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的value</li>
</ol>
<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>线程安全的加载key对应的value：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.首先从m.read中加载只读的readOnly, 从它的map中查找，无锁。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line">    <span class="comment">// read.amended 指明&#x27;Map.dirty`中有`readOnly.m`未包含的数据，所以如果从`Map.read`找不到数据的话，还要进一步到`Map.dirty`中查找</span></span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		<span class="comment">// double check</span></span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			<span class="comment">// // 从m.dirty查找</span></span><br><span class="line">			e, ok = m.dirty[key]</span><br><span class="line">			<span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line">			<span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">			m.missLocked()</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 原子加载 *entry 所保存的value。</span></span><br><span class="line">	<span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.misses++</span><br><span class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">	m.dirty = <span class="literal">nil</span></span><br><span class="line">	m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110724714.png" alt="img" style="zoom:80%;">

<p>首先要强调的是，首先是从readonly里面读，读不到时候才加锁去 map.dirty 里面去读，并且加锁之后首先是进行double check(熟悉Java的都知道double check是什么)。</p>
<p>double check 之后即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>missLocked方法中可能会将m.dirty提升，m,misses会记录从readOnly中获取不到 *entry 的次数，也就是miss的次数，如果达到了 len(m.dirty) 就会原子的替换m.read.m 为 m.dirty。提升后m.dirty、m.misses重置， 并且m.read.amended为false。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 如果m.read存在这个键，并且这个entry没有被标记删除(expunged)，尝试直接存储</span></span><br><span class="line">	<span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. m.read不存在或者已经被标记删除</span></span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="comment">// double check</span></span><br><span class="line">	read, _ = m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">		<span class="keyword">if</span> e.unexpungeLocked() &#123;<span class="comment">//标记成未被删除</span></span><br><span class="line">			<span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></span><br><span class="line">			m.dirty[key] = e</span><br><span class="line">		&#125;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">// m.dirty存在这个键，更新</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">		e.storeLocked(&amp;value)</span><br><span class="line">	<span class="comment">//新键值</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//m.dirty中没有比m.readOnly更新的数据，往m.dirty中增加第一个新键</span></span><br><span class="line">		<span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">			<span class="comment">// 从m.read中复制未删除的数据</span></span><br><span class="line">			<span class="comment">// 并标记m.read已经落后于m.dirty</span></span><br><span class="line">			m.dirtyLocked()</span><br><span class="line">			m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将这个entry加入到m.dirty中</span></span><br><span class="line">		m.dirty[key] = newEntry(value)</span><br><span class="line">	&#125;</span><br><span class="line">	m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tryStore stores a value if the entry has not been expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry is expunged, tryStore returns false and leaves the entry</span></span><br><span class="line"><span class="comment">// unchanged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryStore</span><span class="params">(i *<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">			m.dirty[k] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110342685.png" alt="img" style="zoom:40%;">

<p>以上操作都是先从操作m.read开始的，不满足条件再加锁，然后操作m.dirty。</p>
<p>可能会发生两种数据迁移：</p>
<ol>
<li><p>从m.dirty到m.read的迁移，这个迁移过程其实是指针的的修改，所以效率高；</p>
</li>
<li><p>从read map到dirty map的迁移, 这个迁移需要创建一个新的map来复制key-value，所以效率会低一些</p>
<p><font color="red">Store可能会在某种情况下（在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中）从m.read中复制数据到m.dirty，如果这个时候m.read中数据量非常大，可能会影响性能。</font></p>
</li>
</ol>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 如果不存在于 m.read中，而且 m.dirty 和 m.read 数据不一致。</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	e, ok := read.m[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">		<span class="comment">// 加锁，double check， 然后删除对应的key。</span></span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		e, ok = read.m[key]</span><br><span class="line">		<span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">			<span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		e.<span class="built_in">delete</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112111125713.png" alt="img" style="zoom:80%;">

<p>这里会删除 m.dirty 对应的key-value, 但是m.read中的key-value其实并没有删除，只是设置了删除的标志为expunged。这里的惰性删除避免了重新创建 entry 实体，只用更新指针和value指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>这里sync.Map是对map关键字的封装，肯定无法使用系统提供的 for range 操作。所以这里采用了一个回调的操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Range</span><span class="params">(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历</span></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">		<span class="comment">///提升m.dirty</span></span><br><span class="line">		m.mu.Lock()</span><br><span class="line">		read, _ = m.read.Load().(readOnly)</span><br><span class="line">		<span class="keyword">if</span> read.amended &#123;</span><br><span class="line">			read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">			m.read.Store(read)</span><br><span class="line">			m.dirty = <span class="literal">nil</span></span><br><span class="line">			m.misses = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历, for range是安全的</span></span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		v, ok := e.load()</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Range方法调用前可能会做一个m.dirty的提升，不过提升m.dirty不是一个耗时的操作。</p>
<h3 id="sync-Map总结"><a href="#sync-Map总结" class="headerlink" title="sync.Map总结"></a>sync.Map总结</h3><p>sync.Map的优化策略简单总结可以理解为：</p>
<ol>
<li>无锁读与读写分离；</li>
</ol>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110232202.png" alt="img" style="zoom:50%;">

<ol start="2">
<li>写加锁与延迟提升；</li>
</ol>
<img src="/2021/09/15/%E5%AF%B9sync-Map%E7%9A%84%E7%90%86%E8%A7%A3/20200112110214618.png" alt="img" style="zoom:50%;">

<ol start="3">
<li>指针与惰性删除，map保存的value都是指针。惰性删除，实际删除是在 Store时候去check 然后删除。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/13/Linux%E4%B8%8B4G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/13/Linux%E4%B8%8B4G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83/" class="post-title-link" itemprop="url">Linux下4G虚拟地址空间的分布</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-13 16:46:59 / 修改時間：17:07:29" itemprop="dateCreated datePublished" datetime="2021-09-13T16:46:59+08:00">2021-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>所编写的源代码并不是程序，从C代码（.c/.cpp)—-&gt;链接程序（.exe）是要经过以下几个过程才能真正的运行链接的；</p>
<p>C源程序—&gt;预编译处理（.c/.cpp）–&gt;编译，优化程序（.s）—&gt;汇编程序(.o)—&gt;链接(.exe)</p>
<p>在编译运行过程中，首先需要将程序存储到内存中才能调取运行，但是内存是有限的，不可能将所有的进程都放在内存中去，所以都会给给进程分配一个4G的虚拟地址空间存储数据，在进程运行时在映射到内存中去。</p>
<blockquote>
<p>windows下 4G的空间分布为 ：  用户态：内核态=1：1</p>
<p>Linux下    4G的空间分布为：   用户态：内核态=3：1  </p>
</blockquote>
<p>32位处理机 32 指计算机最多一次处理的比特位, 进程地址空间需要隔离，防止恶意的程序修改其他程序的内存数据，因此计算机中引入虚拟地址空间。4GB虚拟地址空间布局如下图所示</p>
<img src="/2021/09/13/Linux%E4%B8%8B4G%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83/20181113112843119.png" alt="img" style="zoom:60%;">

<p>用户空间：</p>
<p>1、128M大小的不可访问区域（保留区）不可读、不可写</p>
<pre><code>  我们通常将申请的临时变量指针初始化时置为NULL，可以防止后续无意使用这个指针时出错，NULL=0X00，而保留区的数据不能访问。
</code></pre>
<p>2、.text代码段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储代码中的指令。一份代码是由数据和指令构成的，局部变量也属于指令，但是局部变量存储在栈上，代码运行时才在栈中预留好的区域中开辟</span><br></pre></td></tr></table></figure>

<p>3、.data段</p>
<pre><code>这个区域存储代码中的各种数据，包括全局变量，静态局部变量。且必须为已经初始化且初始化不为0的数据
</code></pre>
<p>4、.bss段</p>
<pre><code> 这个区域存储的也是代码中的各种数据，和.data不同的是，存储的是未初始化或者初始化了但为0 的数据（这个段在可执行文件中不占用空间）
</code></pre>
<p>5、堆</p>
<pre><code> 当我们需要申请一块连续且指定大小的内存块的动态内存时，需要在 堆中申请。并且需要手动申请，手动释放。不释放会造成内存泄漏
</code></pre>
<p>6、栈</p>
<pre><code>所有的局部变量存储在这里，函数的运行也需要栈的开辟，释放空间由系统完成
</code></pre>
<p>内核空间：</p>
<p>1、内存直接访问区（ZONE_DMA 大约16M）</p>
<blockquote>
<p>ZONE_DirectMemoryAccess(直接内存访问)可以加快磁盘和内存之间的数据交换，不需要经过CPU的寄存器，这是CPU可以去干别的事，大大增加了效率。</p>
</blockquote>
<p>2、ZONE_NORMAL（大约892M）</p>
<blockquote>
<p>内核中最重要最常用的部分，用于直接映射，PCB就在这里。</p>
</blockquote>
<p>3、ZONE_HIGHMEM(128M)</p>
<blockquote>
<p>高端内存，用于在内核中映射高于1GB的物理内存时使用，64位操作系统没有该段</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> gdata1=<span class="number">10</span>;  <span class="comment">//.data</span></span><br><span class="line"><span class="keyword">int</span> gdata2=<span class="number">0</span>;   <span class="comment">//.bss</span></span><br><span class="line"><span class="keyword">int</span>  gdata3;    <span class="comment">//.bss</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata4=<span class="number">20</span>;  <span class="comment">//.data</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata5=<span class="number">0</span>;  <span class="comment">//.bss</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata6;     <span class="comment">//.bss</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ldata1=<span class="number">30</span>;  <span class="comment">//.text(普通的局部变量开始都为指令存在指令区，只有在运行编译时在栈上开辟空间存储)</span></span><br><span class="line">     <span class="keyword">int</span> ldata2=<span class="number">0</span>;   <span class="comment">//.text</span></span><br><span class="line">     <span class="keyword">int</span> ldata3;    <span class="comment">//.text</span></span><br><span class="line">     ststic <span class="keyword">int</span> ldata4=<span class="number">40</span>;  <span class="comment">//.data</span></span><br><span class="line">     <span class="keyword">static</span>  <span class="keyword">int</span>  ldata5=<span class="number">0</span>;  <span class="comment">//.bss</span></span><br><span class="line">     <span class="keyword">static</span>  <span class="keyword">int</span>  ldata6;    <span class="comment">//.bss</span></span><br><span class="line">      <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/11/%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/11/%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">题目01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-11 22:27:44 / 修改時間：22:51:36" itemprop="dateCreated datePublished" datetime="2021-09-11T22:27:44+08:00">2021-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构按照操作系统的分类，属于分时操作系统。<br>UNIX系统是一个多用户，多任务的分时操作系统。<br>UNIX的系统结构可分为三部分：<pre><code>操作系统内核（是UNIX系统核心管理和控制中心，在系统启动或常驻内存），
系统调用（供程序开发者开发应用程序时调用系统组件，包括进程管理，文件管理，设备状态等），
应用程序（包括各种开发工具，编译器，网络通讯处理程序等，所有应用程序都在Shell的管理和控制下为用户服务）。     
</code></pre>
UNIX系统大部分是由C语言编写的。</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/08/const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88and%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/08/const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88and%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">const修饰指针and引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-08 16:35:28 / 修改時間：16:43:35" itemprop="dateCreated datePublished" datetime="2021-09-08T16:35:28+08:00">2021-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>const修饰指针有三种情况</p>
<ol>
<li>const修饰指针   — 常量指针</li>
<li>const修饰常量   — 指针常量</li>
<li>const即修饰指针，又修饰常量</li>
</ol>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;a; </span><br><span class="line">	p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">	<span class="comment">//*p1 = 100;  报错</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line">	<span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">	<span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">	*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">	<span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line">	<span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p>
</blockquote>
<h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="comment">// int&amp; v = int* const v</span></span><br><span class="line"><span class="comment">// const int&amp; v =  const int * const v </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/" class="post-title-link" itemprop="url">04长生掌决</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-03 22:14:07 / 修改時間：23:17:51" itemprop="dateCreated datePublished" datetime="2021-09-03T22:14:07+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">哲学</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">周易基础及其应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <table>
<thead>
<tr>
<th align="center"></th>
<th align="center">金</th>
<th align="center">木</th>
<th align="center">火</th>
<th align="center">水土</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">长生</font></td>
<td align="center"><font color="yellow">巳</font></td>
<td align="center"><font color="yellow">亥</font></td>
<td align="center"><font color="yellow">寅</font></td>
<td align="center"><font color="yellow">申</font></td>
</tr>
<tr>
<td align="center">沐浴</td>
<td align="center">午</td>
<td align="center">子</td>
<td align="center">卯</td>
<td align="center">酉</td>
</tr>
<tr>
<td align="center">冠带</td>
<td align="center">未</td>
<td align="center">丑</td>
<td align="center">辰</td>
<td align="center">戌</td>
</tr>
<tr>
<td align="center">临官</td>
<td align="center">申</td>
<td align="center">寅</td>
<td align="center">巳</td>
<td align="center">亥</td>
</tr>
<tr>
<td align="center"><font color="red">帝旺</font></td>
<td align="center"><font color="yellow">酉</font></td>
<td align="center"><font color="yellow">卯</font></td>
<td align="center"><font color="yellow">午</font></td>
<td align="center"><font color="yellow">子</font></td>
</tr>
<tr>
<td align="center">衰</td>
<td align="center">戌</td>
<td align="center">辰</td>
<td align="center">未</td>
<td align="center">丑</td>
</tr>
<tr>
<td align="center">病</td>
<td align="center">亥</td>
<td align="center">巳</td>
<td align="center">申</td>
<td align="center">寅</td>
</tr>
<tr>
<td align="center">死</td>
<td align="center">子</td>
<td align="center">午</td>
<td align="center">酉</td>
<td align="center">卯</td>
</tr>
<tr>
<td align="center"><font color="red">墓</font></td>
<td align="center"><font color="yellow">丑</font></td>
<td align="center"><font color="yellow">未</font></td>
<td align="center"><font color="yellow">戌</font></td>
<td align="center"><font color="yellow">辰</font></td>
</tr>
<tr>
<td align="center"><font color="red">绝</font></td>
<td align="center"><font color="yellow">寅</font></td>
<td align="center"><font color="yellow">申</font></td>
<td align="center"><font color="yellow">亥</font></td>
<td align="center"><font color="yellow">巳</font></td>
</tr>
<tr>
<td align="center">胎</td>
<td align="center">卯</td>
<td align="center">酉</td>
<td align="center">子</td>
<td align="center">午</td>
</tr>
<tr>
<td align="center">养</td>
<td align="center">辰</td>
<td align="center">戌</td>
<td align="center">丑</td>
<td align="center">未</td>
</tr>
</tbody></table>
<blockquote>
<p>水土的十二长生一起，六爻就这么规定；命理中土是附在火上面。</p>
<p>在六爻中主要记住：长生，帝旺，墓，绝</p>
</blockquote>
<h2 id="金的记忆方法"><a href="#金的记忆方法" class="headerlink" title="金的记忆方法"></a>金的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223723589.png" alt="image-20210903223723589" style="zoom:70%;">

<h2 id="木的记忆方法"><a href="#木的记忆方法" class="headerlink" title="木的记忆方法"></a>木的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223819633.png" alt="image-20210903223819633" style="zoom:70%;">

<h2 id="火的记忆方法"><a href="#火的记忆方法" class="headerlink" title="火的记忆方法"></a>火的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223915736.png" alt="image-20210903223915736 " style="zoom:70%;">

<h2 id="水土的记忆方法"><a href="#水土的记忆方法" class="headerlink" title="水土的记忆方法"></a>水土的记忆方法</h2><img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903223941093.png" alt="image-20210903223941093" style="zoom:70%;">

<h1 id="地支与节令"><a href="#地支与节令" class="headerlink" title="地支与节令"></a>地支与节令</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">春季</td>
<td align="center">立春</td>
<td align="center">正月</td>
<td align="center">建寅</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">惊蛰</td>
<td align="center">二月</td>
<td align="center">建卯</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">清明</td>
<td align="center">三月</td>
<td align="center">建辰</td>
</tr>
<tr>
<td align="center">夏季</td>
<td align="center">立夏</td>
<td align="center">四月</td>
<td align="center">建巳</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">芒种</td>
<td align="center">五月</td>
<td align="center">建午</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小暑</td>
<td align="center">六月</td>
<td align="center">建未</td>
</tr>
<tr>
<td align="center">秋季</td>
<td align="center">立秋</td>
<td align="center">七月</td>
<td align="center">建申</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">白露</td>
<td align="center">八月</td>
<td align="center">建酉</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">寒露</td>
<td align="center">九月</td>
<td align="center">建戌</td>
</tr>
<tr>
<td align="center">冬季</td>
<td align="center">立冬</td>
<td align="center">十月</td>
<td align="center">建亥</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">大雪</td>
<td align="center">十一月</td>
<td align="center">建子</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">小寒</td>
<td align="center">十二月</td>
<td align="center">建丑</td>
</tr>
</tbody></table>
<blockquote>
<p>以上月份均为阴历</p>
</blockquote>
<p>子丑寅卯辰巳午未申酉戌亥</p>
<img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903225507640.png" alt="image-20210903225507640" style="zoom:50%;">

<img src="/2021/09/03/04%E9%95%BF%E7%94%9F%E6%8E%8C%E5%86%B3/image-20210903225638514.png" alt="image-20210903225638514" style="zoom:50%;">

<blockquote>
<p><font color="red">年以立春作为界限，立春以前按前一年算，立春以后按这一年算</font></p>
</blockquote>
<p>P12</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/" class="post-title-link" itemprop="url">03地支三合局与相刑相害</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2021-09-02 19:22:31" itemprop="dateCreated datePublished" datetime="2021-09-02T19:22:31+08:00">2021-09-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新於</span>
        <time title="修改時間：2021-09-03 22:10:22" itemprop="dateModified" datetime="2021-09-03T22:10:22+08:00">2021-09-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">哲学</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%B2%E5%AD%A6/%E5%91%A8%E6%98%93%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">周易基础及其应用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902192840745.png" alt="image-20210902192840745" style="zoom:67%;">

<blockquote>
<p>丑土子水 ===&gt; 合克</p>
<p>寅木亥水 ===&gt; 合生</p>
<p>卯木戌土 ===&gt; 合克</p>
<p>辰土酉金 ===&gt; 合生</p>
<p>午火未土 ===&gt; 合生</p>
<p>巳火申金 ===&gt; 合克（在六爻中以合为主）巳与申以合论</p>
</blockquote>
<h2 id="地支三合局"><a href="#地支三合局" class="headerlink" title="地支三合局"></a>地支三合局</h2><blockquote>
<p>寅午戌合火局              寅（木）   午（火） 戌（土）   火局</p>
<p>申子辰合水局              申（金）   子（水） 辰（土）   水局</p>
<p>亥卯未合木局</p>
<p>巳酉丑合金局</p>
</blockquote>
<h2 id="地支相刑"><a href="#地支相刑" class="headerlink" title="地支相刑"></a>地支相刑</h2><blockquote>
<p>三刑</p>
<p>寅巳申</p>
<p>丑未戌</p>
</blockquote>
<blockquote>
<p>两刑</p>
<p>寅刑巳                    巳刑申</p>
<p>申刑寅                    丑刑未</p>
<p>未刑戌                    戌刑丑</p>
<p>子刑卯                    卯刑子   ====&gt; 相互刑     一般乱搞男女关系</p>
<p>辰午酉亥 ===&gt; 自己刑自己，自己伤害自己</p>
<p>三刑考虑的较多，两刑考虑的较少。</p>
</blockquote>
<h2 id="地支相害"><a href="#地支相害" class="headerlink" title="地支相害"></a>地支相害</h2><blockquote>
<p>子未相害</p>
<p>丑午相害</p>
<p>寅巳相害</p>
<p>卯辰相害</p>
<p>申亥相害</p>
<p>酉戌相害</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902200048607.png" alt="image-20210902200048607" style="zoom:67%;">

<p>举例：</p>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902200856012.png" alt="image-20210902200856012" style="zoom:50%;">

<blockquote>
<p>婚外恋：子（妻子）  丑（丈夫） 未（小三），丑未相冲，子未相害。小三向丈夫发起进攻，则害了妻子。</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902202953530.png" alt="image-20210902202953530" style="zoom:50%;">

<blockquote>
<p>午丑相害（美国侵略朝鲜），敌人的敌人就是朋友！</p>
</blockquote>
<img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902203056376.png" alt="image-20210902203056376" style="zoom:50%;">

<blockquote>
<p>敌人的朋友就是敌人。</p>
</blockquote>
<h2 id="地支与生肖"><a href="#地支与生肖" class="headerlink" title="地支与生肖"></a>地支与生肖</h2><blockquote>
<p>子    丑    寅    卯    辰    巳    午    未    申    酉    戌    亥</p>
<p>鼠    牛    虎    兔    龙    蛇    马    羊    猴    鸡    狗    猪</p>
</blockquote>
<h2 id="地支与时辰"><a href="#地支与时辰" class="headerlink" title="地支与时辰"></a>地支与时辰</h2><img src="/2021/09/02/%E5%9C%B0%E6%94%AF%E4%B8%89%E5%90%88%E5%B1%80%E4%B8%8E%E7%9B%B8%E5%88%91%E7%9B%B8%E5%AE%B3/image-20210902203417019.png" alt="image-20210902203417019" style="zoom:67%;">

<p>P11</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">虚拟内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-01 16:56:22 / 修改時間：17:03:26" itemprop="dateCreated datePublished" datetime="2021-09-01T16:56:22+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><h3 id="1-传统存储管理方式的缺点"><a href="#1-传统存储管理方式的缺点" class="headerlink" title="1. 传统存储管理方式的缺点"></a>1. 传统存储管理方式的缺点</h3><p>连续分配与非连续分配都属于传统存储管理方式</p>
<p>(1) 一次性</p>
<p>作业必须一次性全部装入内存后才能开始运行</p>
<p>(2) 驻留性</p>
<p>一旦作业被装入内存，就会一直驻留在内存中直至作业运行结束；但事实上，一个时间段内，只需要作业的一小部分数据即可正常运行</p>
<h3 id="2-虚拟内存的定义"><a href="#2-虚拟内存的定义" class="headerlink" title="2. 虚拟内存的定义"></a>2. 虚拟内存的定义</h3><p>(1) 程序装入内存时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存</p>
<p>(2) 程序运行过程中，所要访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>
<p>(3) 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>
<p>(4) 使得用户感觉有一个比实际内存大得多的内存，实际上物理内存大小并未改变，只是在逻 辑上进行了扩充，这就是虚拟内存</p>
<h3 id="3-虚拟内存的特征"><a href="#3-虚拟内存的特征" class="headerlink" title="3. 虚拟内存的特征"></a>3. 虚拟内存的特征</h3><p>(1) 多次性 ：作业被分成多次调入内存</p>
<p>(2) 对换性：作业在运行过程中，可以将作业换入、换出</p>
<p>(3) 虚拟性：从逻辑上扩充了内存的容量，使用户感觉有一个更大的内存</p>
<h3 id="4-知识回顾"><a href="#4-知识回顾" class="headerlink" title="4.  知识回顾"></a>4.  知识回顾</h3><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132643299.png" alt="img" style="zoom:67%;">

<h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>请求分页管理方式与基本分页管理的主要区别在于增加了请求调页和页面置换两个功能</p>
<h3 id="1-页表机制"><a href="#1-页表机制" class="headerlink" title="1. 页表机制"></a>1. 页表机制</h3><p>(1) 为了实现请求调页，操作系统需要通过状态位知道每个页面是否已经调入内存；如果还没 有调入，也需要知道该页面在外存中存放的位置</p>
<p>(2) 为了实现页面置换，操作系统需要决定将哪个页面换出到外存：有的页面没有被修改过， 就不必浪费时间写回外存；有的页面被修改过，就需要将外存中的旧数据覆盖；因此，操 作系统还需要记录每个页面是否被修改过的信息<br><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132658444.png" alt="img" style="zoom:110%;"></p>
<h3 id="2-缺页中断机构"><a href="#2-缺页中断机构" class="headerlink" title="2. 缺页中断机构"></a>2. 缺页中断机构</h3><p>(1) 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系 统的缺页中断处理程序处理中断；此时缺页的进程阻塞，放入阻塞队列中，调页完成后再 将其唤醒，放回就绪队列</p>
<p>(2) 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相 应的页表项</p>
<p>(3) 如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修 改过，则要将其写回外存；未修改过的页面不用写回外存</p>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132707611.png" alt="img" style="zoom:80%;">

<h2 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h2><p>使用页面置换算法决定将哪个页面换出，好的页面置换算法应当追求更少的缺页率，即换入、换出 的次数尽可能的少</p>
<h3 id="1-最佳置换算法-OPT"><a href="#1-最佳置换算法-OPT" class="headerlink" title="1. 最佳置换算法(OPT)"></a>1. 最佳置换算法(OPT)</h3><p>每次选择淘汰的页面是以后永不使用或者最长时间内不再被访问的页面，以保证最低的缺页率</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132717866.png" alt="img" style="zoom:67%;">

<p>操作系统无法预判页面访问顺序，故最佳置换算法无法实现</p>
<h3 id="2-先进先出置换算法-FIFO"><a href="#2-先进先出置换算法-FIFO" class="headerlink" title="2. 先进先出置换算法(FIFO)"></a>2. 先进先出置换算法(FIFO)</h3><p>每次选择淘汰的页面是最早进入内存的页面</p>
<p>实现方法：每次向内存中调入页面时，将页面添加到一个队列的队尾，需要换出页面时换出队 头的页面即可，队列的最大长度取决于内存块的个数</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132724177.png" alt="img" style="zoom:80%;">

<p>注意：FIFO算法会产生Belady异常，即为进程分配的内存块增多时，缺页次数不减反增的现象，因此，FIFO算法性能较差</p>
<h3 id="3-最近最久未使用置换算法-LRU"><a href="#3-最近最久未使用置换算法-LRU" class="headerlink" title="3. 最近最久未使用置换算法(LRU)"></a>3. 最近最久未使用置换算法(LRU)</h3><p>每次选择淘汰的页面是最近最久未使用的页面</p>
<p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的 时间t，当需要淘汰一个页面时，选择现有页面中t值最大的</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132730300.png" alt="img" style="zoom:150%;">

<h3 id="4-最不常用算法（LFU）"><a href="#4-最不常用算法（LFU）" class="headerlink" title="4.最不常用算法（LFU）"></a>4.最不常用算法（LFU）</h3><p>当缺页中断时，选择访问次数最少的那个页面，淘汰之<br>这样新页很吃亏啊<br>取决于程序访问特征</p>
<img src="/2021/09/01/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/20201227132735208.png" alt="img" style="zoom:150%;">








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/09/01/%E6%B5%85%E8%B0%88TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/01/%E6%B5%85%E8%B0%88TCP/" class="post-title-link" itemprop="url">浅谈TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-09-01 14:12:13 / 修改時間：15:38:05" itemprop="dateCreated datePublished" datetime="2021-09-01T14:12:13+08:00">2021-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><ol>
<li><p>TCP是面向连接(虚连接)的传输层协议。</p>
</li>
<li><p>每一条TCP连接只能有两个端点，每一条TCP连接 只能是点对点的。</p>
</li>
<li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。可靠有序，不丢不重</p>
</li>
<li><p>4.TCP提供全双工通信。</p>
<ul>
<li>发送缓存准备发送的数据&amp;已发送但尚未收到确认的数据</li>
<li>接收缓存按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</li>
</ul>
</li>
<li><p>TCP面向字节流口。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p>
<p>流:流入到进程或从进程流出的字节序列。.</p>
</li>
</ol>
<p>TCP传输数据是随机切割数据的</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/2020063020421472.png" alt="img " style="zoom:70%;">

<h2 id="TCP报文段的首部"><a href="#TCP报文段的首部" class="headerlink" title="TCP报文段的首部"></a>TCP报文段的首部</h2><p>注释：见上图，可以看到TCP是将数据随机分割后加上TCP头传输的，所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号<br>确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据<br>偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630210441410.png" alt="img" style="zoom:80%;"></p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630212601599.png" alt="img" style="zoom:80%;">

<p>窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据<br>紧急指针就是告诉TCP从哪里到哪里是紧急数据</p>
<h3 id="TCP的六个控制位"><a href="#TCP的六个控制位" class="headerlink" title="TCP的六个控制位"></a>TCP的六个控制位</h3><p>紧急位URG: URG=1时， 标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p>
<p>确认位ACK: ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p>
<p>推送位PSH: 就是接收端的URG，将PSH=1的数据尽快接收。注意一下，如果没有PSH，一般都是接收方缓存满了之后再将数据发送到主机</p>
<p>复位RST: RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p>
<p>同步位SYN： A和B主机要建立连接，就A先发一个报文，其中SYN=1；B收到之后也回复一个SYN=1的报文，代表接受连接；表明此报文段是一个连接请求/连接接受报文。</p>
<p>终止位FIN; FIN=1时， 表明此报文段发送方数据己发完，要求释放连接。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>SYN=1：(A)要建立连接了！<br>seq=x（随机）：因为还没有数据，所以写什么都无所谓第<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:二段的意思是<br>SYN=1：我(B)同意你(A)建立连接！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=y（随机）：因为还没有数据，所以写什么都无所谓<br>ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据第三<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:三段的意思是<br>SYN=0：SYN只有在建立连接时才为1，其他时候均设为0<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=x+1：我(A)发送的报文段的第一个字节就是x+1<br>ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据</p>
<p>注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630213814996.png" alt="img" style="zoom:80%;"></p>
<h4 id="TCP三次握手特定导致的SYN洪泛攻击"><a href="#TCP三次握手特定导致的SYN洪泛攻击" class="headerlink" title="TCP三次握手特定导致的SYN洪泛攻击"></a>TCP三次握手特定导致的SYN洪泛攻击</h4><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630214925395.png" alt="img" style="zoom:80%;">

<p><font color="red">SYN洪泛攻击，解决方式通过SYN cookie，//TODO</font></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第二段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第三段的意思是:FIN=1：(B)要释放连接了！<br>ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的<br>ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）<br><a href="%E6%B3%A8%E9%87%8A%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AE%B5%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF">comment</a>:第四段的意思是:ACK=1：连接建立了，之后的ACK必须都置为1<br>seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据<br>ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据<br><font color="red">为什么需要等待计时2MSL？</font><br>因为这样可以保证B可以收到A的终止报文段进而进入关闭状态<br>比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630215522825.png" alt="img" style="zoom:80%;">

<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><blockquote>
<p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
</blockquote>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p>CP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630220542461.png" alt="img" style="zoom:75%;">

<h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221424853.png" alt="img" style="zoom:80%;">

<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>发送方每一次发送数据之后都需要接收方进行确认。<br>TCP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中4、5、6丢失，7、8到达，但仍然请求发送的数据序号是4。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630221636424.png" alt="img" style="zoom:75%;">

<h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><p>为什么要使用自适应算法？网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs。</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630222205619.png" alt="img" style="zoom:75%;">

<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。<br>接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了<br>接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/202006302226272.png" alt="img" style="zoom:80%;"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。<br>但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象<br>解决方法：使用计时器<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630223616929.png" alt="img" style="zoom:75%;"></p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>流量控制是对单独一个来说的，拥塞控制是一群</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630224242515.png" alt="img" style="zoom:75%;">

<h3 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h3><p>这里虽然是四种算法，但是通常是两两结合进行使用</p>
<img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232411944.png" alt="img" style="zoom:75%;">

<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。<br>之后一段都是线性增长，每次增加1，直至达到网络拥塞状态<br>瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12）<br>重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630232910475.png" alt="img" style="zoom:75%;"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。<br>不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始<br><img src="/2021/09/01/%E6%B5%85%E8%B0%88TCP/20200630233701386.png" alt="img " style="zoom:75%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">PV操作--经典问题分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-31 19:43:52 / 修改時間：20:10:57" itemprop="dateCreated datePublished" datetime="2021-08-31T19:43:52+08:00">2021-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、多生产者-多消费者问题"><a href="#一、多生产者-多消费者问题" class="headerlink" title="一、多生产者 - 多消费者问题"></a>一、多生产者 - 多消费者问题</h1><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><blockquote>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610154557852.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a>2 问题分析</h2><ol>
<li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。<br>多生产者-多消费者问题关系分析如下：</p>
<blockquote>
<p>互斥关系： 对缓冲区（盘子）的访问要互斥地进行<br>同步关系（一前一后）：</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果</li>
</ol>
</blockquote>
</li>
</ol>
<p>注意：“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</p>
<ol start="2">
<li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p>
<blockquote>
<p>由以上的同步、互斥关系分析，将多生产者-多消费者问题描绘出图形：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155007683.png" alt="img" style="zoom:80%;"></blockquote>
</li>
<li><p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。<br>（互斥信号量初值一般为 1，同步信号量的初始值要看对应资源的初始值是多少）<br><strong>本问题中信号量设置如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">semaphore plate = 1;    //盘子中还可以放多少个水果</span><br></pre></td></tr></table></figure></li>
<li><p>模型实现：</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610155634180.png" alt="img" style="zoom:80%;"></li>
</ol>
<blockquote>
<p>dad：先准备一个苹果，放苹果之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将苹果放入进去（V一下苹果，数量+1）<br>mom：先准备一个橘子，放橘子之前，先判断盘子里是否为空（P一下盘子，检查盘子中还可以放多少个水果），然后再将橘子放入进去（V一下橘子，数量+1）<br>daughter：拿苹果之前，先判断盘子里有没有苹果（P一下苹果，若没有苹果，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）<br>son：拿橘子之前，先判断盘子里有没有橘子（P一下橘子，若没有橘子，自己被阻塞），然后告诉父母，盘子为空了（V一下盘子）</p>
</blockquote>
<blockquote>
<p><strong>以下实现了所有进程之间的同步关系：</strong></p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161040503.png" alt="img" style="zoom:80%;">

<p>还需要实现各个进程对盘子（缓冲区）的互斥访问：<br>就是所有进程对盘子进行PV操作，即加锁和解锁的过程</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20200610161420106.png" alt="img" style="zoom:80%;">
</blockquote>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> semaphore mutex = 1;    //实现互斥访问盘子（缓冲区）</span><br><span class="line">  semaphore apple = 0;    //盘子中有几个苹果 </span><br><span class="line">  semaphore orange = 0;   //盘子中有几个橘子</span><br><span class="line">  semaphore plate = 1;    //盘子中还可以放多少个水果</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dad</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个苹果;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(apple);       //允许女儿进程取苹果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">mom</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           准备一个橘子;</span><br><span class="line">           P(plate);</span><br><span class="line">           P(mutex);</span><br><span class="line">           向盘子中放橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(orange);        //允许儿子进程取橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">daughter</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(apple);</span><br><span class="line">           P(mutex);</span><br><span class="line">          从盘子中取出苹果;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">son</span></span> ()&#123;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">           P(orange);</span><br><span class="line">           P(mutex);</span><br><span class="line">           从盘子中取出橘子;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(plate);           //允许父母进程进程向盘子中取放水果</span><br><span class="line">           吃橘子;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、吸烟者问题"><a href="#二、吸烟者问题" class="headerlink" title="二、吸烟者问题"></a>二、吸烟者问题</h1><h2 id="1、问题描述-1"><a href="#1、问题描述-1" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉，但是要卷起并抽掉一支烟，需要三种材料：烟草、纸、胶水。三个抽烟者中，每一个第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者无限提供三种材料，供应者每次将两种材料放桌子上，拥有剩下材料的抽烟者卷一支烟并抽掉它，并给供应者一个信号完成了，供应者就会把另外两种材料再放桌子上，这个过程一直重复（三个抽烟者轮流抽烟）<br><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319181813857.png" alt="img" style="zoom:80%;"></p>
<h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><h3 id="1、关系分析。"><a href="#1、关系分析。" class="headerlink" title="1、关系分析。"></a>1、关系分析。</h3><p>供应者与三个抽烟者分别是同步关系。由于抽烟者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）</p>
<h3 id="2、整理思路。"><a href="#2、整理思路。" class="headerlink" title="2、整理思路。"></a>2、整理思路。</h3><p>四个进程，供应者作为生产者向三个抽烟者提供材料</p>
<h3 id="3、信号量设置"><a href="#3、信号量设置" class="headerlink" title="3、信号量设置"></a>3、信号量设置</h3><p>信号量offer1、offer2、offer3分别表示烟草和纸组合，烟草和胶水组合，胶水和纸组合。信号量finish表示抽烟完成信号</p>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183414832.png" alt="img" style="zoom:80%;">

<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319183610850.png" alt="img" style="zoom:80%;">

<h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190319185437858.png" alt="img" style="zoom:80%;">

<h1 id="二、读者-写者问题"><a href="#二、读者-写者问题" class="headerlink" title="二、读者-写者问题"></a>二、读者-写者问题</h1><h2 id="1、问题描述-2"><a href="#1、问题描述-2" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程 和其他进程（写进程或读进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者再完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320135112282.png" alt="img" style="zoom:80%;">

<h2 id="2、问题分析-1"><a href="#2、问题分析-1" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182746487.png" alt="img" style="zoom:80%;">

<h2 id="3、实现-1"><a href="#3、实现-1" class="headerlink" title="3、实现"></a>3、实现</h2><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182822669.png" alt="img" style="zoom:80%;">

<p>写优先：</p>
<p><img src="/2021/08/31/PV%E6%93%8D%E4%BD%9C-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/20190320182907776.png" alt="img"></p>
<h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由Dijkstra提出并解决的哲学家进餐问题（The Dinning Philosophers Problems）是典型的同步问题。五个哲学家共用一张圆桌，分别坐在周围的五把椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有当他拿到两只筷子时，才能进餐，进餐完毕，放下筷子，继续思考。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用记录型信号量解决哲学家进餐问题，经分析，筷子是邻接资源，在一段时间内只允许一位哲学家使用，可以用一个互斥型信号量表示一只筷子，由这个五个信号量构成信号量数组。<br>semaphore chopstick[5] = {1, 1, 1, 1, 1};<br>所有信号量初始为1，第i位哲学家的活动可描述为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line"> 	p(chopstick[i]);  // 申请左边的一只筷子</span><br><span class="line"> 	p(chopstick[(i+1)%5]];  // 申请右边筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	eat</span><br><span class="line"> 	...</span><br><span class="line"> 	v(chopstick[i]);  // 释放左边的一只筷子</span><br><span class="line"> 	v(chopstick[(i+1)%5];  // 释放右边的筷子</span><br><span class="line"> 	...</span><br><span class="line"> 	think</span><br><span class="line"> 	...</span><br><span class="line">&#125; <span class="keyword">while</span> (True);</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>问题</strong>：<br> 哲学家饥饿时总是先拿起左边的筷子，之后拿起右边的筷子，成功后便可进餐。进餐后又放下左边的筷子，再放下右边的筷子。显然不会有两个相邻的哲学家同时进餐，有可能引起<strong>死锁</strong>：即每一个哲学家都拿起左边的筷子，当他们拿右边筷子，便会无限等待。</font></p>
<p><strong>共有三种解决办法：</strong></p>
<h2 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h2><ul>
<li><p><strong>利用and型信号量机制</strong>：仅当哲学家左右两只筷子均可用时，才允许他拿起筷子进餐。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i], chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>另一种方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, mutex = 1; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(mutex);  // 申请临界资源</span><br><span class="line">	p(chopstick[i]);  // 拿左</span><br><span class="line">	p(chopstick[(i+1)%5]);  // 拿右</span><br><span class="line">	v(mutex);  // 释放临界资源</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>至多允许有<strong>四位哲学家</strong>同时去拿左边筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放他的两只筷子，从而使更多的哲学家能够进餐。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;, L = 4; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	p(L);</span><br><span class="line">	p(chopstick[i]);</span><br><span class="line">	p(chopstick[(i+1)%5]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(L);</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure></li>
<li><p>规定奇数号哲学家先拿起左边筷子，然后在去拿右边筷子，偶数号相反。按此规定，将是1,2号哲学家竞争1号筷子，3,4竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后才去竞争偶数号筷子，最后总有人获得两只筷子。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	think</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (i % 2 == 0):</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p(chopstick[(i+1)%5]);</span><br><span class="line">		p(chopstick[i]);</span><br><span class="line">	...</span><br><span class="line">	eat</span><br><span class="line">	...</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[(i+1)%5]);</span><br><span class="line">&#125; <span class="keyword">while</span>(True);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">布隆过滤器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-30 20:11:22 / 修改時間：20:43:30" itemprop="dateCreated datePublished" datetime="2021-08-30T20:11:22+08:00">2021-08-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="布隆过滤器的理解"><a href="#布隆过滤器的理解" class="headerlink" title="布隆过滤器的理解"></a>布隆过滤器的理解</h1><h2 id="场景分析："><a href="#场景分析：" class="headerlink" title="场景分析："></a>场景分析：</h2><p>黑名单问题：</p>
<p>需求大致为：100亿个url为黑名单，搜索公司想让用户搜索黑名单里的url时，不给用户显示。如果url输入这100亿黑名单则返回True，否则返回False。假设每个url64kb。</p>
<p>如果使用hashset实现该功能的话，需要6400亿字节（640G）的内存。浪费大量空间，不现实。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>算法：</p>
<blockquote>
<p>准备k个相互独立哈希函数，长度为n的比特数组，比特数组的每个比特位初始化为0。</p>
<p>存入流程：</p>
<ol>
<li>使用k个哈希函数，计算某个url的哈希值，使用哈希值对n取模。<strong>idx = hash(url)%n</strong></li>
<li>将相对的比特数组位置描黑。 比特数组【idx】 = 1</li>
</ol>
<p>while k个哈希函数：</p>
<p>​    idx = hash(url) % n</p>
<p>​    比特数组【idx】 = 1</p>
<p>查询流程：</p>
<p>使用k个哈希函数，计算哈希值，对n取模，如果所有位置都为1，则该url属于这100亿黑名单。</p>
</blockquote>
<p>重要公式：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317223869.png" alt="img " style="zoom:150%;">

<p>p为预计的失误率。n为样本个数。m为最优比特位个数。</p>
<p> Hash 函数个数选取最优数目：</p>
<img src="/2021/08/30/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/2012071317394641.png" alt="img" style="zoom:150%;">

<p>m为比特位个数，n为样本个数，k为哈希函数个数</p>
<p>在确定m和k后计算失误率：</p>
<center>p = (1-e<sup>(-kn/m)</sup>)<sup>k</sup>​</center>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
