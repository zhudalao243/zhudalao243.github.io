<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhudalao243.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"b2t":false,"scrollpercent":true},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://zhudalao243.github.io/page/3/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="zzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zhudalao243.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-TW","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>上善若水</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">上善若水</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">成为一个有智慧的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zzy"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">zzy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">逃逸分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 23:22:17 / 修改時間：23:32:04" itemprop="dateCreated datePublished" datetime="2021-08-24T23:22:17+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。</p>
<p>函数中申请一个新的对象：</p>
<blockquote>
<ul>
<li>如果分配在栈中，则函数执行结束可自动将内存回收；</li>
<li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；</li>
</ul>
</blockquote>
<p>有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。</p>
<h2 id="逃逸策略"><a href="#逃逸策略" class="headerlink" title="逃逸策略"></a>逃逸策略</h2><p>每当函数中申请新的对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：</p>
<ol>
<li>如果函数外部没有引用，则优先放到栈中；</li>
<li>如果函数外部存在引用，则必定放到堆中；</li>
</ol>
<p>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</p>
<h2 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h2><h3 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h3><p>道Go可以返回局部变量指针，这是一个典型的变量逃逸案例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StudentRegister</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Student</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Student) <span class="comment">//局部变量s逃逸到堆</span></span><br><span class="line">    s.Name = name</span><br><span class="line">    s.Age = age</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    StudentRegister(<span class="string">&quot;Jim&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数StudentRegister()内部s为局部变量，其值通过函数返回值返回，s本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>通过编译参数-gcflag=-m可以查看编译过程中的逃逸分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: can inline StudentRegister</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: can inline main</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">18</span>: inlining call to StudentRegister</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: leaking param: name</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">9</span>: <span class="built_in">new</span>(Student) escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">18</span>: main <span class="built_in">new</span>(Student) does not escape</span><br></pre></td></tr></table></figure>

<p>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="栈空间不足逃逸"><a href="#栈空间不足逃逸" class="headerlink" title="栈空间不足逃逸"></a>栈空间不足逃逸</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> index, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[index] = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Slice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。<br>直接查看编译提示，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>: Slice <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>) does not escape</span><br></pre></td></tr></table></figure>

<p>我们发现此处并没有发生逃逸。那么把切片长度扩大10倍即10000会如何呢?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>: <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>

<p>发现当切片长度扩大到10000时就会逃逸。</p>
<p>实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="动态类型逃逸"><a href="#动态类型逃逸" class="headerlink" title="动态类型逃逸"></a>动态类型逃逸</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也会产生逃逸。<br>如下代码所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Escape&quot;</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码s变量只是一个string类型变量，调用fmt.Println()时会产生逃逸：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: s escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: main ... argument does not escape</span><br></pre></td></tr></table></figure>

<h3 id="闭包引用对象逃逸"><a href="#闭包引用对象逃逸" class="headerlink" title="闭包引用对象逃逸"></a>闭包引用对象逃逸</h3><p>某著名的开源框架实现了某个返回Fibonacci数列的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数返回一个闭包，闭包引用了函数的局部变量a和b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出Fibonacci数列。<br>完整的示例程序如下所示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Fibonacci: %d\n&quot;</span>, f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\SourceCode\GoExpert\src&gt;<span class="keyword">go</span> build -gcflags=-m</span><br><span class="line"># _/D_/SourceCode/GoExpert/src</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: can inline Fibonacci.func1</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: &amp;a escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>: moved to heap: a</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>: &amp;b escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>: moved to heap: b</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: f() escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">17</span>: main ... argument does not escape</span><br></pre></td></tr></table></figure>

<h2 id="逃逸总结"><a href="#逃逸总结" class="headerlink" title="逃逸总结"></a>逃逸总结</h2><blockquote>
<ul>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
</blockquote>
<h2 id="函数传递指针真的比传值效率高吗？"><a href="#函数传递指针真的比传值效率高吗？" class="headerlink" title="函数传递指针真的比传值效率高吗？"></a>函数传递指针真的比传值效率高吗？</h2><blockquote>
<p>指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">Golang协程调度器原理与GMP设计思想</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 20:22:00 / 修改時間：21:51:29" itemprop="dateCreated datePublished" datetime="2021-08-24T20:22:00+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-Golang“调度器器”由来"><a href="#一-Golang“调度器器”由来" class="headerlink" title="一. Golang“调度器器”由来"></a>一. Golang“调度器器”由来</h1><p>多进程、多线程的问题？</p>
<blockquote>
<p>设计变得复杂，进程/线程的数量越多，切换成本就越大，也就越浪费</p>
<p>多进程、多线程的壁垒,高内存占用，进程占用内存（虚拟内存4GB（32bit OS）），线程占用约4MB</p>
</blockquote>
<h2 id="线程池的缺陷"><a href="#线程池的缺陷" class="headerlink" title="线程池的缺陷"></a>线程池的缺陷</h2><p>​        在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断地从任务队列中取出任务并执行，可以有效的减少线程创建和销毁所带来的开销。</p>
<p><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/m_b499f154d0135854b725ce27a6b7a009_r.png" alt="img"></p>
<p>我们把任务队列中的每一个任务称作G，而G往往代表一个函数。线程池中的worker线程不断地从任务队列中取出任务并执行。而worker线程的调度则交给操作系统进行调度。</p>
<p>如果worker线程执行的G任务中发生系统调用，则操作系统会将该线程置为阻塞状态，也意味着该线程在怠工，也意味着消费任务队列的worker线程变少了，也就是说线程池消费任务队列的能力变弱了。</p>
<p>如果任务队列中的大部分任务都会进行系统调用，则会让这种状态恶化，大部分worker线程进入阻塞状态，从而任务队列中的任务产生堆积。</p>
<p>解决这个问题的一个思路就是重新审视线程池中线程的数量，增加线程池中线程数量可以一定程度上提高消费能力，但随着线程数量增多，由于过多线程争抢CPU，消费能力会有上限，甚至出现消费能力下降。 </p>
<p>调度器器的优化:</p>
<blockquote>
<p>Goroutine的优化: 内存仅占用几KB，可以大量开辟。灵活调用，切换成本低。</p>
</blockquote>
<p>早期的Go的调度器器：</p>
<blockquote>
<p>基本的全局Go队列列和⽐比较传统的轮询利利⽤用多个thread去调度。</p>
<p>弊端：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了了激烈烈的锁竞争。</li>
<li> M转移G会造成延迟和额外的系统负载。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了了系统开销。    </li>
</ol>
</blockquote>
<h1 id="GMP模型的设计思想"><a href="#GMP模型的设计思想" class="headerlink" title="GMP模型的设计思想"></a>GMP模型的设计思想</h1><h2 id="Goroutine主要概念如下："><a href="#Goroutine主要概念如下：" class="headerlink" title="Goroutine主要概念如下："></a>Goroutine主要概念如下：</h2><ul>
<li><p>G（Goroutine）: 即Go协程，每个go关键字都会创建一个协程。</p>
</li>
<li><p>M（Machine）： 工作线程，在Go中称为Machine。</p>
</li>
<li><p>P(Processor): 处理器（Go中定义的一个摡念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。</p>
</li>
</ul>
<img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824210046445.png" alt="image-20210824210046445 " style="zoom:67%;">

<p>M是交给操作系统调度的线程，M持有一个P，P将G调度进M中执行。P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将G调度到M中执行。</p>
<p>P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。</p>
<p>程序中可以使用<code>runtime.GOMAXPROCS()</code>设置P的个数，在某些IO密集型的场景下可以在一定程度上提高性能。</p>
<blockquote>
<p>全局队列:  存放等待运⾏行行的G</p>
<p>P的本地队列: 存放等待运行的G, 数量限制 (不超过256G),优先将新创建的G放在P的本地队列中，如果满了会放在全局队列中。</p>
<p>P列表：程序启动时创建， 最多有GOMAXPROCS个(可配置)</p>
<p>M列表： 当前操作系统分配到当前Go程序的内核线程数。</p>
<p>P的数量：</p>
<ul>
<li>环境变量量$GOMAXPROCS</li>
<li>在程序中通过runtime.GOMAXPROCS() 来设置</li>
</ul>
<p>M的数量：</p>
<ul>
<li>Go语⾔言本身 是限定M的最⼤大量量是10000(忽略略)</li>
<li>runtime/debug包中的SetMaxThreads函数来设置</li>
<li>有一个M阻塞，会创建一个新的M</li>
<li>如果有M空闲，那么就会回收或者睡眠</li>
</ul>
</blockquote>
<h2 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h2><ol>
<li><p>复用线程 避免频繁的创建、销毁线程，而是对线程的复用。</p>
<ul>
<li><p>work stealing机制</p>
<p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p>
</li>
<li><p>hand off机制</p>
<p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p>
</li>
</ul>
</li>
<li><p>利用并行 </p>
<p>GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。</p>
</li>
<li><p>抢占</p>
<p>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死.</p>
</li>
<li><p>全局G队列列 </p>
<p>当M执行work stealing从其他P偷不到G时，它可以从全局G队列列获取G。</p>
</li>
</ol>
<p>每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</p>
<p>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性地查看全局队列中是否有G待运行并将其调度到M中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</p>
<h2 id="“go-func-”-经历了了什什么过程"><a href="#“go-func-”-经历了了什什么过程" class="headerlink" title="“go func()” 经历了了什什么过程"></a>“go func()” 经历了了什什么过程</h2><p>流程：</p>
<blockquote>
<ol>
<li>我们通过 go func()来创建⼀一个goroutine</li>
<li>有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</li>
<li>G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</li>
<li>一个M调度G执行的过程是一个循环机制；</li>
<li>当M执行某一个G时候如果发生了syscall或其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P</li>
<li>当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列列中。</li>
</ol>
</blockquote>
<p>调度器器的生命周期?</p>
<blockquote>
<p>M0</p>
<p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p>G0</p>
<p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数,每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
</blockquote>
<h1 id="GOMAXPROCS设置对性能的影响"><a href="#GOMAXPROCS设置对性能的影响" class="headerlink" title="GOMAXPROCS设置对性能的影响"></a>GOMAXPROCS设置对性能的影响</h1><p>一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。<br>在某些IO密集型的应用里，这个值可能并不意味着性能最好。<br>理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。<br>但由于Go调度器检测到M被阻塞是有一定延迟的，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，或许会有好的效果。</p>
<h1 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212038512.png" alt="image-20210824212038512" style="zoom:67%;">

<blockquote>
<p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。</p>
</blockquote>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212307079.png" alt="image-20210824212307079" style="zoom:67%;">

<blockquote>
<p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了了线程M1的复用。</p>
</blockquote>
<h2 id="场景3、4、5"><a href="#场景3、4、5" class="headerlink" title="场景3、4、5"></a>场景3、4、5</h2><center><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212818637.png" alt="image-20210824212818637" style="zoom:50%;"><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212858320.png" alt="image-20210824212858320" style="zoom:50%;"><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824212951443.png" alt="image-20210824212951443" style="zoom:50%;"></center>

<h2 id="场景六"><a href="#场景六" class="headerlink" title="场景六"></a>场景六</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824213232136.png" alt="image-20210824213232136" style="zoom:67%;">

<blockquote>
<p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为<strong>自旋线程</strong>（没有G但为运行<br>状态的线程，不断寻找G）。</p>
</blockquote>
<h2 id="场景七"><a href="#场景七" class="headerlink" title="场景七"></a>场景七</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824213556496.png" alt="image-20210824213556496" style="zoom:67%;">

<blockquote>
<p>M2自旋线程，首先尝试从全局队列获取G。M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量量符合下面的公式：</p>
<p>​                            <strong>n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</strong></p>
</blockquote>
<h2 id="场景八"><a href="#场景八" class="headerlink" title="场景八"></a>场景八</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214007571.png" alt="image-20210824214007571" style="zoom:50%;">

<blockquote>
<p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
</blockquote>
<h2 id="场景九"><a href="#场景九" class="headerlink" title="场景九"></a>场景九</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214402203.png" alt="image-20210824214402203" style="zoom:50%;">

<blockquote>
<p>最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS=4，所以一共4个P)，多余的没事做线程会让他们休眠。</p>
</blockquote>
<h2 id="场景十"><a href="#场景十" class="headerlink" title="场景十"></a>场景十</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824214727895.png" alt="image-20210824214727895" style="zoom:67%;">

<blockquote>
<p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;=P, 大部分都是M在抢占需要运行的P)，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p>
</blockquote>
<h2 id="场景十一"><a href="#场景十一" class="headerlink" title="场景十一"></a>场景十一</h2><img src="/2021/08/24/Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8EGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/image-20210824215013595.png" alt="image-20210824215013595" style="zoom:50%;">

<blockquote>
<p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/SSL-TLS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/SSL-TLS/" class="post-title-link" itemprop="url">SSL/TLS and HTTPS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 17:20:09 / 修改時間：17:48:38" itemprop="dateCreated datePublished" datetime="2021-08-24T17:20:09+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p><img src="/2021/08/24/SSL-TLS/1539271432019.png" alt="1539271432019"></p>
<blockquote>
<ul>
<li><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。<br>SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li>
<li><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc5246">RFC</a> 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li>
</ul>
<p>SSL/TLS协议提供的服务主要有：</p>
<ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ol>
</blockquote>
<p><img src="/2021/08/24/SSL-TLS/image-20210824173412361.png" alt="image-20210824173412361"></p>
<blockquote>
<p>客户端与服务端需要经过一个握手的过程才能完成身份认证，建立一个安全的连接。握手的过程如下：</p>
<ol>
<li><p>客户端访问服务器（比如：<a target="_blank" rel="noopener" href="https://www.12306.cn/">https://www.12306.cn</a>）,发送ssl版本、客户端支持的加密算法等消息。</p>
</li>
<li><p>服务器向客户端发送ssl版本、加密算法、证书（证书出现了）等消息。</p>
</li>
<li><p>客户端收到消息后，判断证书是否可信, 若可信，则继续通信，发送消息：</p>
<p><font color="red">客户端生成一个随机数，从证书中获取服务器端的公钥，对随机数加密；</font></p>
<p>随后信息都将使用双方协定的加密方法和密钥发送, 客户端握手结束。</p>
</li>
<li><p>服务器端对数据解密得到随机数, 使用协商好的加密算法和秘钥进行通信</p>
</li>
</ol>
</blockquote>
<p>描述的是客户端和服务器刚建立连接之后做的事情:</p>
<blockquote>
<p>第一次</p>
<ul>
<li>客户端连接服务器<ul>
<li>客户端使用的ssl版本, 客户端支持的加密算法</li>
</ul>
</li>
<li>服务器<ul>
<li>先将自己支持ssl版本和客户端的支持的版本比较<ul>
<li>支持的不一样, 连接断开</li>
<li>支持的一样, 继续</li>
</ul>
</li>
<li>根据得到的客户端支持 的加密算法, 找一个服务器端也同样支持算法, 发送给客户端</li>
<li>需要发送服务器的证书给客户端</li>
</ul>
</li>
</ul>
<p>第二次:</p>
<p>客户端:</p>
<ul>
<li>接收服务器的证书</li>
<li>校验证书的信息<ul>
<li>校验证书的签发机构</li>
<li>证书的有效期</li>
<li>证书中支持 的域名和访问的域名是否一致</li>
</ul>
</li>
<li>校验有问题, 浏览器会给提示</li>
</ul>
</blockquote>
<h2 id="https-gt-单向认证"><a href="#https-gt-单向认证" class="headerlink" title="https -&gt; 单向认证"></a>https -&gt; 单向认证</h2><p><img src="/SSL-TLS/https1.png" alt="https1"></p>
<ol>
<li>服务器要准备的<ul>
<li>生成密钥对</li>
<li>将公钥发送给ca, 由ca签发证书</li>
<li>将ca签发的证书和非对称加密的私钥部署到当前的web服务器</li>
</ul>
</li>
<li>通信流程<ol>
<li>客户端连接服务器, 通过一个域名<ul>
<li>域名和IP地址的关系<ul>
<li>域名要绑定IP地址<ul>
<li>一个域名只能绑定一个IP地址</li>
</ul>
</li>
<li>IP地址需要被域名绑定<ul>
<li>一个IP地址可以被多个域名绑定</li>
</ul>
</li>
</ul>
</li>
<li>客户端访问的域名会解析成IP地址, 通过IP地址访问web服务器</li>
</ul>
</li>
<li>服务器收到了客户端的请求<ul>
<li>服务器将CA签发的证书发送给浏览器(客户端)</li>
</ul>
</li>
<li>客户端拿到了服务器的公钥证书<ul>
<li>读这个公钥 证书<ul>
<li>验证域名</li>
<li>有效期</li>
<li>ca签发机构</li>
<li>服务器的公钥</li>
</ul>
</li>
</ul>
</li>
<li>客户会生成一个随机数 (作为对称加密的秘钥来使用的)<ul>
<li>使用服务器的公钥对这个随机数进行加密</li>
<li>将这个加密之后 秘钥发送给服务器</li>
</ul>
</li>
<li>服务器对收到的密文解密<ul>
<li>使用服务器的是要解密, 得到对称加密的秘钥</li>
</ul>
</li>
<li>数据的传输<ul>
<li>使用对称加密的方式对数据进行加密</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/%E8%AF%81%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/%E8%AF%81%E4%B9%A6/" class="post-title-link" itemprop="url">证书</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 16:42:45 / 修改時間：17:19:26" itemprop="dateCreated datePublished" datetime="2021-08-24T16:42:45+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><blockquote>
<p>公钥证书（Public-Key Certificate，PKC)其实和驾照很相似，里面记有姓名、组织、邮箱地址等<font color="red">个人信息</font>，以及属于<font color="red">此人的公钥, 并由认证机构（Certification Authority、Certifying Authority, CA）施加数字签名</font>。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate）。</p>
</blockquote>
<h2 id="证书的应用场景"><a href="#证书的应用场景" class="headerlink" title="证书的应用场景"></a>证书的应用场景</h2><img src="/2021/08/24/%E8%AF%81%E4%B9%A6/1539265302304.png" alt="1539265302304" style="zoom:130%;">

<blockquote>
<ol>
<li><p><font color="red" size="4">Bob生成密钥对</font></p>
<ul>
<li><p>可以将bob看成百度, 提供是web服务器</p>
</li>
<li><p>生成一个密钥对</p>
<ul>
<li>公钥  -&gt; 分发</li>
<li>私钥 -&gt; 百度留着</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Bob在认证机构Trent注册自己的公钥</font></p>
<ul>
<li>百度找了一大家都信赖的机构, 来证明这个公钥是百度的</li>
<li>认证机构会生成一个证书, 写明了公钥属于百度<ul>
<li>认证机构也有一个非对称加密的密钥对</li>
<li>认证机构使用自己的私钥对百度的公钥进行签名, 生成了证书</li>
<li>认证机构将证书发送给百度</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书</font></p>
</li>
<li><p><font color="red" size="4">Alice得到带有认证机构Trent的数字签名的Bob的公钥（证书）</font></p>
<ul>
<li>alice可以看做一个客户 -&gt; 浏览器</li>
<li>客户端访问的百度 -&gt; 得到了百度的证书<ul>
<li>证书中有百度的公钥</li>
</ul>
</li>
<li>客户端需要使用认证机构的公钥对证书进行验证<ul>
<li>客户端怎么会有认证机构的公钥<ul>
<li>window会预装, 或者用户自己安装</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性</font></p>
<ul>
<li>使用认证机构的公钥解除百度证书中签名的数据<ul>
<li>百度的公钥</li>
<li>百度的域名</li>
<li>百度证书的有效期</li>
</ul>
</li>
</ul>
</li>
<li><p><font color="red" size="4">Alice用Bob的公钥加密消息并发送给Bob</font></p>
<ul>
<li>非对称加密</li>
<li>使用公钥加密 -&gt; 对称加密秘钥分发</li>
</ul>
</li>
<li><p><font color="red" size="4">Bob用自己的私钥解密密文得到Alice的消息</font></p>
<ul>
<li>服务器使用私钥解密 -&gt; 得到对称加密的秘钥</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="证书规范和格式-–-x509-了解"><a href="#证书规范和格式-–-x509-了解" class="headerlink" title="证书规范和格式 – x509(了解)"></a>证书规范和格式 – x509(了解)</h2><blockquote>
<p><strong>X.509</strong>是一种非常通用的证书格式。所有的证书都符合ITU-T X.509国际标准，因此(理论上)为一种应用创建的证书可以用于任何其他符合X.509标准的应用。X.509证书的结构是用ASN1(Abstract Syntax Notation One)进行描述数据结构，并使用ASN.1语法进行编码。 </p>
<p>X.509规范中一般推荐使用PEM(Privacy Enhanced Mail）格式来存储证书相关的文件。</p>
<ul>
<li>证书文件的文件名后缀一般为 .crt 或 .cer </li>
<li>对应私钥文件的文件名后缀一般为 .key</li>
<li>证书请求文件的文件名后綴为 .csr </li>
<li>有时候也统一用pem作为文件名后缀。</li>
</ul>
</blockquote>
<h2 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h2><blockquote>
<p>CA证书顾名思义就是由CA（Certification Authority）机构发布的数字证书。要对CA证书完全理解及其作用，首先要理解SSL。SSL（security sockets layer，安全套接层）是为网络通信提供安全及数据完整性的一种安全协议。<strong>SSL3.0版本以后又被称为TLS。SSL位于TCP与各应用层之间，是操作系统向外提供的API。</strong>SSL如何保证网络通信的安全和数据的完整性呢？就是采用了两种手段：身份认证和数据加密。首先身份认证就需要用到CA证书了。</p>
</blockquote>
<ol>
<li><p>证书的获取和身份的认证（重点）</p>
<blockquote>
<p>客户端与服务端需要经过一个握手的过程才能完成身份认证，建立一个安全的连接。握手的过程如下：</p>
<ol>
<li><p>客户端访问服务器（比如：<a target="_blank" rel="noopener" href="https://www.12306.cn/">https://www.12306.cn</a>）,发送ssl版本、客户端支持的加密算法等消息。</p>
</li>
<li><p>服务器向客户端发送ssl版本、加密算法、证书（证书出现了）等消息。</p>
</li>
<li><p>客户端收到消息后，判断证书是否可信, 若可信，则继续通信，发送消息：</p>
<p><font color="red">客户端生成一个随机数，从证书中获取服务器端的公钥，对随机数加密；</font></p>
<p>随后信息都将使用双方协定的加密方法和密钥发送, 客户端握手结束。</p>
</li>
<li><p>服务器端对数据解密得到随机数, 使用协商好的加密算法和秘钥进行通信</p>
</li>
</ol>
</blockquote>
</li>
<li><p>客户端如何验证CA证书是可信任的?（了解）</p>
<blockquote>
<ol>
<li><p>查看证书的方式:</p>
<p>Internet选项 -&gt; 内容 -&gt; 证书, 打开证书窗口查看已经安装的证书</p>
<p>只要电脑上安装了该证书, 就说明该证书是受信任的。使用https协议访问时，服务器发送证书向浏览器时，首先查找该证书是否已在信任列表中，然后对证书进行校验，校验成功，那么就证明证书是可信的。</p>
<p>下图中<code>受信任的根证书颁发机构</code>下的证书都是根证书。</p>
<p>证书验证的机制是只要根证书是受信任的，那么它的子证书都是可信的。比如说，我们使用https协议访问了需要百度证书的网站，即使我们不安装百度证书，那么网站也不会提示证书不安全，因为，生成百度证书的根证书<code>Globalsign Root CA - R1</code>证书，在受信任的证书列表中。如果一个证书的根证书是不可信的，那么这个证书肯定也是不可信任的。</p>
<p>由以上可知，根证书在证书验证中极其重要，而且，根证书是无条件信任的，只要我们将根证书安装上，就说明我们对根证书是信任的。比如我们安装12306的根证书，是出于我们对国家的信任，对网站的信任，我们才放心安装这个根证书。对于一些不安全的网站的证书，一定要慎重安装。</p>
<p>另外需要知道的是，【<code>受信任的根证书颁发机构</code>】中的证书是windows预先安装的一些证书，都是国际上很有权威的证书机构，他们证书的生成都有很严格的流程，因此他们的证书被认为是安全，就像我们相信银行是安全，所以把钱存入到银行</p>
<p><img src="/2021/08/24/%E8%AF%81%E4%B9%A6/1539272408707.png" alt="1539272408707"></p>
</li>
<li><p>证书的颁发机构 -&gt; CA</p>
<ul>
<li>发布根证书</li>
<li>中间证书</li>
<li>个人</li>
</ul>
</li>
<li><p>证书的信任链 -&gt; 证书签发机构的信任链</p>
<p>A是一个可信赖证书签发机构, A信任B, B就有资格去签发证书</p>
<p>从等级上A比B高一级</p>
</li>
</ol>
</blockquote>
</li>
<li><p>有哪些CA机构?</p>
</li>
</ol>
<blockquote>
<p>世界上较早的数字认证中心是美国的verisign<code>威瑞信</code>公司，在windows的证书窗口中可以看到好多verisign公司生成的证书, 美国的<em>DigiCert</em></p>
<p>另外还有加拿大的ENTRUST公司，也是很著名的证书机构。</p>
<p>中国的安全认证体系分为金融CA和非金融CA。</p>
<ul>
<li>在金融CA方面，根证书由中国人民银行管理，</li>
<li>非金融CA方面，由中国电信负责。<ul>
<li>行业性CA<ul>
<li>中国金融认证中心</li>
<li>中国电信认证中心</li>
</ul>
</li>
<li>区域性CA, 区域性CA主要是以政府为背景，以企业机制运行<ul>
<li>广东CA中心</li>
<li>上海CA中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>沃通 – <a target="_blank" rel="noopener" href="http://www.wosign.com/products/ssl.htm">www.wosign.com/products/ssl.htm</a></p>
</blockquote>
<h2 id="公钥基础设施-PKI（了解）"><a href="#公钥基础设施-PKI（了解）" class="headerlink" title="公钥基础设施 - PKI（了解）"></a>公钥基础设施 - PKI（了解）</h2><p>PKI组成的要素</p>
<ul>
<li>用户<ul>
<li>申请证书的人 -&gt; web服务器端<ul>
<li>申请证书<ul>
<li>生成密钥对 , 或者委托ca生成</li>
<li>将公钥发送给CA</li>
<li>ca使用自己的私钥对得到公钥签名</li>
<li>将证书发送给用户</li>
</ul>
</li>
<li>发送证书<ul>
<li>当客户端访问服务器的时候发送证书给客户端</li>
</ul>
</li>
<li>注销证书<ul>
<li>当发现私钥泄露之后</li>
</ul>
</li>
</ul>
</li>
<li>使用证书的人 -&gt; 客户端<ul>
<li>接收证书</li>
<li>验证对方的身份信息</li>
</ul>
</li>
</ul>
</li>
<li>CA认证机构<ul>
<li>可以生产密钥对(可选)</li>
<li>对公钥签名</li>
<li>吊销证书</li>
</ul>
</li>
<li>仓库<ul>
<li>存储证书 -&gt; 公钥</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="post-title-link" itemprop="url">数字签名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 16:00:55 / 修改時間：16:30:57" itemprop="dateCreated datePublished" datetime="2021-08-24T16:00:55+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><h2 id="签名的生成和验证"><a href="#签名的生成和验证" class="headerlink" title="签名的生成和验证"></a>签名的生成和验证</h2><blockquote>
<ol>
<li><p>签名</p>
<ul>
<li>有原始数据对其进行哈希运算   -&gt;   散列值</li>
<li>使用非对称加密的<font color="red">私钥</font>对散列值加密 -&gt; 签名</li>
<li>将原始数据和签名一并发送给对方</li>
</ul>
</li>
<li><p>验证</p>
<ul>
<li><p>接收数据 </p>
<ul>
<li>原始数据</li>
<li>数字签名</li>
</ul>
</li>
<li><p>数字签名, 需要使用<font color="red">公钥</font>解密, 得到散列值</p>
</li>
<li><p>对原始数据进行哈希运算得到新的散列值</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>小结：</p>
<blockquote>
<ol>
<li>数据通信<ul>
<li>公钥加密, 私钥解密</li>
</ul>
</li>
<li>数字签名:<ul>
<li>私钥加密, 公钥解密</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="数字签名的方法"><a href="#数字签名的方法" class="headerlink" title="数字签名的方法"></a>数字签名的方法</h2><p><img src="/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1539177860475.png" alt="1539177860475"></p>
<h2 id="使用RSA进行数字签名"><a href="#使用RSA进行数字签名" class="headerlink" title="使用RSA进行数字签名"></a>使用RSA进行数字签名</h2><ol>
<li>使用rsa生成密钥对</li>
</ol>
<blockquote>
<ol>
<li>生成密钥对</li>
<li>序列化</li>
<li>保存到磁盘文件</li>
</ol>
</blockquote>
<ol start="2">
<li>使用私钥进行数字签名</li>
</ol>
<blockquote>
<ol>
<li>打开磁盘的私钥文件</li>
<li>将私钥文件中的内容读出</li>
<li>使用pem对数据解码, 得到了pem.Block结构体变量</li>
<li>x509将数据解析成私钥结构体 -&gt; 得到了私钥</li>
<li>创建一个哈希对象 -&gt; md5/sha1</li>
<li>给哈希对象添加数据</li>
<li>计算哈希值</li>
<li>使用rsa中的函数对散列值签名</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>)</span> <span class="params">(s []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">参数<span class="number">1</span>: rand.Reader</span><br><span class="line">参数<span class="number">2</span>: 非对称加密的私钥</span><br><span class="line">参数<span class="number">3</span>: 使用的哈希算法</span><br><span class="line">	crypto.sha1</span><br><span class="line">	crypto.md5</span><br><span class="line">参数<span class="number">4</span>: 数据计算之后得到的散列值</span><br><span class="line">返回值: </span><br><span class="line">- s: 得到的签名数据</span><br><span class="line">- err: 错误信息</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>使用公钥进行签名认证</li>
</ol>
<blockquote>
<ol>
<li><p>打开公钥文件, 将文件内容读出 - []byte</p>
</li>
<li><p>使用pem解码 -&gt; 得到pem.Block结构体变量</p>
</li>
<li><p>使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口</p>
</li>
<li><p>进行类型断言 -&gt; 得到了公钥结构体</p>
</li>
<li><p>对原始消息进行哈希运算(和签名使用的哈希算法一致) -&gt; 散列值</p>
<ol>
<li>创建哈希接口</li>
<li>添加数据</li>
<li>哈希运算</li>
</ol>
</li>
<li><p>签名认证 - rsa中的函数</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyPKCS1v15</span><span class="params">(pub *PublicKey, hash crypto.Hash, hashed []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span></span></span><br><span class="line">参数<span class="number">1</span>: 公钥</span><br><span class="line">参数<span class="number">2</span>: 哈希算法 -&gt; 与签名使用的哈希算法一致</span><br><span class="line">参数<span class="number">3</span>: 将原始数据进行哈希原始得到的散列值</span><br><span class="line">参数<span class="number">4</span>: 签名的字符串</span><br><span class="line">返回值: </span><br><span class="line">	- <span class="literal">nil</span> -&gt; 验证成功</span><br><span class="line">	- !=<span class="literal">nil</span> -&gt; 失败</span><br></pre></td></tr></table></figure>
</blockquote>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，这样一来消息认证码就无法发挥作用了。&quot;</span>)</span><br><span class="line">	sigText := SignatureRSA(src, <span class="string">&quot;private.pem&quot;</span>)</span><br><span class="line">	bl := VerifyRSA(src, sigText, <span class="string">&quot;public.pem&quot;</span>)</span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA签名 - 私钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignatureRSA</span><span class="params">(plainText []<span class="keyword">byte</span>, fileName <span class="keyword">string</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 打开磁盘的私钥文件</span></span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 将私钥文件中的内容读出</span></span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//3. 使用pem对数据解码, 得到了pem.Block结构体变量</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//4. x509将数据解析成私钥结构体 -&gt; 得到了私钥</span></span><br><span class="line">	privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5. 创建一个哈希对象 -&gt; md5/sha1 -&gt; sha512</span></span><br><span class="line">	<span class="comment">// sha512.Sum512()</span></span><br><span class="line">	myhash := sha512.New()</span><br><span class="line">	<span class="comment">//6. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">//7. 计算哈希值</span></span><br><span class="line">	hashText := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">//8. 使用rsa中的函数对散列值签名</span></span><br><span class="line">	sigText, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA512, hashText)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sigText</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RSA签名验证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyRSA</span><span class="params">(plainText, sigText []<span class="keyword">byte</span>, pubFileName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 打开公钥文件, 将文件内容读出 - []byte</span></span><br><span class="line">	file, err := os.Open(pubFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. 使用pem解码 -&gt; 得到pem.Block结构体变量</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 进行类型断言 -&gt; 得到了公钥结构体</span></span><br><span class="line">	publicKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line">	<span class="comment">//5. 对原始消息进行哈希运算(和签名使用的哈希算法一致) -&gt; 散列值</span></span><br><span class="line">	hashText := sha512.Sum512(plainText)</span><br><span class="line">	<span class="comment">//6. 签名认证 - rsa中的函数</span></span><br><span class="line">	err = rsa.VerifyPKCS1v15(publicKey, crypto.SHA512, hashText[:], sigText)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用椭圆曲线进行数字签名"><a href="#使用椭圆曲线进行数字签名" class="headerlink" title="使用椭圆曲线进行数字签名"></a>使用椭圆曲线进行数字签名</h2><blockquote>
<p>椭圆曲线在go中对应的包: import “crypto/elliptic”</p>
<p>使用椭圆曲线在go中进行数字签名: import “crypto/ecdsa”</p>
<p>美国FIPS186-2标准, 推荐使用5个素域上的椭圆曲线, 这5个素数模分别是:</p>
<p>P<del>192</del> = 2^192^ - 2^64^ - 1</p>
<p>P<del>224</del> = 2^224^ - 2^96^ + 1</p>
<p>P<del>256</del> = 2^256^ - 2^224^  + 2^192^ - 2^96^ -1</p>
<p>P<del>384</del> = 2^384^ - 2^128^  - 2^96^ + 2^32^ -1</p>
<p>P<del>512</del> = 2^512^ - 1</p>
</blockquote>
<ol>
<li>秘钥对称的生成, 并保存到磁盘</li>
</ol>
<blockquote>
<ol>
<li><p>使用ecdsa生成密钥对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(c elliptic.Curve, rand io.Reader)</span> <span class="params">(priv *PrivateKey, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>将私钥写入磁盘</p>
<ul>
<li>使用x509进行序列化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalECPrivateKey</span><span class="params">(key *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将得到的切片字符串放入pem.Block结构体中</p>
<p>block := pem.Block{</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type : <span class="string">&quot;描述....&quot;</span>,</span><br><span class="line"></span><br><span class="line">Bytes : MarshalECPrivateKey返回值中的切片字符串,</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
<li><p>使用pem编码</p>
<p>​    pem.Encode();</p>
</li>
</ul>
</li>
<li><p>将公钥写入磁盘</p>
<ul>
<li>从私钥中得到公钥</li>
<li>使用x509进行序列化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKIXPublicKey</span><span class="params">(pub <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将得到的切片字符串放入pem.Block结构体中</li>
</ul>
<p>block := pem.Block{</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type : <span class="string">&quot;描述....&quot;</span>,</span><br><span class="line"></span><br><span class="line">Bytes : MarshalECPrivateKey返回值中的切片字符串,</span><br></pre></td></tr></table></figure>

<p>}</p>
<ul>
<li><p>使用pem编码</p>
<p>pem.Encode();</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<ol start="2">
<li>使用私钥进行数字签名</li>
</ol>
<blockquote>
<ol>
<li><p>打开私钥文件, 将内容读出来 -&gt;[]byte</p>
</li>
<li><p>使用pem进行数据解码 -&gt; pem.Decode()</p>
</li>
<li><p>使用x509, 对私钥进行还原</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseECPrivateKey</span><span class="params">(der []<span class="keyword">byte</span>)</span> <span class="params">(key *ecdsa.PrivateKey, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>对原始数据进行哈希运算 -&gt; 散列值</p>
</li>
<li><p>进行数字签名</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(rand io.Reader, priv *PrivateKey, hash []<span class="keyword">byte</span>)</span> <span class="params">(r, s *big.Int, err error)</span></span></span><br><span class="line">- 得到的r和s不能直接使用, 因为这是指针</span><br><span class="line">	应该将这两块内存中的数据进行序列化 -&gt; []<span class="keyword">byte</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">(text []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li><p>使用公钥验证数字签名</p>
<blockquote>
<ol>
<li><p>打开公钥文件, 将里边的内容读出 -&gt; []byte</p>
</li>
<li><p>pem解码 -&gt; pem.Decode()</p>
</li>
<li><p>使用x509对公钥还原</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKIXPublicKey</span><span class="params">(derBytes []<span class="keyword">byte</span>)</span> <span class="params">(pub <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>将接口 -&gt; 公钥</p>
</li>
<li><p>对原始数据进行哈希运算 -&gt; 得到散列值</p>
</li>
<li><p>签名的认证 - &gt; ecdsa</p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Verify</span><span class="params">(pub *PublicKey, hash []<span class="keyword">byte</span>, r, s *big.Int)</span> <span class="title">bool</span></span></span><br><span class="line">- 参数<span class="number">1</span>: 公钥</span><br><span class="line">- 参数<span class="number">2</span>: 原始数据生成的散列值</span><br><span class="line">- 参数<span class="number">3</span>,<span class="number">4</span>: 通过签名得到的连个点</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">UnmarshalText</span><span class="params">(text []<span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="数字签名无法解决的问题"><a href="#数字签名无法解决的问题" class="headerlink" title="数字签名无法解决的问题"></a>数字签名无法解决的问题</h2><p><img src="/2021/08/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1539178819165.png" alt="1539178819165"></p>
<p>实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/elliptic&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	GenerateEccKey()</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;使用x509对pem.Block中的Bytes变量中的数据进行解析 -&gt;  得到一接口&quot;</span>)</span><br><span class="line">	rText, sText := EccSignature(src, <span class="string">&quot;eccPrivate.pem&quot;</span>)</span><br><span class="line">	bl := EccVerify(src, rText, sText, <span class="string">&quot;eccPublic.pem&quot;</span>)</span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 生成密钥对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateEccKey</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 使用ecdsa生成密钥对</span></span><br><span class="line">	privateKey, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 将私钥写入磁盘</span></span><br><span class="line">	<span class="comment">//- 使用x509进行序列化</span></span><br><span class="line">	derText, err := x509.MarshalECPrivateKey(privateKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 将得到的切片字符串放入pem.Block结构体中</span></span><br><span class="line">	block := pem.Block&#123;</span><br><span class="line">		Type : <span class="string">&quot;ecdsa private key&quot;</span>,</span><br><span class="line">		Bytes : derText,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 使用pem编码</span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;eccPrivate.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pem.Encode(file, &amp;block)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//3. 将公钥写入磁盘</span></span><br><span class="line">	<span class="comment">//- 从私钥中得到公钥</span></span><br><span class="line">	publicKey := privateKey.PublicKey</span><br><span class="line">	<span class="comment">//- 使用x509进行序列化</span></span><br><span class="line">	derText, err = x509.MarshalPKIXPublicKey(&amp;publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 将得到的切片字符串放入pem.Block结构体中</span></span><br><span class="line">	block = pem.Block&#123;</span><br><span class="line">		Type : <span class="string">&quot;ecdsa public key&quot;</span>,</span><br><span class="line">		Bytes : derText,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//- 使用pem编码</span></span><br><span class="line">	file, err = os.Create(<span class="string">&quot;eccPublic.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	pem.Encode(file, &amp;block)</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ecc签名 - 私钥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EccSignature</span><span class="params">(plainText []<span class="keyword">byte</span>, privName <span class="keyword">string</span>)</span>  <span class="params">(rText, sText []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 打开私钥文件, 将内容读出来 -&gt;[]byte</span></span><br><span class="line">	file, err := os.Open(privName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. 使用pem进行数据解码 -&gt; pem.Decode()</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509, 对私钥进行还原</span></span><br><span class="line">	privateKey, err := x509.ParseECPrivateKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 对原始数据进行哈希运算 -&gt; 散列值</span></span><br><span class="line">	hashText := sha1.Sum(plainText)</span><br><span class="line">	<span class="comment">//5. 进行数字签名</span></span><br><span class="line">	r, s, err := ecdsa.Sign(rand.Reader, privateKey, hashText[:])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 对r, s内存中的数据进行格式化 -&gt; []byte</span></span><br><span class="line">	rText, err = r.MarshalText()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	sText, err = s.MarshalText()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ecc签名认证</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EccVerify</span><span class="params">(plainText, rText, sText []<span class="keyword">byte</span>, pubFile <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">//1. 打开公钥文件, 将里边的内容读出 -&gt; []byte</span></span><br><span class="line">	file, err := os.Open(pubFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := file.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">	file.Read(buf)</span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="comment">//2. pem解码 -&gt; pem.Decode()</span></span><br><span class="line">	block, _ := pem.Decode(buf)</span><br><span class="line">	<span class="comment">//3. 使用x509对公钥还原</span></span><br><span class="line">	pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 将接口 -&gt; 公钥</span></span><br><span class="line">	publicKey := pubInterface.(*ecdsa.PublicKey)</span><br><span class="line">	<span class="comment">//5. 对原始数据进行哈希运算 -&gt; 得到散列值</span></span><br><span class="line">	hashText := sha1.Sum(plainText)</span><br><span class="line">	<span class="comment">// 将rText, sText -&gt; int数据</span></span><br><span class="line">	<span class="keyword">var</span> r, s big.Int</span><br><span class="line">	r.UnmarshalText(rText)</span><br><span class="line">	s.UnmarshalText(sText)</span><br><span class="line">	<span class="comment">//6. 签名的认证 - &gt; ecdsa  (问题,api的设计为什么在这个地方要传地址,直接传值比较不是更好吗?)</span></span><br><span class="line">	bl := ecdsa.Verify(publicKey, hashText[:], &amp;r, &amp;s)</span><br><span class="line">	<span class="keyword">return</span> bl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/" class="post-title-link" itemprop="url">消息认证码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-24 15:48:51 / 修改時間：15:59:11" itemprop="dateCreated datePublished" datetime="2021-08-24T15:48:51+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h1><h2 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h2><blockquote>
<p><strong>消息认证码（message authentication code）是一种确认完整性并进行认证的技术，取三个单词的首字母，简称为MAC。</strong></p>
</blockquote>
<p><img src="/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/1539176665517.png" alt="1539176665517"></p>
<ul>
<li><p>思考改进方案?</p>
<p>从哈希函数入手</p>
<p>需要将要发送的数据进行哈希运算, 将哈希值和原始数据一并发送</p>
<p>需要在进行哈希运算的时候引入加密的步骤</p>
<ul>
<li>在alice对数据进行哈希运算的时候引入一个秘钥, 让其参与哈希运算, 生成散列值</li>
<li>bob对数据校验<ul>
<li>bob收到原始和散列值之后, <ul>
<li>处理原始数据: 通过秘钥和哈希算法对原始数据生成散列值</li>
<li>散列值比较: 生成的散列值 和  接收到的散列值进行比对</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="消息认证码的使用步骤"><a href="#消息认证码的使用步骤" class="headerlink" title="消息认证码的使用步骤"></a>消息认证码的使用步骤</h2><p><img src="/2021/08/24/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/1539177690828.png" alt="1539177690828"></p>
<blockquote>
<p>前提条件:</p>
<ul>
<li>在消息认证码生成的一方和校验的一方, 必须有一个秘钥</li>
<li>双方约定好使用同样的哈希函数对数据进行运算</li>
</ul>
<p>流程:</p>
<p>发送者: </p>
<ul>
<li>发送原始法消息</li>
<li>将原始消息生成消息认证码<ul>
<li>((原始消息) + 秘钥)  *   函数函数 = 散列值(消息认证码)</li>
</ul>
</li>
<li>将消息认证码发送给对方</li>
</ul>
<p>接收者:</p>
<ul>
<li>接收原始数据</li>
<li>接收消息认证码</li>
<li>校验: <ul>
<li>( 接收的消息  +  秘钥 ) * 哈希函数   = 新的散列值</li>
<li>通过新的散列值和接收的散列值进行比较</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="go中对消息认证码的使用"><a href="#go中对消息认证码的使用" class="headerlink" title="go中对消息认证码的使用"></a>go中对消息认证码的使用</h2><blockquote>
<p>有一个包: crypto/hmac</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(h <span class="keyword">func</span>()</span> <span class="title">hash</span>.<span class="title">Hash</span>, <span class="title">key</span> []<span class="title">byte</span>) <span class="title">hash</span>.<span class="title">Hash</span></span></span><br><span class="line">- 返回值: hash接口</span><br><span class="line">- 参数<span class="number">1</span>: 哈希函数的函数名</span><br><span class="line">	sha1.<span class="built_in">new</span></span><br><span class="line">	md5.<span class="built_in">new</span></span><br><span class="line">	sha256.<span class="built_in">new</span></span><br><span class="line">- 参数<span class="number">2</span>: 秘钥</span><br><span class="line"></span><br><span class="line">第二步: 添加数据</span><br><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误</span></span><br><span class="line">    io.Writer</span><br><span class="line">    <span class="comment">// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 重设hash为无数据输入的状态</span></span><br><span class="line">    Reset()</span><br><span class="line">    <span class="comment">// 返回Sum会返回的切片的长度</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回hash底层的块大小；Write方法可以接受任何大小的数据，</span></span><br><span class="line">    <span class="comment">// 但提供的数据是块大小的倍数时效率更高</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line">第三步: 计算散列值</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/hmac&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	src := []<span class="keyword">byte</span>(<span class="string">&quot;在消息认证码中，需要发送者和接收者之间共享密钥，而这个密钥不能被主动攻击者Mallory获取。&quot;</span> +</span><br><span class="line">		<span class="string">&quot;如果这个密钥落入Mallory手中，则Mallory也可以计算出MAC值，从而就能够自由地进行篡改和伪装攻击，&quot;</span> +</span><br><span class="line">		<span class="string">&quot;这样一来消息认证码就无法发挥作用了。&quot;</span>)</span><br><span class="line">	key := []<span class="keyword">byte</span>(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">	hamc1 := GenerateHamc(src, key)</span><br><span class="line">	bl := VerifyHamc(src, key, hamc1)</span><br><span class="line">	<span class="comment">//fmt.Printf(&quot;校验结果: %t\n&quot;, bl)</span></span><br><span class="line">	fmt.Println(bl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成消息认证码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateHamc</span><span class="params">(plainText, key []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建哈希接口, 需要指定使用的哈希算法, 和秘钥</span></span><br><span class="line">	myhash := hmac.New(sha1.New, key)</span><br><span class="line">	<span class="comment">// 2. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">// 3. 计算散列值</span></span><br><span class="line">	hashText := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> hashText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证消息认证码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyHamc</span><span class="params">(plainText, key, hashText []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建哈希接口, 需要指定使用的哈希算法, 和秘钥</span></span><br><span class="line">	myhash := hmac.New(sha1.New, key)</span><br><span class="line">	<span class="comment">// 2. 给哈希对象添加数据</span></span><br><span class="line">	myhash.Write(plainText)</span><br><span class="line">	<span class="comment">// 3. 计算散列值</span></span><br><span class="line">	hamc1 := myhash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 4. 两个散列值比较</span></span><br><span class="line">	<span class="keyword">return</span> hmac.Equal(hashText, hamc1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="消息认证码的问题"><a href="#消息认证码的问题" class="headerlink" title="消息认证码的问题"></a>消息认证码的问题</h2><ol>
<li>弊端<ul>
<li>有秘钥分发困难的问题</li>
</ul>
</li>
<li>无法解决的问题<ul>
<li>不能进行第三方证明</li>
<li>不能防止否认</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/Go%E8%AF%AD%E8%A8%80sync-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/Go%E8%AF%AD%E8%A8%80sync-Map/" class="post-title-link" itemprop="url">Go语言sync.Map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 20:10:29 / 修改時間：20:20:16" itemprop="dateCreated datePublished" datetime="2021-08-18T20:10:29+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p>
<p>样例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>:<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="number">10000</span> &#123;</span><br><span class="line">			test[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">	fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现有这样的报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent map <span class="built_in">read</span> and map write</span><br></pre></td></tr></table></figure>

<p>根本原因就是：并发的去读写map结构的数据了。</p>
<p>错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。</p>
<p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</p>
<p>sync.Map 有以下特性：</p>
<ul>
<li>无须初始化，直接声明即可。</li>
<li>sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。</li>
<li>使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。</li>
</ul>
<p>并发安全的 sync.Map 演示代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> scene sync.Map</span><br><span class="line">	<span class="comment">// 将键值对保存到sync.Map</span></span><br><span class="line">	scene.Store(<span class="string">&quot;greece&quot;</span>, <span class="number">97</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;london&quot;</span>, <span class="number">100</span>)</span><br><span class="line">	scene.Store(<span class="string">&quot;egypt&quot;</span>, <span class="number">200</span>)</span><br><span class="line">	<span class="comment">// 从sync.Map中根据键取值</span></span><br><span class="line">	fmt.Println(scene.Load(<span class="string">&quot;london&quot;</span>))</span><br><span class="line">	<span class="comment">// 根据键删除对应的键值对</span></span><br><span class="line">	scene.Delete(<span class="string">&quot;london&quot;</span>)</span><br><span class="line">	<span class="comment">// 遍历所有sync.Map中的键值对</span></span><br><span class="line">	scene.Range(<span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;iterate:&quot;</span>, k, v)</span><br><span class="line">		<span class="comment">//return false   返回false立即停止遍历</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/" class="post-title-link" itemprop="url">Golang中map的基本使用和底层理解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 16:44:00 / 修改時間：19:53:38" itemprop="dateCreated datePublished" datetime="2021-08-18T16:44:00+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="map的基本使用"><a href="#map的基本使用" class="headerlink" title="map的基本使用"></a>map的基本使用</h1><h2 id="key与value的限制"><a href="#key与value的限制" class="headerlink" title="key与value的限制"></a>key与value的限制</h2><p>key一定要是<strong>可比较</strong>的类型（可以理解为支持==的操作）：</p>
<table>
<thead>
<tr>
<th align="center">可比教类型</th>
<th align="center">不可比较类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">slice</td>
</tr>
<tr>
<td align="center">numeric</td>
<td align="center">map</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">func</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">channel</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">interface</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">array和struct</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果是非法的key类型，会报错：invalid map key type xxx</p>
<blockquote>
<p>golang为uint32、uint64、string提供了fast access，使用这些类型作为key可以提高map访问速度。[runtime/hashmap_fast.go]</p>
</blockquote>
<p>value可以是<strong>任意类型</strong>。</p>
<h2 id="新增-amp-删除-amp-更新-amp-查询"><a href="#新增-amp-删除-amp-更新-amp-查询" class="headerlink" title="新增 &amp; 删除 &amp; 更新 &amp; 查询"></a>新增 &amp; 删除 &amp; 更新 &amp; 查询</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除，key不存在则啥也不干</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;咖啡色的羊驼2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询，key不存在返回value类型的零值</span></span><br><span class="line">i := m[<span class="string">&quot;name&quot;</span>] <span class="comment">// 三种查询方式，</span></span><br><span class="line">i, ok := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">_, ok := m[<span class="string">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>需要强调的是map本身是<strong>无序的</strong>，在遍历的时候并不会按照你传入的顺序，进行传出</p>
<p>正常遍历:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; </span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有序遍历:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 把key单独抽取出来，放在数组中</span></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">    keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行数组的排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">// 遍历数组就是有序的了</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">    fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>Golang中是没有引用传递的，均为值传递。这意味着传递的是数据的拷贝。<br>那么map本身是<strong>引用类型</strong>，作为形参或返回参数的时候，传递的是<strong>值的拷贝，而值是地址</strong>，<strong>扩容</strong>时也<strong>不会改变</strong>这个地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeM</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 函数开始时地址是： %p\n&quot;</span>, m)</span><br><span class="line">	<span class="keyword">var</span> max = <span class="number">5</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;max; i++&#123;</span><br><span class="line">		m[<span class="keyword">int64</span>(i)] = <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 在函数返回前地址是：%p\n&quot;</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span></span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>, <span class="number">1</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 的原始地址：%p\n&quot;</span>, m)</span><br><span class="line">	changeM(m)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m 改变后地址：%p\n&quot;</span>, m)</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 长度是：&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line">	fmt.Println(<span class="string">&quot;m 参数是：&quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m 的原始地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 函数开始时地址是： <span class="number">0xc00006a360</span></span><br><span class="line">m 在函数返回前地址是：<span class="number">0xc00006a360</span></span><br><span class="line">m 改变后地址：<span class="number">0xc00006a360</span></span><br><span class="line">m 长度是： <span class="number">5</span></span><br><span class="line">m 参数是： <span class="keyword">map</span>[<span class="number">0</span>:<span class="number">2</span> <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2</span> <span class="number">3</span>:<span class="number">2</span> <span class="number">4</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="map的深入理解"><a href="#map的深入理解" class="headerlink" title="map的深入理解"></a>map的深入理解</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p>
<p>map数据结构由<code>runtime/map.go:hmap</code>定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    ...</span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    ...</span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示一个拥有4个bucket的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt="img " style="zoom:80%;">

<p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p>
<p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket</p>
<h2 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h2><p>bucket数据结构由<code>runtime/map.go:bmap</code>定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位</span></span><br><span class="line">    data    <span class="keyword">byte</span>[<span class="number">1</span>]  <span class="comment">//key value数据:key/key/key/.../value/value/value...</span></span><br><span class="line">    overflow *bmap   <span class="comment">//溢出bucket的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个bucket可以存储8个键值对。</p>
<ul>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li>
<li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li>
</ul>
<p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p>
<p>下图展示bucket存放8个key-value对：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_7f0ba5a124641b1413279892581513c4_r.png" alt="img" style="zoom:80%;">

<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</p>
<p>下图展示产生冲突后的map：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_a8b9e5919d9951a71c1c36445dd68521_r.png" alt="img" style="zoom:80%;">

<p>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍</p>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p>
<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 = 键数量/bucket数量</span><br></pre></td></tr></table></figure>
</blockquote>
<p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</p>
<p>哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：</p>
<ul>
<li>哈希因子过小，说明空间利用率低</li>
<li>哈希因子过大，说明冲突严重，存取效率低</li>
</ul>
<p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p>
<h2 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h2><h3 id="扩容的前提条件"><a href="#扩容的前提条件" class="headerlink" title="扩容的前提条件"></a>扩容的前提条件</h3><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。<br>触发扩容的条件有二个：</p>
<ol>
<li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li>
</ol>
<h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。<br>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2d622a6bc19ca1b5bcb225f77869f9c2_r.png" alt="img" style="zoom:100%;">

<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</p>
<p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_2f0122f26e5d66ca91e6820ace6b379b_r.png" alt="img" style="zoom:100%;">

<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。<br>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</p>
<p>搬迁完成后的示意图如下：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_b1178e0a3cea02c9386e5f5eaa6f99a6_r.png" alt="img" style="zoom:80%;">

<p>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。</p>
<h3 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h3><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，而是把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。<br>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</p>
<img src="/2021/08/18/Golang%E4%B8%AD%E7%9A%84map/m_f3a5989c90204df9304d5ae246f3db72_r.png" alt="img" style="zoom:80%;">

<p>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</p>
<h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>取哈希值高位在tophash数组中查询</li>
<li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li>
<li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li>
<li>如果当前处于搬迁过程，则优先从oldbuckets查找</li>
</ol>
<p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p>
<h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p>
<ol>
<li>根据key值算出哈希值</li>
<li>取哈希值低位与hmap.B取模确定bucket位置</li>
<li>查找该key是否已经存在，如果存在则直接更新值</li>
<li>如果没找到将key，将key插入</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">单向散列函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 15:00:02 / 修改時間：15:17:22" itemprop="dateCreated datePublished" datetime="2021-08-18T15:00:02+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是单向散列函数"><a href="#什么是单向散列函数" class="headerlink" title="什么是单向散列函数"></a>什么是单向散列函数</h2><blockquote>
<p>单向散列函数（one-wayftnction）有一个输人和一个输出，其中输人称为消息（message），输出称为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。</p>
<p>散列值的长度和消息的长度无关。无论消息是1比特，还是100MB，甚至是IOOGB，单向散列函数都会计算出固定长度的散列值。以SHA-I单向散列函数为例，它所计算出的散列值的长度永远是160比特（20字节）</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150209003.png" alt="image-20210818150209003" style="zoom:67%;">

<h2 id="单向散列函数的性质"><a href="#单向散列函数的性质" class="headerlink" title="单向散列函数的性质"></a>单向散列函数的性质</h2><ul>
<li><p>根据任意长度的消息计算出固定长度的散列值</p>
</li>
<li><p>能够快速计算出散列值</p>
</li>
<li><p>消息不同散列值也不同</p>
<blockquote>
<p>为了能够确认完整性，消息中哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值。</p>
<p>如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。<strong>两个不同的消息产生同一个散列值的情况称为碰撞（collision）</strong>。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。</p>
</blockquote>
</li>
<li><p><strong>具备单向性</strong></p>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150357989.png" alt="image-20210818150357989" style="zoom:67%;"></li>
</ul>
<h2 id="单向散列函数的实际应用"><a href="#单向散列函数的实际应用" class="headerlink" title="单向散列函数的实际应用"></a>单向散列函数的实际应用</h2><ul>
<li>检测软件是否被篡改</li>
</ul>
<blockquote>
<p>我们可以使用单向散列函数来确认自己下载的软件是否被篡改。</p>
<p>很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。</p>
<p>这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。</p>
</blockquote>
<img src="/2021/08/18/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/image-20210818150530259.png" alt="image-20210818150530259" style="zoom:67%;">

<ul>
<li><p>消息认证码</p>
<blockquote>
<p>使用单向散列函数可以构造消息认证码。</p>
<p>消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。</p>
<p>消息认证码在SSL/TLS中也得到了运用，关于SSL/TLS我们将后边章节中介绍。</p>
</blockquote>
</li>
<li><p>数字签名</p>
<blockquote>
<p>在进行数字签名时也会使用单向散列函数。</p>
<p>数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。</p>
</blockquote>
</li>
<li><p>伪随机数生成器</p>
<blockquote>
<p>使用单向散列函数可以构造伪随机数生成器。</p>
<p>密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。</p>
</blockquote>
</li>
<li><p>一次性口令</p>
<blockquote>
<p>使用单向散列函数可以构造一次性口令（one-time password）。</p>
<p>一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。</p>
</blockquote>
</li>
</ul>
<h2 id="常用的单向散列函数"><a href="#常用的单向散列函数" class="headerlink" title="常用的单向散列函数"></a>常用的单向散列函数</h2><h3 id="MD4、MD5"><a href="#MD4、MD5" class="headerlink" title="MD4、MD5"></a>MD4、MD5</h3><blockquote>
<p>MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。</p>
<p>MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。</p>
</blockquote>
<p>Go中使用MD5</p>
<ul>
<li><p>需要导入的包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>计算Md5的方式1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_1</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 计算数据的md5</span></span><br><span class="line">	result := md5.Sum(str)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, result)</span><br><span class="line">	<span class="comment">// 2. 数据格式化为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result[:])</span><br><span class="line">	fmt.Println(<span class="string">&quot;res: &quot;</span>, res)</span><br><span class="line">	<span class="keyword">return</span>  res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>返回数据data的MD5校验和</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(data []<span class="keyword">byte</span>)</span> [<span class="title">Size</span>]<span class="title">byte</span></span></span><br><span class="line">    - 参数 data: 原始数据</span><br><span class="line">    - 返回值: 经过md5计算之后得到的数据, 长度为 <span class="number">16</span>字节(<span class="keyword">byte</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>将字符串编码为16进制格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeToString</span><span class="params">(src []<span class="keyword">byte</span>)</span> <span class="title">string</span></span></span><br><span class="line">    - 参数 src: 要转换的数据</span><br><span class="line">    - 返回值: 转换之后得到的<span class="number">16</span>进制格式字符串</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>计算Md5的方式2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMD5_2</span><span class="params">(str []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 创建一个使用MD5校验的Hash对象`</span></span><br><span class="line">	myHash := md5.New()</span><br><span class="line">	<span class="comment">// 2. 通过io操作将数据写入hash对象中</span></span><br><span class="line">	io.WriteString(myHash, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="comment">//io.WriteString(myHash, &quot;, world&quot;)</span></span><br><span class="line">	myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;, world&quot;</span>))</span><br><span class="line">	<span class="comment">// 3. 计算结果</span></span><br><span class="line">	result := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	<span class="comment">// 4. 将结果转换为16进制格式字符串</span></span><br><span class="line">	res := fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="comment">// --- 这是另外一种格式化切片的方式</span></span><br><span class="line">	res = hex.EncodeToString(result)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要函数说明:</p>
<ol>
<li><p>创建一个新的使用MD5校验的hash.Hash接口 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">hash</span>.<span class="title">Hash</span></span></span><br></pre></td></tr></table></figure>

<p>Hash是一个被所有hash函数实现的公共接口。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误</span></span><br><span class="line">    io.Writer</span><br><span class="line">    <span class="comment">// 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line">    <span class="comment">// 重设hash为无数据输入的状态</span></span><br><span class="line">    Reset()</span><br><span class="line">    <span class="comment">// 返回Sum会返回的切片的长度</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 返回hash底层的块大小；Write方法可以接受任何大小的数据，</span></span><br><span class="line">    <span class="comment">// 但提供的数据是块大小的倍数时效率更高</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;io&quot;</span> 包中 Writer 接口用于包装基本的写入方法。</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过io操作将数据写入hash对象中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 第一种方式</span><br><span class="line">函数所属的包: <span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line">    - 参数 w: 实现了/包含Writer接口的对象</span><br><span class="line">    - 参数 s: 要添加到IO对象中的数据</span><br><span class="line">    - 返回值 n: 数据长度</span><br><span class="line">    - 返回值 err: 错误信息</span><br><span class="line"># 第二种方式</span><br><span class="line">使用md5包中的New()方法得到的hash.Hash接口(假设名为: myHash)添加数据</span><br><span class="line">myHash.Write([]<span class="keyword">byte</span>(<span class="string">&quot;测试数据&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>使用hash.Hash接口中的Sum方法计算结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sum(b []byte) []byte</span><br><span class="line">    - 参数 b: 将b中的数据进行哈希计算, 结果添加到原始数据的前面, </span><br><span class="line">      		 一般情况下该参数指定为空, 即: nil</span><br><span class="line">    - 返回值: 进行哈希运算之后得到的结果 </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"><a href="#SHA-1、SHA-224、SHA-256、SHA-384、SHA-512" class="headerlink" title="SHA-1、SHA-224、SHA-256、SHA-384、SHA-512"></a>SHA-1、SHA-224、SHA-256、SHA-384、SHA-512</h2><blockquote>
<p>SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。</p>
<p>SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没有问题。</p>
<p>SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th align="center">比特数</th>
<th align="center">字节数</th>
</tr>
</thead>
<tbody><tr>
<td>MD4</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>MD5</td>
<td align="center">128bit</td>
<td align="center">16byte</td>
</tr>
<tr>
<td>SHA-1</td>
<td align="center">160bit</td>
<td align="center">20byte</td>
</tr>
<tr>
<td>SHA-224</td>
<td align="center">224bit</td>
<td align="center">28byte</td>
</tr>
<tr>
<td>SHA-256</td>
<td align="center">256bit</td>
<td align="center">32byte</td>
</tr>
<tr>
<td>SHA-384</td>
<td align="center">384bit</td>
<td align="center">48byte</td>
</tr>
<tr>
<td>SHA-512</td>
<td align="center">512bit</td>
<td align="center">64byte</td>
</tr>
</tbody></table>
<h3 id="Go中对SHA-1、SHA-2的使用"><a href="#Go中对SHA-1、SHA-2的使用" class="headerlink" title="Go中对SHA-1、SHA-2的使用"></a>Go中对SHA-1、SHA-2的使用</h3><ul>
<li>需要导入的包</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/sha1&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/sha512&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用sha1计算文件指纹</li>
</ul>
<blockquote>
<p>上一小节介绍了如何使用go提供的API计算数据的md5指纹, sha1的计算方式和md5的套路是一样的, 需要将md5包, 替换为sh1, 下面给大家介绍一下如何使用sha1计算文件的指纹(md5亦如此) </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSha1</span><span class="params">(src <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 打开文件</span></span><br><span class="line">	fp, err := os.Open(src)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;文件打开失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 创建基于sha1算法的Hash对象</span></span><br><span class="line">	myHash := sha1.New()</span><br><span class="line">	<span class="comment">// 3. 将文件数据拷贝给哈希对象</span></span><br><span class="line">	num, err := io.Copy(myHash, fp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;拷贝文件失败&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件大小: &quot;</span>, num)</span><br><span class="line">	<span class="comment">// 4. 计算文件的哈希值</span></span><br><span class="line">	tmp1 := myHash.Sum(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 5. 数据格式转换</span></span><br><span class="line">    result := hex.EncodeToString(tmp1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;sha1: &quot;</span>, result)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zhudalao243.github.io/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="zzy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">非对称加密</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>
      

      <time title="創建時間：2021-08-18 14:15:44 / 修改時間：15:17:52" itemprop="dateCreated datePublished" datetime="2021-08-18T14:15:44+08:00">2021-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">密码学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;非对称加密也叫公钥密码: 使用公钥加密, 使用私钥解密&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对称加密的弊端"><a href="#对称加密的弊端" class="headerlink" title="对称加密的弊端"></a>对称加密的弊端</h2><ul>
<li><p>秘钥分发困难</p>
</li>
<li><p>可以通过非对称加密完成秘钥的分发</p>
<blockquote>
<p>https</p>
<p>Alice 和 Bob通信, Alice给bob发送数据, 使用对称加密的方式</p>
<ol>
<li>生成一个非对称的秘钥对, bob生成</li>
<li>bob将公钥发送给alice</li>
<li>alice生成一个用于对称加密的秘钥</li>
<li>alice使用bob的公钥就对称加密的秘钥进行加密, 并且发送给bob</li>
<li>bob使用私钥就数据解密, 得到对称加密的秘钥</li>
<li>通信的双方使用写好的秘钥进行对称加密数据加密</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="非对称加密的秘钥"><a href="#非对称加密的秘钥" class="headerlink" title="非对称加密的秘钥"></a>非对称加密的秘钥</h2><ul>
<li>不存在秘钥分发困难的问题</li>
</ul>
<h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>数据对谁更重要, 谁就拿私钥</p>
<ul>
<li>直观上看: 私钥比公钥长</li>
<li>使用第三方工具生成密钥对: 公钥文件xxx.pub xxx </li>
</ul>
<blockquote>
<ol>
<li><p>通信流程, 信息加密  （A写数据, 发送给B, 信息只允许B读）</p>
<p>A: 公钥</p>
<p>B: 私钥</p>
</li>
<li><p>登录认证 （客户端要登录, 连接服务器, 向服务器请求个人数据）</p>
<p>客户端:  私钥</p>
<p>服务器:  公钥</p>
</li>
<li><p>数字签名（表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面）</p>
<ul>
<li>发送信息的人:   私钥</li>
<li>收到信息的人:   公钥</li>
</ul>
</li>
<li><p>网银U盾</p>
<ul>
<li>个人: 私钥</li>
<li>银行拿公钥</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><h3 id="RSA加密"><a href="#RSA加密" class="headerlink" title="RSA加密"></a>RSA加密</h3><blockquote>
<p>非对称加密的代表—RSA。在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达，如下:                                                                                    </p>
</blockquote>
<p>$$<br>密文=明文 ^ E  mod     N（RSA加密）<br>$$</p>
<blockquote>
<p>也就是说，RSA的密文是对代表明文的数字的E次方求modN的结果。换句话说，就是将明文自己做E次乘法，然后将其结果除以N求余数，这个余数就是密文。</p>
<p>加密公式中出现的两个数一一一E和N，到底都是什么数呢？RSA的加密是求明文的E次方modN，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，E和N是RSA加密的密钥，也就是说，<strong>E和N的组合就是公钥</strong>。</p>
<p>不过，E和N并不是随便什么数都可以的，它们是经过严密计算得出的。顺便说一句，<strong>E是加密（Encryption）的首字母，N是数字（Number)的首字母</strong>。</p>
<p>有一个很容易引起误解的地方需要大家注意一一E和N这两个数并不是密钥对（公钥和私钥的密钥对）。E和N两个数才组成了一个公钥，因此我们一般会写成 “公钥是(E，N)” 或者 “公钥是{E, N}” 这样的形式，将E和N用括号括起来。</p>
<p>现在大家应该已经知道，==<strong>RSA的加密就是 “求E次方的modN”</strong>==，接下来我们来看看RSA的解密。</p>
</blockquote>
<h3 id="RSA解密"><a href="#RSA解密" class="headerlink" title="RSA解密"></a>RSA解密</h3><blockquote>
<p>RSA的解密和加密一样简单，可以用下面的公式来表达：</p>
</blockquote>
<p>$$<br>明文=密文^DmodN（RSA解密）<br>$$</p>
<blockquote>
<p>也就是说，对表示密文的数字的D次方求modN就可以得到明文。换句话说，将密文自己做D次乘法，再对其结果除以N求余数，就可以得到明文。</p>
<p>这里所使用的数字N和加密时使用的数字N是相同的。<strong>数D和数N组合起来就是RSA的解密密钥，因此D和N的组合就是私钥</strong>。只有知道D和N两个数的人才能够完成解密的运算。</p>
<p>大家应该已经注意到，<strong>在RSA中，加密和解密的形式是相同的。加密是求 “E次方的mod N”，而解密则是求 “D次方的modN”</strong>，这真是太美妙了。</p>
<p>当然，D也并不是随便什么数都可以的，作为解密密钥的D，和数字E有着相当紧密的联系。否则，用E加密的结果可以用D来解密这样的机制是无法实现的。</p>
<p>顺便说一句，<strong>D是解密〈Decryption）的首字母，N是数字（Number）的首字母</strong>。</p>
<p>我们将上面讲过的内容整理一下，如下表所示。</p>
</blockquote>
<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143403596.png" alt="image-20210818143403596" style="zoom:67%;">

<img src="/2021/08/18/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/image-20210818143417941.png" alt="image-20210818143417941" style="zoom:67%;">

<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ol>
<li>x509证书规范、pem、base64<ul>
<li>pem编码规范 - 数据加密</li>
<li>base64 - 对数据编码, 可逆<ul>
<li>不管原始数据是什么, 将原始数据使用64个字符来替代<ul>
<li>a-z  A-Z 0-9 + /</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ASN.1抽象语法标记</li>
<li>PKCS1标准</li>
</ol>
<h2 id="Go中生成公钥和私钥"><a href="#Go中生成公钥和私钥" class="headerlink" title="Go中生成公钥和私钥"></a>Go中生成公钥和私钥</h2><p>需要引入的包:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>生成私钥操作流程概述:</p>
<blockquote>
<ol>
<li>使用rsa中的GenerateKey方法生成私钥</li>
<li>通过x509标准将得到的ras私钥序列化为ASN.1 的 DER编码字符串</li>
<li>将私钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件中</li>
</ol>
</blockquote>
<p>生成公钥操作流程:</p>
<blockquote>
<ol>
<li>从得到的私钥对象中将公钥信息取出</li>
<li>通过x509标准将得到 的rsa公钥序列化为字符串</li>
<li>将公钥字符串设置到pem格式块中</li>
<li>通过pem将设置好的数据进行编码, 并写入磁盘文件</li>
</ol>
</blockquote>
<p>生成公钥和私钥的源代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数bits: 指定生成的秘钥的长度, 单位: bit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RsaGenKey</span><span class="params">(bits <span class="keyword">int</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1. 生成私钥件</span></span><br><span class="line">	<span class="comment">// GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥</span></span><br><span class="line">	<span class="comment">// 参数1: Reader是一个全局、共享的密码用强随机数生成器</span></span><br><span class="line">	<span class="comment">// 参数2: 秘钥的位数 - bit</span></span><br><span class="line">	privateKey, err := rsa.GenerateKey(rand.Reader, bits)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. MarshalPKCS1PrivateKey将rsa私钥序列化为ASN.1 PKCS#1 DER编码</span></span><br><span class="line">	derStream := x509.MarshalPKCS1PrivateKey(privateKey)</span><br><span class="line">	<span class="comment">// 3. Block代表PEM编码的结构, 对其进行设置</span></span><br><span class="line">	block := pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>,<span class="comment">//&quot;RSA PRIVATE KEY&quot;,</span></span><br><span class="line">		Bytes: derStream,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4. 创建文件</span></span><br><span class="line">	privFile, err := os.Create(<span class="string">&quot;private.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5. 使用pem编码, 并将数据写入文件中</span></span><br><span class="line">	err = pem.Encode(privFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6. 最后的时候关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> privFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 7. 生成公钥文件</span></span><br><span class="line">	publicKey := privateKey.PublicKey</span><br><span class="line">	derPkix, err := x509.MarshalPKIXPublicKey(&amp;publicKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	block = pem.Block&#123;</span><br><span class="line">		Type: <span class="string">&quot;RSA PUBLIC KEY&quot;</span>,<span class="comment">//&quot;PUBLIC KEY&quot;,</span></span><br><span class="line">		Bytes: derPkix,</span><br><span class="line">	&#125;</span><br><span class="line">	pubFile, err := os.Create(<span class="string">&quot;public.pem&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 8. 编码公钥, 写入文件</span></span><br><span class="line">	err = pem.Encode(pubFile, &amp;block)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> pubFile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的函数介绍:</p>
<ol>
<li><p>GenerateKey函数使用随机数据生成器random生成一对具有指定字位数的RSA密钥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/rsa&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(random io.Reader, bits <span class="keyword">int</span>)</span> <span class="params">(priv *PrivateKey, err error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: io.Reader: 赋值为: rand.Reader</span><br><span class="line">        -- rand包实现了用于加解密的更安全的随机数生成器。</span><br><span class="line">        -- <span class="keyword">var</span> Reader io.Reader (rand包中的变量)</span><br><span class="line">    - 参数<span class="number">2</span>: bits: 秘钥长度</span><br><span class="line">    - 返回值<span class="number">1</span>: 代表一个RSA私钥。</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>通过x509 将rsa私钥序列化为ASN.1 PKCS#1 DER编码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数 (x509包解析X<span class="number">.509</span>编码的证书和密钥)。</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKCS1PrivateKey</span><span class="params">(key *rsa.PrivateKey)</span> []<span class="title">byte</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过rsa.GenerateKey得到的私钥</span><br><span class="line">    - 返回值: 将私钥通过ASN<span class="number">.1</span>序列化之后得到的私钥编码数据</span><br></pre></td></tr></table></figure></li>
<li><p>设置Pem编码结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Block代表PEM编码的结构。</span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span>            <span class="comment">// 得自前言的类型（如&quot;RSA PRIVATE KEY&quot;）</span></span><br><span class="line">    Headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// 可选的头项，Headers是可为空的多行键值对。</span></span><br><span class="line">    Bytes   []<span class="keyword">byte</span>            <span class="comment">// 内容解码后的数据，一般是DER编码的ASN.1结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将得到的Pem格式私钥通过文件指针写入磁盘中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, b *Block)</span> <span class="title">error</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 可进行写操作的IO对象, 此处需要指定一个文件指针</span><br><span class="line">    - 参数<span class="number">2</span>: 初始化完成的Pem块对象, 即Block对象</span><br></pre></td></tr></table></figure></li>
<li><p>通过RSA私钥得到公钥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私钥</span></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey            <span class="comment">// 公钥</span></span><br><span class="line">    D         *big.Int   <span class="comment">// 私有的指数</span></span><br><span class="line">    Primes    []*big.Int <span class="comment">// N的素因子，至少有两个</span></span><br><span class="line">    <span class="comment">// 包含预先计算好的值，可在某些情况下加速私钥的操作</span></span><br><span class="line">    Precomputed PrecomputedValues</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    N   *big.Int <span class="comment">// 模</span></span><br><span class="line">    E   <span class="keyword">int</span>      <span class="comment">// 公开的指数</span></span><br><span class="line">&#125;</span><br><span class="line">通过私钥获取公钥</span><br><span class="line">publicKey := privateKey.PublicKey <span class="comment">// privateKey为私钥对象</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过x509将公钥序列化为PKIX格式DER编码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;crypto/x509&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalPKIXPublicKey</span><span class="params">(pub <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line">    - 参数<span class="number">1</span>: 通过私钥对象得到的公钥</span><br><span class="line">    - 返回值<span class="number">1</span>：将公钥通过ASN<span class="number">.1</span>序列化之后得到的编码数据</span><br><span class="line">    - 返回值<span class="number">2</span>: 错误信息</span><br></pre></td></tr></table></figure></li>
<li><p>将公钥编码之后的数据格式化为Pem结构, 参考私钥的操作</p>
</li>
<li><p>将得到的Pem格式公钥通过文件指针写入磁盘中</p>
</li>
<li><p>生成的私钥和公钥文件数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 私钥文件数据</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXgIBAAKBgQC5bm0DCEV+EFeiLUqSshziqhSB30jXy5BWbPV5SlMq4aWiEknM</span><br><span class="line">i+Mw1aXic4bEsM3YyT73eWsifqZNSc/4fRaV4qz5OL8IIe9AZoGDSLX/Ar9AQMJf</span><br><span class="line">OHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3DVEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">AoGARGdn72ZtvENrEHiEufjajwMO7Zng1TpS1I79PvEcHQWAhHkaoEo6VRl7SD41</span><br><span class="line">yPkv9njGsaQo0WDHGFvSTGhYm/EWGrBWRPc5xXbSBg7ty9Iza9B1ekAj8VfWryen</span><br><span class="line">Wje3xDOCVCDUiCcYdaSfPiJPYuWMSnNMNa+0cR921zBQg0ECQQDpCMljuH7LrpbC</span><br><span class="line">NDF5q+LbUWMAE2KLDPX4WmDSdZdIO3mPux3MdwOUEfrcvSBGZNB7gyaEG7goZL8G</span><br><span class="line">BqL22MJHAkEAy7SqbVPoPbMPHuLI52VQ2FDp6xxSWLhjmv1ePCHGo28MDCaHeVzZ</span><br><span class="line">QaxyuIbnY8A6NHfu/QGwz/eB941IjYNBMwJBAI9XEEl+mr++zIz4fdZRnGE7VqId</span><br><span class="line">SmgtuL7jGNtb6YpMyyFV/6ZdLp5N0PkmfEvQh0zyBycLxeNS1Q1n16Xu/tECQQCZ</span><br><span class="line">dF42wdDgOfWYFMu31VETw9CTtuApya3vYhMNRXx4Pf1bYeMIf/OCT8CUVbwWHwc5</span><br><span class="line">42d73TwvTorvy9TuFgSVAkEA6F69THlTn5oIP8IWHcHuqS01fIR/vGfEwQ4cFZGR</span><br><span class="line">ketfieyeeF8rjn4qzwT/ugwRNjkhfKmoILnIC8UhEEJdjA==</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公钥文件数据</span></span><br><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5bm0DCEV+EFeiLUqSshziqhSB</span><br><span class="line"><span class="number">30</span>jXy5BWbPV5SlMq4aWiEknMi+Mw1aXic4bEsM3YyT73eWsifqZNSc/<span class="number">4</span>fRaV4qz5</span><br><span class="line">OL8IIe9AZoGDSLX/Ar9AQMJfOHbAtdIlCGQ4d80KjpDpPs2wZkTqllWCg31d7U3D</span><br><span class="line">VEm5kqTGtSYIu9e7JQIDAQAB</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go中使用RSA加解密"><a href="#Go中使用RSA加解密" class="headerlink" title="Go中使用RSA加解密"></a>Go中使用RSA加解密</h2><ol>
<li><p>操作步骤</p>
<ul>
<li><p>公钥加密</p>
<blockquote>
<ol>
<li>将公钥文件中的公钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的公钥解析出来</li>
<li>使用得到的公钥通过rsa进行数据加密</li>
</ol>
</blockquote>
</li>
<li><p>私钥解密</p>
<blockquote>
<ol>
<li>将私钥文件中的私钥读出, 得到使用pem编码的字符串</li>
<li>将得到的字符串解码</li>
<li>使用x509将编码之后的私钥解析出来</li>
<li>使用得到的私钥通过rsa进行数据解密</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li>RSA公钥加密</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSAEncrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">    file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 读文件</span></span><br><span class="line">    info, _ := file.Stat()</span><br><span class="line">    allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">    file.Read(allText)</span><br><span class="line">    <span class="comment">// 3. 关闭文件</span></span><br><span class="line">    file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">    block, _ := pem.Decode(allText)</span><br><span class="line">    <span class="keyword">if</span> block == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 解析一个DER编码的公钥</span></span><br><span class="line">    pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 公钥加密</span></span><br><span class="line">    result, _ := rsa.EncryptPKCS1v15(rand.Reader, pubKey, src)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RSA私钥解密</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RSADecrypt</span><span class="params">(src, filename []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 根据文件名将文件内容从文件中读出</span></span><br><span class="line">  file, err := os.Open(<span class="keyword">string</span>(filename))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 读文件</span></span><br><span class="line">  info, _ := file.Stat()</span><br><span class="line">  allText := <span class="built_in">make</span>([]<span class="keyword">byte</span>, info.Size())</span><br><span class="line">  file.Read(allText)</span><br><span class="line">  <span class="comment">// 3. 关闭文件</span></span><br><span class="line">  file.Close()</span><br><span class="line">  <span class="comment">// 4. 从数据中查找到下一个PEM格式的块</span></span><br><span class="line">  block, _ := pem.Decode(allText)</span><br><span class="line">  <span class="comment">// 5. 解析一个pem格式的私钥</span></span><br><span class="line">  privateKey , err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">  <span class="comment">// 6. 私钥解密</span></span><br><span class="line">  result, _ := rsa.DecryptPKCS1v15(rand.Reader, privateKey, src)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重要的函数介绍</li>
</ul>
<ol>
<li>将得到的Pem格式私钥通过文件指针写入磁盘中</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;encoding/pem&quot;</span> 包中的函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(p *Block, rest []<span class="keyword">byte</span>)</span></span></span><br><span class="line">    - 参数 data: 需要解析的数据块</span><br><span class="line">    - 返回值<span class="number">1</span>: 从参数中解析出的PEM格式的块</span><br><span class="line">    - 返回值<span class="number">2</span>: 参数data剩余的未被解码的数据</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解析一个DER编码的公钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKIXPublicKey</span><span class="params">(derBytes []<span class="keyword">byte</span>)</span> <span class="params">(pub <span class="keyword">interface</span>&#123;&#125;, err error)</span></span></span><br><span class="line">    - 参数 derBytes: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 pub: 接口对象, 实际是公钥数据</span><br><span class="line">    - 参数 err:   错误信息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解析一个DER编码的私钥 , pem中的Block结构体中的数据格式为ASN.1编码</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParsePKCS1PrivateKey</span><span class="params">(der []<span class="keyword">byte</span>)</span> <span class="params">(key *rsa.PrivateKey, err error)</span></span></span><br><span class="line">    - 参数 der: 从pem的Block结构体中取的ASN<span class="number">.1</span>编码数据</span><br><span class="line">    - 返回值 key: 解析出的私钥</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将接口转换为公钥</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubKey := pubInterface.(*rsa.PublicKey)</span><br><span class="line">    - pubInterface: ParsePKIXPublicKey函数返回的 <span class="keyword">interface</span>&#123;&#125; 对象</span><br><span class="line">    - pubInterface.(*rsa.PublicKey): 将pubInterface转换为公钥类型 rsa.PublicKey</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用公钥加密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptPKCS1v15</span><span class="params">(rand io.Reader, pub *PublicKey, msg []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 pub:  非对称加密加密使用的公钥</span><br><span class="line">    - 参数 msg:  要使用公钥加密的原始数据</span><br><span class="line">    - 返回值 out: 加密之后的数据</span><br><span class="line">    - 返回值 err: 错误信息</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用私钥解密数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数所属的包: <span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptPKCS1v15</span><span class="params">(rand io.Reader, priv *PrivateKey, ciphertext []<span class="keyword">byte</span>)</span> <span class="params">(out []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line">    - 参数 rand: 随机数生成器, 赋值为 rand.Reader</span><br><span class="line">    - 参数 priv: 非对称加密解密使用的私钥</span><br><span class="line">    - 参数 ciphertext: 需要使用私钥解密的数据</span><br><span class="line">    - 返回值 out: 解密之后得到的数据</span><br><span class="line">    - 返回值 err: 错误信</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ECC椭圆曲线"><a href="#ECC椭圆曲线" class="headerlink" title="ECC椭圆曲线"></a>ECC椭圆曲线</h2><blockquote>
<ol>
<li>概念</li>
</ol>
<p>椭圆曲线密码学（英语：Elliptic curve cryptography，缩写为 ECC），一种建立公开密钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p>
<p>ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。</p>
<p>椭圆曲线密码学的许多形式有稍微的不同，所有的都依赖于被广泛承认的解决椭圆曲线离散对数问题的困难性上。与传统的基于大质数因子分解困难性的加密方法不同，ECC通过椭圆曲线方程式的性质产生密钥。</p>
<p>ECC 164位的密钥产生的一个安全级相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国<code>居民二代身份证</code>正在使用 256 位的椭圆曲线密码，虚拟货币<code>比特币</code>也选择ECC作为加密算法。</p>
<p>具体算法详解参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/taifei/article/details/73277247">https://blog.csdn.net/taifei/article/details/73277247</a></li>
</ul>
<ol start="2">
<li>数学原理</li>
</ol>
<p>不管是RSA还是ECC或者其它，公钥加密算法都是依赖于某个正向计算很简单（多项式时间复杂度），而逆向计算很难（指数级时间复杂度）的数学问题。</p>
<p>椭圆曲线依赖的数学难题是:</p>
<p><code>k为正整数，P是椭圆曲线上的点（称为基点）, k*P=Q , 已知Q和P，很难计算出k</code></p>
</blockquote>
<h2 id="非对称加密解惑"><a href="#非对称加密解惑" class="headerlink" title="非对称加密解惑"></a>非对称加密解惑</h2><ul>
<li>非对称加密比对称加密机密性更高吗?</li>
</ul>
<blockquote>
<p>这个问题无法回答, 以为机密性高低是根据秘钥长度而变化的</p>
</blockquote>
<ul>
<li><strong>采用1024bit 秘钥长度的非对称加密, 和采用128bit秘钥长度的对称加密中, 是秘钥更长的非对称加密更安全吗?</strong></li>
</ul>
<blockquote>
<p>不是。</p>
<p>非对称加密的密钥长度不能与对称加密的密钥长度进行直接比较。下表是一张密钥长度的比较表（本表摘自《应用密码学》），根据这张表我们可以看出，1024比特的公钥密码与128比特的对称密码相比，反而是128比特的对称密码抵御暴力破解的能力更强。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">对称加密秘钥长度</th>
<th align="center">非对称加密秘钥长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">128 比特</td>
<td align="center">2304 比特</td>
</tr>
<tr>
<td align="center">112 比特</td>
<td align="center">1792 比特</td>
</tr>
<tr>
<td align="center">80 比特</td>
<td align="center">768 比特</td>
</tr>
<tr>
<td align="center">64 比特</td>
<td align="center">512 比特</td>
</tr>
<tr>
<td align="center">56 比特</td>
<td align="center">384 比特</td>
</tr>
</tbody></table>
<ul>
<li><strong>有了非对称加密， 以后对称加密会被替代吗？</strong></li>
</ul>
<blockquote>
<p>不会</p>
<p>一般来说，在采用具备同等机密性的密钥长度的情况下，非对称加密的处理速度只有对称加密的几百分之一。因此，非对称加密并不适合用来对很长的消息内容进行加密。根据目的的不同，还可能会配合使用对称加密和非对称加密，如，混合密码系统就是将这两种密码组合而成的。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一頁"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一頁"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 強力驅動
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
